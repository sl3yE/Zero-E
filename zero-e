#!/usr/bin/env bash
banner=\
"Zero-E (z0e) by @sl3yE -- https://github.com/sl3yE/Zero-E

Support this project -- https://github.com/sponsors/sl3yE
			https://buymeacoffee.com/sl3yE
"
version="v1.5"

###Functions
function updatecheck { # Check version and update the script
    {   
        URL="https://raw.githubusercontent.com/sl3yE/zero-e/main/zero-e"
        TIMEOUT=1  # Set the maximum time (in seconds) for the curl request

        # Function to get the latest version string from the script on GitHub
        get_latest_version() {
            latest_version=$(curl -s --fail --max-time "$TIMEOUT" "$URL" | grep -m 1 '^version=' | awk -F'"' '{print $2}')
			if [ $? -ne 0 ] || [ -z "$latest_version" ]; then
                echo "Failed to fetch the latest version from GitHub"
                return 1  # Indicate failure
            fi
            echo "$latest_version"
        }
        # Function to update the script
        update_script() {
            # Ensure correct location and overwrite
            script_path="$(dirname "$0")/zero-e"
            curl -o "$script_path" --max-time "$TIMEOUT" "$URL" && chmod +x "$script_path"
            if [ $? -ne 0 ]; then
                echo "Failed to update the script -- check your internet connection or GitHub access"
                return 1
            fi
            
            # Check if zeroe is already in PATH; if so, reinstall to that location
            if command -v zeroe >/dev/null 2>&1; then
                zeroe_cmd_path="$(command -v zeroe)"
                echo "Detected Zero-E is already installed at $zeroe_cmd_path"
                echo "Reinstalling Zero-E to $zeroe_cmd_path"
                sudo cp "$script_path" "$zeroe_cmd_path" && sudo chmod +x "$zeroe_cmd_path"
                if [ $? -eq 0 ]; then
                    echo "Zero-E reinstalled successfully."
					z0e_resinstall=true
                else
                    echo "Failed to reinstall Zero-E."
                fi
            fi
        }

        latest_version=$(get_latest_version)
        # If the version fetch fails, skip the update check
        if [ $? -ne 0 ]; then
            #echo "Skipping update check due to connectivity issues."
            return 0
        fi
        # Proceed with the update check if the version fetch was successful
        if [ "$version" != "$latest_version" ]; then
            echo "A new version of Zero-E is available: $latest_version"
            read -p "Update to the latest version? <y/n>: " response
            if [ "$response" == "y" ]; then
                echo ""
                echo "Updating..."
                update_script
                if [ $? -eq 0 ]; then
                    echo ""
                    echo "Zero-E updated to $latest_version"
					if [ "$z0e_resinstall" != true ]; then
						echo "If previously installed as a command, reinstall Zero-E to \$PATH"
					fi
                    exit 0
                else
                    echo "Update failed"
                fi
            else
                echo "Continuing with the local version"
                echo ""
            fi
        fi
        # Check if script is named 'zero-e.sh' and rename
        script_name=$(basename "$0")
        if [ "$script_name" = "zero-e.sh" ]; then
            echo "z0e's script file renamed to zero-e in v1.1"
            mv "$0" "$(dirname "$0")/zero-e"
            echo "Local zero-e.sh file renamed to 'zero-e' -- please re-run z0e"
            exit 0
        fi
    } >&2
}

function settype { #Set external or internal
	if [ "$e_opt" = true ] || [ "$i_opt" = true ]; then
		if [ "$e_opt" = true ]; then
			typevar="ext"
			i_opt=false
		elif [ "$i_opt" = true ]; then
			typevar="int"
			e_opt=false
		fi
	else
		echo "[?] Perform <e>xternal or <i>nternal methodology:"
		while true; do
			read -e -p " [>] " type
			if [ "$type" = "E" ] || [ "$type" = "e" ] || [ "$type" = "external" ] || [ "$type" = "External" ] || [ "$type" = "Ext" ] || [ "$type" = "ext" ]; then
				typevar="ext"
				e_opt=true
				break
			elif [ "$type" = "I" ] || [ "$type" = "i" ] || [ "$type" = "internal" ] || [ "$type" = "Internal" ] || [ "$type" = "Int" ] || [ "$type" = "int" ]; then
				typevar="int"
				i_opt=true
				break
			else
				echo -e "\e[31m [X] Error: You must enter 'e' for external or 'i' for internal \e[0m" >&2
			fi
		done
	fi
}

function output { #sets the output dir (now two-phase: phase1 path prep, phase2 backup/cleanup)
	local commit_mode=false
	if [[ "$OUTPUT_COMMIT_MODE" == true ]]; then
		commit_mode=true
	fi

	if [ -z "$o_opt" ] && [ "$defaults" = true ]; then
		filepath="./z0e-output"
	elif [ -n "$o_opt" ]; then
		filepath="$o_opt"
	else
		echo "[?] Enter the output directory path:"
		while true; do
			read -e -p " [>] " filepath
			if [ -f "$filepath" ]; then
				echo -e "\e[31m [X] Error: File exists with the same name \e[0m" >&2
			elif [ -z "$filepath" ]; then
				echo -e "\e[31m [X] Error: You must enter a directory name or path \e[0m" >&2
			elif [[ "$filepath" == "-"* ]]; then
				echo -e "\e[31m [X] Error: Directory names starting with '-' may cause issues with commands \e[0m" >&2
			elif [[ "$filepath" == *" "* ]]; then
				echo -e "\e[31m [X] Error: To proactively avoid errors, whitespace is not allowed in file names \e[0m" >&2
			elif [[ "$filepath" == "/dev/null" ]]; then
				echo -e "\e[31m [X] Error: /dev/null cannot be used as an output directory \e[0m" >&2
			elif [ -n "$filepath" ]; then
				break
			fi
		done
	fi
	if [ "$filepath" = "." ]; then
		filepath=$(pwd)
	elif [ "$filepath" = "~" ]; then
		filepath="/home/$SUDO_USER"
	elif [[ "$filepath" = '~/'* ]]; then
		filepath=${filepath/#\~/"/home/$SUDO_USER"}
		if [ ! -d "$filepath" ];then
			mkdir -p "$filepath"
		fi
	else
		if [ ! -d "$filepath" ];then
			mkdir -p "$filepath"
		fi
	fi

	# Phase1 directory scaffolding always (or already done)
	mkdir -p $filepath/logs/ 2>/dev/null || true
	mkdir -p $filepath/logs/processed/ 2>/dev/null || true
	mkdir -p $filepath/analysis/ 2>/dev/null || true

	o_opt="$(realpath $filepath)"
	filepath="$(realpath $filepath)"

	# Flush buffered DNS map if any (safe to do in phase1)
	dns_map_sync_to_final 2>/dev/null || true

	# If not commit mode yet or already committed, return
	if [[ "$commit_mode" != true || "$OUTPUT_COMMITTED" == true ]]; then
		return 0
	fi

	# ---- Commit Phase (backup + cleanup) ----
	local shouldBackup=false
	if [ "$typevar" = "ext" ] && { \
		 [ "$(find "$filepath" -maxdepth 1 -type f -name 'ext-*' 2>/dev/null)" ]
	   }; then
		 shouldBackup=true
	elif [ "$typevar" = "int" ] && { \
		 [ "$(find "$filepath" -maxdepth 1 -type f -name 'int-*' 2>/dev/null)" ]
	   }; then
		 shouldBackup=true
	fi
	if [ "$shouldBackup" = true ]; then
		local baseDir=$(dirname "$filepath")
		local name=$(basename "$filepath")
		local prefix="${name}-z0e"
		local suffix=".bak"
		local idx=1
		while true; do
			if [ ! -d "$baseDir/$prefix$idx$suffix" ]; then
				break
			fi
			((idx++))
		done
		local newDir="$baseDir/$prefix$idx$suffix"
		# Short backup message: show only names, not full absolute paths
		local origName="$name"
		local backupName="$(basename "$newDir")"
		echo "     z0e results files detected in output directory -- backing up '$origName' -> '$backupName'"
		cp -r "$filepath" "$newDir"
	fi

	if [ "$stage" = "script-start" ] && [ "$resume" != "y" ]; then
		find "$filepath" -type f -name "${typevar}-*" -exec rm -f {} +
	fi

	OUTPUT_COMMITTED=true
	return 0
}

#############################################
# DNS resolution helpers (conditional usage)
#############################################

is_ipv4_or_range_or_cidr() {
	local t="$1"
	if [[ $t =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}(/([0-9]|[12][0-9]|3[0-2]))?$ ]]; then
		return 0
	elif [[ $t =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}-[0-9]{1,3}$ ]]; then
		return 0
	fi
	return 1
}

looks_like_hostname() {
	local t="$1"
	if is_ipv4_or_range_or_cidr "$t"; then return 1; fi
	[[ $t == *"/"* ]] && return 1
	[[ $t != *.* ]] && return 1
	[[ $t =~ [A-Za-z] ]] || return 1
	[[ $t =~ ^[A-Za-z0-9.-]+$ ]] || return 1
	return 0
}

# Simple in-script whitespace trim (avoids xargs which chokes on unmatched quotes)
trim_ws() {
	# usage: trim_ws "string" -> echoes trimmed
	local s="$1"
	# remove leading whitespace
	s="${s##[$'\t\r\n ']*}"
	# remove trailing whitespace (loop to handle pattern edge cases)
	while [[ $s =~ [[:space:]]$ ]]; do s="${s%[[:space:]]}"; done
	printf '%s' "$s"
}

# Detect whether a file contains at least one valid target/exclude token
# (IPv4 / range / CIDR or hostname pattern). Returns 0 if found, 1 otherwise.
file_has_any_valid_entry() {
	local f="$1"
	[[ -s $f ]] || return 1
	while IFS= read -r line; do
		# Strip comments after first '#'
		line="${line%%#*}"
		line="$(trim_ws "$line")"
		[[ -z $line ]] && continue
		if is_ipv4_or_range_or_cidr "$line" || looks_like_hostname "$line"; then
			return 0
		fi
	done < "$f"
	return 1
}

ensure_getent_available() {
	if command -v getent >/dev/null 2>&1; then
		return 0
	fi
	echo -e "\e[33m [!] DNS names detected but 'getent' was not found on PATH \e[0m" >&2
	read -p "     Attempt to install the required package(s)? <y/n>: " _ans
	if [[ $_ans != "y" ]]; then
		echo -e "\e[31m [X] Error: Cannot resolve DNS names without 'getent' -- exiting \e[0m" >&2
		exit 1
	fi
	local success=false
	if command -v apt-get >/dev/null 2>&1; then
		sudo apt-get update && sudo apt-get install -y libc-bin && success=true
	elif command -v yum >/dev/null 2>&1; then
		sudo yum install -y glibc-common && success=true || true
	elif command -v dnf >/dev/null 2>&1; then
		sudo dnf install -y glibc-common && success=true || true
	elif command -v apk >/dev/null 2>&1; then
		sudo apk add libc6-compat && success=true || true
	elif command -v pacman >/dev/null 2>&1; then
		sudo pacman -Sy --noconfirm glibc && success=true || true
	fi
	if ! $success; then
		echo -e "\e[31m [X] Error: Automatic installation failed or unsupported package manager. Install 'getent'/glibc utilities manually. \e[0m" >&2
		exit 1
	fi
	if ! command -v getent >/dev/null 2>&1; then
		echo -e "\e[31m [X] Error: 'getent' still not available after installation attempt. Exiting. \e[0m" >&2
		exit 1
	fi
}

# Quick DNS preflight to detect broken resolver before long scans
dns_preflight_check() {
	# Only run when starting a new scan (not on resume) and avoid forcing installs here
	if [[ "$resume" = "y" ]]; then
		return 0
	fi
	# If getent is not available, skip quietly; we'll install/require it later only if hostnames are actually used
	if ! command -v getent >/dev/null 2>&1; then
		# Soft notice; do not block or prompt installs here
		echo -e "\e[33m [!] Skipping DNS check: 'getent' not found on PATH\e[0m" >&2
		return 0
	fi

	local testers=("example.com" "nmap.org")
	local ok=0
	for hn in "${testers[@]}"; do
		local res
		if command -v timeout >/dev/null 2>&1; then
			res=$(timeout 3 getent ahostsv4 "$hn" 2>/dev/null | awk '{print $1}' | grep -E '^[0-9]+(\.[0-9]+){3}$' | head -n1)
		else
			res=$(getent ahostsv4 "$hn" 2>/dev/null | awk '{print $1}' | grep -E '^[0-9]+(\.[0-9]+){3}$' | head -n1)
		fi
		if [[ -n "$res" ]]; then
			ok=1
			break
		fi
	done

	if [[ $ok -eq 0 ]]; then
		echo -e "\e[33m [!] DNS check: Failed to resolve example.com or nmap.org\e[0m" >&2
		echo -e "\e[33m     Name resolution appears broken -- Hostname-to-IP features and rDNS in scans may fail.\e[0m" >&2
		read -r -p "     Continue anyway? <y/N>: " ans
		ans=${ans:-N}
		if [[ ! "$ans" =~ ^[Yy]$ ]]; then
			echo -e "\e[31m [X] Aborting at user request -- Fix DNS (e.g., /etc/resolv.conf, DNS server reachability) and retry.\e[0m" >&2
			exit 1
		fi
	fi
}

# DNS mapping helpers: buffer before $filepath is set; write to final once available
dns_map_append() {
	local line="$1"
	# If output dir is known, write directly to final mapping file
	if [[ -n "${filepath:-}" ]]; then
		local _tv
		if [[ -n "${typevar:-}" ]]; then _tv="$typevar";
		elif [[ "$e_opt" = true ]]; then _tv="ext";
		elif [[ "$i_opt" = true ]]; then _tv="int";
		else _tv=""; fi
		local final="${filepath}/logs/${_tv:+${_tv}-}dns-resolutions.txt"
		mkdir -p "${filepath}/logs" 2>/dev/null || true
		[[ -f "$final" ]] || : > "$final"
		echo "$line" >> "$final" 2>/dev/null || true
		return 0
	fi
	# Otherwise, buffer to /tmp until output dir is known
	if [[ -z "${DNS_MAP_BUFFER:-}" ]]; then
		DNS_MAP_BUFFER="/tmp/zeroe_dns_map_${session:-nosession}_$$.txt"
	fi
	echo "$line" >> "$DNS_MAP_BUFFER" 2>/dev/null || true
}

dns_map_sync_to_final() {
	# If there's a buffer and output dir is now known, flush it to final and clear the buffer
	[[ -n "${DNS_MAP_BUFFER:-}" ]] || return 0
	[[ -s "$DNS_MAP_BUFFER" ]] || return 0
	[[ -n "${filepath:-}" ]] || return 0
	local _tv
	if [[ -n "${typevar:-}" ]]; then _tv="$typevar";
	elif [[ "$e_opt" = true ]]; then _tv="ext";
	elif [[ "$i_opt" = true ]]; then _tv="int";
	else _tv=""; fi
	local final="${filepath}/logs/${_tv:+${_tv}-}dns-resolutions.txt"
	mkdir -p "${filepath}/logs" 2>/dev/null || true
	[[ -f "$final" ]] || : > "$final"
	cat "$DNS_MAP_BUFFER" >> "$final" 2>/dev/null || true
	rm -f "$DNS_MAP_BUFFER" 2>/dev/null || true
	unset DNS_MAP_BUFFER
}

resolve_dns_in_metadata() {
	local metadata_file_ref="$1"
	local raw_file_ref="$2"
	local original_metadata="$metadata_file_ref"
	local original_raw="$raw_file_ref"
	local hostnames=()
	while IFS= read -r line; do
		local val
		val="${line##*__ }"
		if looks_like_hostname "$val"; then
			hostnames+=("$val")
		fi
	done < "$original_metadata"
	if [[ ${#hostnames[@]} -eq 0 ]]; then
		return 0
	fi
	ensure_getent_available
	# DNS mapping lines will be appended via dns_map_append; it buffers until output dir is known
	local resolved_tmp_ips
	resolved_tmp_ips=$(mktemp /tmp/targets_dns_resolved.XXXXXX)
	local new_metadata
	new_metadata=$(mktemp /tmp/targets_single_ips.metadata.resolved.XXXXXX)
	local new_raw
	new_raw=$(mktemp /tmp/targets_single_ips.raw.resolved.XXXXXX)
	declare -A RESOLVED_CACHE
	local unresolved=()
	local total_resolved_ips=0
	local total_dns=${#hostnames[@]}
	local processed_dns=0
	local progress_step=${DNS_PROGRESS_STEP:-50}
	echo -e "     Resolving ${#hostnames[@]} DNS name(s)..." >&2
	for hn in "${hostnames[@]}"; do
		if [[ -n "${RESOLVED_CACHE[$hn]}" ]]; then
			continue
		fi
		processed_dns=$((processed_dns+1))
		if (( processed_dns % progress_step == 0 )); then
			local pct=$(( processed_dns * 100 / total_dns ))
			printf "\r     Resolving DNS names: %d/%d (%d%%)..." "$processed_dns" "$total_dns" "$pct" >&2
		fi
		local resolved
		resolved=$(getent ahostsv4 "$hn" 2>/dev/null | awk '{print $1}' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' | sort -u)
		if [[ -z "$resolved" ]]; then
			unresolved+=("$hn")
			RESOLVED_CACHE[$hn]="__UNRESOLVED__"
		else
			RESOLVED_CACHE[$hn]="$resolved"
			local joined
			joined=$(echo "$resolved" | tr '\n' ',' | sed 's/,$//')
			dns_map_append "$hn -> $joined"
			while IFS= read -r ip; do
				echo "$ip" >> "$resolved_tmp_ips"
				((total_resolved_ips++))
			done < <(echo "$resolved")
		fi
	done
	printf "\r\e[K" >&2
	if [[ ${#unresolved[@]} -gt 0 ]]; then
		echo -e "\e[31m [X] Error: Failed to resolve the following DNS name(s):\e[0m" >&2
		for hn in "${unresolved[@]}"; do
			echo -e "\e[31m      - $hn\e[0m" >&2
		done
		if [[ "$interactive_targets" = true ]]; then
			# In interactive mode, do not exit; let caller re-prompt
			return 1
		else
			echo -e "\e[33m [!] Aborting -- resolve manually or remove from targets. \e[0m" >&2
			exit 1
		fi
	fi
	while IFS= read -r line; do
		local prefix val
		prefix="${line%%__ *}__"
		val="${line##*__ }"
		if looks_like_hostname "$val"; then
			while IFS= read -r ip; do
				echo "$prefix $ip" >> "$new_metadata"
				echo "$ip" >> "$new_raw"
			done < <(echo "${RESOLVED_CACHE[$val]}" | tr ' ' '\n' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$')
		else
			echo "$line" >> "$new_metadata"
			echo "$val" >> "$new_raw"
		fi
	done < "$original_metadata"
	mv "$new_metadata" "$original_metadata"
	mv "$new_raw" "$original_raw"
	if [[ $total_resolved_ips -gt 0 ]]; then
		echo -e "     Resolved ${#hostnames[@]} DNS name(s) to $total_resolved_ips IPv4 address(es)" >&2
	fi
}

resolve_dns_in_file() {
	local file="$1"
	[[ -f $file ]] || return 0
	local hostnames=()
	while IFS= read -r line; do
		# Use trim_ws instead of external xargs to avoid unmatched quote errors
		local t="$(trim_ws "$line")"
		[[ -z $t ]] && continue
		if looks_like_hostname "$t"; then
			hostnames+=("$t")
		fi
	done < "$file"
	if [[ ${#hostnames[@]} -eq 0 ]]; then
		# No hostnames; use original file as-is
		RESOLVED_DNS_FILE="$file"
		return 0
	fi
	ensure_getent_available
	# DNS mapping lines will be appended via dns_map_append; it buffers until output dir is known
	local temp_out
	temp_out=$(mktemp /tmp/targets_dns_file_resolved.XXXXXX)
	local unresolved=()
	local total_resolved_ips=0
	local total_dns=${#hostnames[@]}
	local processed_dns=0
	local progress_step=${DNS_PROGRESS_STEP:-50}
	echo -e "     Resolving ${#hostnames[@]} DNS name(s)..." >&2
	while IFS= read -r line; do
		# Use trim_ws instead of xargs for robust whitespace trimming
		local t="$(trim_ws "$line")"
		if looks_like_hostname "$t"; then
			processed_dns=$((processed_dns+1))
			if (( processed_dns % progress_step == 0 )); then
				local pct=$(( processed_dns * 100 / total_dns ))
				printf "\r     Resolving DNS names: %d/%d (%d%%)..." "$processed_dns" "$total_dns" "$pct" >&2
			fi
			local resolved
			resolved=$(getent ahostsv4 "$t" 2>/dev/null | awk '{print $1}' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' | sort -u)
			if [[ -z $resolved ]]; then
				unresolved+=("$t")
			else
				local joined
				joined=$(echo "$resolved" | tr '\n' ',' | sed 's/,$//')
				dns_map_append "$t -> $joined"
				while IFS= read -r ip; do
					echo "$ip" >> "$temp_out"
					((total_resolved_ips++))
				done < <(echo "$resolved")
			fi
		else
			echo "$t" >> "$temp_out"
		fi
	done < "$file"
	printf "\r\e[K" >&2
	if [[ ${#unresolved[@]} -gt 0 ]]; then
		echo -e "\e[31m [X] Error: Failed to resolve the following DNS name(s):\e[0m" >&2
		for hn in "${unresolved[@]}"; do
			echo -e "\e[31m      - $hn\e[0m" >&2
		done
		if [[ "$interactive_targets" = true ]]; then
			# In interactive mode, do not exit; let caller re-prompt
			rm -f "$temp_out"
			RESOLVED_DNS_FILE=""
			return 1
		else
			echo -e "\e[33m [!] Aborting -- resolve them manually or remove them from targets. \e[0m" >&2
			rm -f "$temp_out"
			RESOLVED_DNS_FILE=""
			exit 1
		fi
	fi
	# Do not overwrite the original file; consumers should use RESOLVED_DNS_FILE
	RESOLVED_DNS_FILE="$temp_out"
	if [[ $total_resolved_ips -gt 0 ]]; then
		echo -e "     Resolved ${#hostnames[@]} DNS name(s) to $total_resolved_ips IPv4 address(es)" >&2
	fi
}

function targets {  # Sets the targets file
    if [[ "$session_flag" = true && -n "$session" ]]; then
        session_dir="/var/lib/zeroe/sessions/$session"
        targets_file="$session_dir/targets-single-ips.z0e"
    else
        targets_file="/var/lib/zeroe/targets-single-ips.z0e"
    fi
    ################################################################
    # 1) If t_opt is a single existing, non-empty file with no IP pattern, just use it
    ################################################################
    if [ -n "$t_opt" ] && [ -f "$t_opt" ] && [ -s "$t_opt" ] \
       && ! [[ "$t_opt" =~ [0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ ]] \
       && [[ "$t_opt" != *","* ]]
    then
	ips="$t_opt"
	resolve_dns_in_file "$ips"
	# Use the resolved temp file if provided, otherwise original
	ips="${RESOLVED_DNS_FILE:-$ips}"
	checkfile="$ips"
	checkinvalidips
    ################################################################
    # 2) Else if t_opt is a comma‚Äêseparated list (or includes IP pattern),
    #    merge them (just like the -t option)
    ################################################################
    elif [ -n "$t_opt" ] && (
         { ! [ -f "$t_opt" ] && [[ "$t_opt" =~ [0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ ]]; } \
         || [[ "$t_opt" == *","* ]]
       )
    then
		IFS=',' read -ra token_array <<< "$t_opt"
        # build 2 parallel files:
        #   metadata_file => lines have a prefix for "FILE" or "INPUT"
        #   raw_file      => lines have no prefix (the actual IP or range)
        metadata_file=$(mktemp /tmp/targets_single_ips.metadata.XXXXXX)
        raw_file=$(mktemp /tmp/targets_single_ips.raw.XXXXXX)
        > "$metadata_file"
        > "$raw_file"
        anyerrors=false
        for token in "${token_array[@]}"; do
			trimmed_token="$(trim_ws "$token")"
            if [ -f "$trimmed_token" ]; then
                # If it's a file, ensure non-empty
                if [ ! -s "$trimmed_token" ]; then
                    echo -e "\e[31m [X] Error: '$trimmed_token' is empty \e[0m" >&2
                    anyerrors=true
                    break
                fi
                # Merge its lines
                while IFS= read -r fileline; do
                    echo "__SRC:FILE:${trimmed_token}__ $fileline" >> "$metadata_file"
                    echo "$fileline" >> "$raw_file"
                done < "$trimmed_token"
            else
                # It's an IP or range
                echo "__SRC:INPUT__ $trimmed_token" >> "$metadata_file"
                echo "$trimmed_token" >> "$raw_file"
            fi
        done
        if $anyerrors; then
            exit 1
        fi
        # Resolve any DNS names before validation; abort if any cannot be resolved
		if ! resolve_dns_in_metadata "$metadata_file" "$raw_file"; then
			exit 1
		fi
		# Validate the flattened raw file (IPs only after resolution)
		checkfile="$raw_file"
		checkinvalidips
        # If validation passed, we set ips to the raw file
        # so the rest of the function sees no metadata lines
        ips="$raw_file"
    ################################################################
    # 3) If the user didn't set t_opt or set an invalid one,
    #    handle the defaults or prompt logic
    ################################################################
    elif [[ -z "$t_opt" && "$defaults" = true ]]; then
        ips="targets.txt"
        if [[ ! -f "$ips" ]]; then
            echo -e "\e[31m [X] Error: The default targets file (./targets.txt) does not exist \e[0m" >&2
            exit 1
        elif [ ! -s "$ips" ]; then
            echo -e "\e[31m [X] Error: $ips is empty \e[0m" >&2
            exit 1
        fi
		resolve_dns_in_file "$ips"
		ips="${RESOLVED_DNS_FILE:-$ips}"
		checkfile="$ips"
		checkinvalidips
	elif [ -n "$t_opt" ]; then
        # t_opt is set but doesn't fit the above patterns
        if [[ "$t_opt" == "-"* ]]; then
            echo -e "\e[31m [X] Error: File names starting with '-' may cause issues with commands \e[0m" >&2
            exit 1
        elif [[ "$t_opt" == *" "* ]]; then
            echo -e "\e[31m [X] Error: To proactively avoid errors, whitespace is not allowed in file names \e[0m" >&2
            exit 1
        elif [ ! -s "$t_opt" ]; then
            echo -e "\e[31m [X] Error: $t_opt is empty or doesn't exist \e[0m" >&2
            exit 1
        fi
		ips="$t_opt"
		# Resolve any hostnames before validation (non-destructive)
		resolve_dns_in_file "$ips"
		ips="${RESOLVED_DNS_FILE:-$ips}"
		checkfile="$ips"
		checkinvalidips
    else
        ################################################################
        # 4) Interactive prompt logic
        ################################################################
		echo "[?] Enter the target IP address(es), filename(s), and/or DNS name(s): "
		interactive_targets=true
		while true; do
            read -e -p " [>] " user_input

            if [[ -z "$user_input" ]]; then
                echo -e "\e[31m [X] Error: You must enter the target IP address(es), filename(s), and/or DNS name(s) \e[0m" >&2
                continue
            fi
            if [ -f "$user_input" ] && [ -s "$user_input" ] \
               && ! [[ "$user_input" =~ [0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ ]] \
               && [[ "$user_input" != *","* ]]
            then
				# Single existing file
                ips="$user_input"
				targets_userInput="$ips"
				if resolve_dns_in_file "$ips"; then
					ips="${RESOLVED_DNS_FILE:-$ips}"
					checkfile="$ips"
					checkinvalidips
				else
					continue
				fi
				if [[ "$allvalid" = 1 ]]; then
                    t_opt="$ips"
                    break
				else
					if [[ -f "$ips" ]]; then
						lines_total=$(wc -l < "$ips" 2>/dev/null || echo 0)
						echo -e "\e[31m [X] '$user_input' contains no valid IP/range/CIDR/DNS entries \e[0m" >&2
					fi
                fi
            elif { ! [ -f "$user_input" ] && [[ "$user_input" =~ [0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ ]]; } \
                 || [[ "$user_input" == *","* ]]
            then
				targets_userInput="$user_input"
                # Merge tokens
                IFS=',' read -ra token_array <<< "$user_input"
                metadata_file=$(mktemp /tmp/targets_single_ips.metadata.XXXXXX)
                raw_file=$(mktemp /tmp/targets_single_ips.raw.XXXXXX)
                > "$metadata_file"
                > "$raw_file"
                anyerrors=false
                for token in "${token_array[@]}"; do
					trimmed_token="$(trim_ws "$token")"
                    if [ -f "$trimmed_token" ]; then
                        if [ ! -s "$trimmed_token" ]; then
                            echo -e "\e[31m [X] Error: '$trimmed_token' is empty \e[0m" >&2
                            anyerrors=true
                            break
                        fi
                        while IFS= read -r fileline; do
                            echo "__SRC:FILE:${trimmed_token}__ $fileline" >> "$metadata_file"
                            echo "$fileline" >> "$raw_file"
                        done < "$trimmed_token"
                    else
                        echo "__SRC:INPUT__ $trimmed_token" >> "$metadata_file"
                        echo "$trimmed_token" >> "$raw_file"
                    fi
                done
                if $anyerrors; then
                    continue  # Re-prompt
                fi
				if resolve_dns_in_metadata "$metadata_file" "$raw_file"; then
					checkfile="$metadata_file"
					checkinvalidips
				else
					# DNS error(s) reported; re-prompt user
					continue
				fi
                if [[ "$allvalid" = 1 ]]; then
                    ips="$raw_file"
                    t_opt="$ips"
                    break
				else
					meta_lines=$(wc -l < "$metadata_file" 2>/dev/null || echo 0)
					echo -e "\e[31m [X] Entered list contains no valid targets (processed $meta_lines token line(s)) \e[0m" >&2
                fi
			else
				# Single token handling: if it's not a file, not an IP/range/CIDR, and has no commas, treat as hostname
				if [[ ! -f "$user_input" ]] && [[ ! "$user_input" =~ [0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ ]] && [[ "$user_input" != *","* ]]; then
					# Create a temporary file to reuse existing file-based resolution & validation workflow
					temp_host_file=$(mktemp /tmp/z0e_single_host.XXXXXX)
					echo "$user_input" > "$temp_host_file"
					ips="$temp_host_file"
					targets_userInput="$user_input"
					# Resolve now (if hostname) and validate; on failure re-prompt
					if resolve_dns_in_file "$ips"; then
						ips="${RESOLVED_DNS_FILE:-$ips}"
						checkfile="$ips"
						checkinvalidips
					else
						continue
					fi
					if [[ "$allvalid" = 1 ]]; then
						t_opt="$ips"
						break
					else
						lines_total=$(wc -l < "$ips" 2>/dev/null || echo 0)
						echo -e "\e[31m [X] '$user_input' contains no valid targets \e[0m" >&2
						 continue
					fi
				else
					# Possibly a single file with IP pattern or a non-existent file
					if [[ ! -f "$user_input" ]]; then
						echo -e "\e[31m [X] Error: $user_input is not a file or a valid IP list \e[0m" >&2
					elif [ ! -s "$user_input" ]; then
						echo -e "\e[31m [X] Error: $user_input is empty \e[0m" >&2
					else
						# It's an existing file but might also look like an IP pattern or commas treat it as file anyway
						ips="$user_input"
						targets_userInput="$ips"
						resolve_dns_in_file "$ips"
						ips="${RESOLVED_DNS_FILE:-$ips}"
						checkfile="$ips"
						checkinvalidips
						if [[ "$allvalid" = 1 ]]; then
							t_opt="$ips"
							break
						else
							lines_total=$(wc -l < "$ips" 2>/dev/null || echo 0)
							echo -e "\e[31m [X] '$user_input' contains no valid targets \e[0m" >&2
						fi
					fi
				fi
			fi
	done
	interactive_targets=false
    fi
	# If interactive mode produced a temp file containing an unresolved single hostname, resolve it now
	if [[ -f "$ips" ]] \
	   && grep -Eq '^[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' "$ips" \
	   && ! grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' "$ips"; then
		resolve_dns_in_file "$ips"
		ips="${RESOLVED_DNS_FILE:-$ips}"
		checkfile="$ips"
		checkinvalidips
	fi
    ################################################################
    # 5) final block
    ################################################################
	t_opt="$(realpath "$ips")"
    ips="$(realpath "$ips")"
	checkfile="$ips"
	geniplist "$ips" > "$targets_file" &
	GEN_PID=$!
	status_msg="     Generating temporary list of single IP addresses for targets..."
	# Print spinner to stderr to avoid corrupting stdout prompts
	use_stderr=true
	statusgeniplist "$GEN_PID"
	wait "$GEN_PID"
    ips="$targets_file"
    t_opt="$targets_file"
}

function excludes { # Sets the excludes file (parity with targets)
	# Idempotency: rely on EXCLUDES_ALREADY_RAN instead of EXCLUDES_OPT (which only signals user supplied -x)
	if [[ "$EXCLUDES_ALREADY_RAN" == true ]]; then
		return 0
	fi
	# Global nullexcludes path
	mkdir -p /var/lib/zeroe
	touch /var/lib/zeroe/nullexcludes.z0e
	nullexcludes="/var/lib/zeroe/nullexcludes.z0e"

	# Session-based excludes output (canonical single IP list)
	if [[ "$session_flag" = true && -n "$session" ]]; then
		session_dir="/var/lib/zeroe/sessions/$session"
		excludes_file="$session_dir/excludes-single-ips.z0e"
	else
		excludes_file="/var/lib/zeroe/excludes-single-ips.z0e"
	fi

	# 1) defaults path when -x omitted and defaults mode
	if [[ -z "$x_opt" && "$defaults" = true ]]; then
		nostrikes="$nullexcludes"

	# 2) Non-empty -x provided: could be a file, a list, or direct IP/hostname(s)
	elif [[ -n "$x_opt" ]]; then
		if [ -f "$x_opt" ] && [ -s "$x_opt" ] \
		   && ! [[ "$x_opt" =~ [0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ ]] \
		   && [[ "$x_opt" != *","* ]]
		then
			# Reject files that have no valid entries (prevents treating arbitrary text as excludes)
			if ! file_has_any_valid_entry "$x_opt"; then
				echo -e "\e[31m [X] Error: -x file '$x_opt' contains no valid IPs or hostnames \e[0m" >&2
				exit 1
			fi
			# Single file (may contain hostnames) -> resolve first
			resolve_dns_in_file "$x_opt"
			nostrikes="${RESOLVED_DNS_FILE:-$x_opt}"
			checkfile="$nostrikes"; checkinvalidips
		elif looks_like_hostname "$x_opt"; then
			# Single bare hostname provided -> build temporary metadata/raw just like composite path
			metadata_file=$(mktemp /tmp/excludes_single_ips.metadata.XXXXXX)
			raw_file=$(mktemp /tmp/excludes_single_ips.raw.XXXXXX)
			echo "__SRC:INPUT__ $x_opt" >> "$metadata_file"
			echo "$x_opt" >> "$raw_file"
			if ! resolve_dns_in_metadata "$metadata_file" "$raw_file"; then
				echo -e "\e[31m [X] Error: DNS resolution failed for hostname '$x_opt' \e[0m" >&2; exit 1
			fi
			checkfile="$metadata_file"; checkinvalidips
			if [[ "$allvalid" -eq 1 ]]; then
				nostrikes="$raw_file"
			else
				exit 1
			fi
		elif [[ ( ! -f "$x_opt" && "$x_opt" =~ [0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ ) || "$x_opt" == *","* ]]; then
			# Composite input: comma list of tokens (files and/or entries)
			IFS=',' read -ra token_array <<< "$x_opt"
			metadata_file=$(mktemp /tmp/excludes_single_ips.metadata.XXXXXX)
			raw_file=$(mktemp /tmp/excludes_single_ips.raw.XXXXXX)
			anyerrors=false
			for token in "${token_array[@]}"; do
				trimmed="$(trim_ws "$token")"
				if [ -f "$trimmed" ]; then
					if [ ! -s "$trimmed" ]; then
						echo -e "\e[31m [X] Error: '$trimmed' is empty \e[0m" >&2
						anyerrors=true; break
					fi
					while IFS= read -r line; do
						echo "__SRC:FILE:${trimmed}__ $line" >> "$metadata_file"
						echo "$line" >> "$raw_file"
					done < "$trimmed"
				else
					echo "__SRC:INPUT__ $trimmed" >> "$metadata_file"
					echo "$trimmed" >> "$raw_file"
				fi
			done
			if $anyerrors; then exit 1; fi
			resolve_dns_in_metadata "$metadata_file" "$raw_file"
			checkfile="$metadata_file"; checkinvalidips
			if [[ "$allvalid" -eq 1 ]]; then
				nostrikes="$raw_file"
			else
				exit 1
			fi
		else
			# Treat as single file or raise error
			if [[ "$x_opt" == "-"* ]]; then
				echo -e "\e[31m [X] Error: File names starting with '-' may cause issues \e[0m" >&2; exit 1
			elif [[ "$x_opt" == *" "* ]]; then
				echo -e "\e[31m [X] Error: Whitespace not allowed in file names \e[0m" >&2; exit 1
			elif [ ! -s "$x_opt" ] && [ "$x_opt" != "$nullexcludes" ]; then
				echo -e "\e[31m [X] Error: '$x_opt' is empty or doesn't exist \e[0m" >&2; exit 1
			fi
			nostrikes="$x_opt"
			checkfile="$nostrikes"; checkinvalidips
		fi

	# 3) Interactive prompt (no -x and not defaults)
	else
		echo "[?] Enter the excluded IP addresses and/or filename(s) -- if none, press <enter>: "
		excludesprompt=true
		while true; do
			read -e -p " [>] " nostrikes
			if [[ -z "$nostrikes" ]]; then
				nostrikes="$nullexcludes"; break
			elif [ -f "$nostrikes" ] && [ -s "$nostrikes" ] \
				 && ! [[ "$nostrikes" =~ [0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ ]] \
				 && [[ "$nostrikes" != *","* ]]
			then
				# Single file
				exc_log="$nostrikes"
				checkfile="$nostrikes"; checkinvalidips
				if [[ "$allvalid" = 1 ]]; then
					x_opt="$nostrikes"; excludesprompt=false; break
				fi
			elif looks_like_hostname "$nostrikes"; then
				# Single hostname entered interactively
				exc_log="$nostrikes"
				metadata_file=$(mktemp /tmp/excludes_single_ips.metadata.XXXXXX)
				raw_file=$(mktemp /tmp/excludes_single_ips.raw.XXXXXX)
				echo "__SRC:INPUT__ $nostrikes" >> "$metadata_file"
				echo "$nostrikes" >> "$raw_file"
				if ! resolve_dns_in_metadata "$metadata_file" "$raw_file"; then
					echo -e "\e[31m [X] Error: DNS resolution failed for hostname '$nostrikes' \e[0m" >&2
					continue
				fi
				checkfile="$metadata_file"; checkinvalidips
				if [[ "$allvalid" = 1 ]]; then
					nostrikes="$raw_file"; x_opt="$raw_file"; excludesprompt=false; break
				fi
			elif [[ ( ! -f "$nostrikes" && "$nostrikes" =~ [0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ ) || "$nostrikes" == *","* ]]; then
				# Composite interactive input
				exc_log="$nostrikes"
				IFS=',' read -ra token_array <<< "$nostrikes"
				metadata_file=$(mktemp /tmp/excludes_single_ips.metadata.XXXXXX)
				raw_file=$(mktemp /tmp/excludes_single_ips.raw.XXXXXX)
				anyerrors=false
				for token in "${token_array[@]}"; do
					trimmed="$(trim_ws "$token")"
					if [ -f "$trimmed" ]; then
						if [ ! -s "$trimmed" ]; then
							echo -e "\e[31m [X] Error: '$trimmed' is empty \e[0m" >&2
							anyerrors=true; break
						fi
						while IFS= read -r line; do
							echo "__SRC:FILE:${trimmed}__ $line" >> "$metadata_file"
							echo "$line" >> "$raw_file"
						done < "$trimmed"
					else
						echo "__SRC:INPUT__ $trimmed" >> "$metadata_file"
						echo "$trimmed" >> "$raw_file"
					fi
				done
				if $anyerrors; then continue; fi
				resolve_dns_in_metadata "$metadata_file" "$raw_file"
				checkfile="$metadata_file"; checkinvalidips
				if [[ "$allvalid" = 1 ]]; then
					nostrikes="$raw_file"; x_opt="$raw_file"; excludesprompt=false; break
				fi
			else
				# Error or single file without commas/IP pattern
				if [[ ! -f "$nostrikes" ]]; then
					echo -e "\e[31m [X] Error: You must pass an existing file(s) and/or comma-separated IP list \e[0m" >&2
				elif [ ! -s "$nostrikes" ]; then
					echo -e "\e[31m [X] Error: '$nostrikes' is empty \e[0m" >&2
				else
					exc_log="$nostrikes"; checkfile="$nostrikes"; checkinvalidips
					if [[ "$allvalid" = 1 ]]; then
						x_opt="$nostrikes"; excludesprompt=false; break
					fi
				fi
			fi
		done
	fi

	# 4) Canonical single-IP expansion (skip if nullexcludes placeholder)
	if [[ "$nostrikes" != "$nullexcludes" ]]; then
		# If raw file still may contain hostnames (single file path branch that had no hostnames earlier), attempt resolution again (idempotent)
		if resolve_dns_in_file "$nostrikes"; then
			nostrikes="${RESOLVED_DNS_FILE:-$nostrikes}"
			checkfile="$nostrikes"; checkinvalidips
		else
			echo -e "\e[31m [X] Error: DNS resolution failure in excludes list \e[0m" >&2; exit 1
		fi
		x_opt="$(realpath "$nostrikes")"
		nostrikes="$(realpath "$nostrikes")"
		checkfile="$nostrikes"
		geniplist "$nostrikes" > "$excludes_file" &
		GEN_PID=$!
		status_msg="     Generating temporary list of single IP addresses for excludes..."
		use_stderr=true
		statusgeniplist "$GEN_PID"; wait "$GEN_PID"
		nostrikes="$excludes_file"; x_opt="$excludes_file"
	fi
}

function enableudp { #Enables UDP scans
	if [[ "$only_flag" == true ]] && ([[ "$S_opt" == "discovery-hosts" ]] || [[ "$S_opt" == "discovery-ports" ]] || [[ "$S_opt" == "services-tcp" ]] || [[ "$stage" == "discovery-hosts" ]] || [[ "$stage" == "discovery-ports" ]] || [[ "$stage" == "services-tcp" ]]); then # Check if --only flag is set with a TCP-only stage
		echo "[?] <E>nable or <d>isable UDP scans:"
		echo -e "\e[33m [!] Configured to only run a TCP stage -- UDP scans disabled \n\e[0m"
		udp="n"
		U_opt=false
		u_opt=true
	elif [[ "$u_opt" = false && "$U_opt" = false && "$defaults" = true ]]; then
		udp="y"
		U_opt=true
	elif [ "$U_opt" = true ]; then
		udp="y"
	elif [ "$u_opt" = true ]; then
		udp="n"
	else
		echo "[?] <E>nable or <d>isable UDP scans:"
		while true; do
			read -e -p " [>] " udp
				if [ "$udp" = "e" ] || [ "$udp" = "E" ] || [ "$udp" = "enable" ] || [ "$udp" = "Enable" ] || [ "$udp" = "d" ] || [ "$udp" = "D" ] || [ "$udp" = "disable" ] || [ "$udp" = "Disable" ]; then
					break
				else
					echo -e "\e[31m [X] Error: You must enter 'e', 'enable', 'd', or 'disable' \e[0m" >&2
				fi
		done
		if [ "$udp" = "e" ] || [ "$udp" = "E" ] || [ "$udp" = "enable" ] || [ "$udp" = "Enable" ]; then
			udp="y"
			U_opt=true
			u_opt=false
		elif [ "$udp" = "d" ] || [ "$udp" = "D" ] || [ "$udp" = "disable" ] || [ "$udp" = "Disable" ]; then
			udp="n"
			U_opt=false
			u_opt=true
		fi
	fi

	if [[ "$u_opt" = true || "$udp" = "n" ]] && [[ "$S_opt" = *"udp" || "$stage" = *"udp" ]]; then #If UDP scans are disabled, but UDP stage is selected
		echo -e "\e[31m [X] Error: A UDP stage cannot be selected if UDP scans are disabled \e[0m" >&2
		exit 1
	fi

	if [[ "$only_flag" == true ]] && ([[ "$U_opt" == true ]] || [[ "$udp" == "y" ]]) && [[ "$S_opt" != *"udp"* && "$stage" != *"udp"* ]] && [[ "$stage" != "script-start" && "$stage" != "discovery-lists" ]]; then #If only UDP scans are enabled, but TCP stage is selected
		echo -e "\e[31m [X] Error: A TCP stage cannot be selected if only UDP scans are enabled \e[0m" >&2
		exit 1
	fi
}	

function filtersusips { #filters out IPs that may be deception hosts
	# masscan greppable format has IP in $2 on Host lines
	awk -v out="$susips" '
	/Host/ {
		ip[$2]++;
	}
	END {
		for (i in ip) {
			if (ip[i] > 100) {
				print i >> out;
			}
		}
	}' "$susinput" 2>>"$filepath/logs/$typevar-errors.log"
	if [ -f "$susips" ]; then
		awk 'FNR==NR {sus_ips[$0]=1; next} !($2 in sus_ips)' "$susips" "$susinput" >> "$susoutput" 2>>"$filepath/logs/$typevar-errors.log"
	else
		cat "$susinput" >> "$susoutput" 2>>"$filepath/logs/$typevar-errors.log"
	fi
}

function singleportstorange { #Converts individual sequential port numbers into a range
	awk '
	BEGIN{start=end=""}
	{
	    if(start == ""){
	        start=end=$1;
	    }
	    else if($1 == end+1){
	        end=$1;
	    }
	    else{
	        if(start == end)
	            print start;
	        else
	            print start"-"end;
	        start=end=$1;
	    }
	}
	END{
	    if(start == end)
	        print start;
	    else
	        print start"-"end;
	}' <(sort -n "$filepath/rangetemp.txt") >> $rangeout
	rm "$filepath/rangetemp.txt"
	#sed -i '/^[ \t]*$/d' "$checkfile" #cant remember why i had $checkfiles here. its only ever set to $ips and $nostrikes
	sed -i '/^[ \t]*$/d' "$rangeout" #Removes blank lines and lines that only contain spaces
	sort -u -o "$rangeout" "$rangeout"
}

function checkinvalidips { #Checks targets file for invalid entries
    dos2unix -q "$checkfile"
    sed -i '/^[ \t]*$/d' "$checkfile"  # remove blank lines
    sed -i 's/^[[:space:]]*//; s/[[:space:]]*$//' "$checkfile" # remove leading/trailing whitespace

    #Regex pattern to match single IPv4 addresses, ranges, etc.
    ip_single='^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$'
    ip_range_full='^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])-(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$'
    ip_cidr='^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\/([0-9]|[1-2][0-9]|3[0-2])$'
	ip_range_anyoct='^((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])-([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))$|^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])-([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))$|^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])-([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))$|^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])-([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])))$'

    anyinvalid=0

    # Pattern to detect the source prefix:
    #   __SRC:FILE:(somefile)__ actual_line
    #   __SRC:INPUT__ actual_line
    prefix_regex='^__SRC:(FILE|INPUT)(:([^[:space:]]+))?__[[:space:]]+(.*)$'
    # Explanation:
    #  ^__SRC:(FILE|INPUT) => "FILE" or "INPUT"
    #  (:([^[:space:]]+))? => optionally captures the filename after a colon (no spaces)
    #  __ => literal double underscore
    #  [[:space:]]+ => space(s) after the prefix
    #  (.*)$ => the rest is the actual IP/range line

	# Track whether any valid lines were encountered (for summary when no valid lines)
	local saw_valid_line=false
	# Buffer invalid entry messages when in geniplist mode so we can decide what to print at end
	local -a invalid_msgs=()
	# Track total processed lines for potential summary optimization
	local total_processed=0
	# Capture up to a small preview of invalid lines if file is entirely invalid (non-geniplist interactive/file mode)
	local -a preview_invalid_lines=()
	local preview_limit=8
	while IFS= read -r rawline || [[ -n "$rawline" ]]; do
        # 1) Parse out the source
        srcType=""
        fileSource=""
        line="$rawline"

        if [[ "$rawline" =~ $prefix_regex ]]; then
            srcType="${BASH_REMATCH[1]}"  # "FILE" or "INPUT"
            fileSource="${BASH_REMATCH[3]}"  # e.g. "test-ip.txt"
            line="${BASH_REMATCH[4]}"       # the actual IP/range line
        else
            # If no prefix, fallback to older logic. Possibly from a single-file scenario.
            srcType="FILE"
            fileSource="$checkfile"
            # 'line' is already set to "$rawline"
        fi

        # 2) Decide whether we consider it "entered IPs" or "file lines"
        if [[ "$srcType" == "INPUT" ]]; then
            enteredips=true
        else
            enteredips=false
        fi

        # 3) If the file ended up empty after removing blank lines
        if [ ! -s "$checkfile" ]; then
            echo -e "\e[31m [X] Error: $checkfile is empty \e[0m" >&2
        fi

		# 4) Check the line against the IP patterns
		((total_processed++))
		if [[ "$line" =~ $ip_single ]] || [[ "$line" =~ $ip_cidr ]] || [[ "$line" =~ $ip_range_full ]]; then
			 saw_valid_line=true
		elif [[ "$line" =~ $ip_range_anyoct ]]; then
            # It's an improperly formatted range that masscan cannot parse
			if [[ "$enteredips" = true ]]; then
				if [[ "$geniplistopt" == true ]]; then
					invalid_msgs+=("[X] Error: $line is an improperly formatted range")
				else
					echo -e "\e[31m [X] Error: $line is an improperly formatted range \e[0m" >&2
					echo -e "\e[31m            IP address ranges must be in the format x.x.x.x-y.y.y.y \e[0m" >&2
				fi
			else
				if [[ "$geniplistopt" == true ]]; then
					invalid_msgs+=("[X] Error: $fileSource contains an improperly formatted range -- $line")
				else
					echo -e "\e[31m [X] Error: $fileSource contains an improperly formatted range -- $line \e[0m" >&2
					echo -e "\e[31m            IP address ranges must be in the format x.x.x.x-y.y.y.y \e[0m" >&2
				fi
			fi
            anyinvalid=1
		else
			# Not a recognized IP/range/CIDR
			if [[ "$enteredips" = true ]]; then
				if [[ "$geniplistopt" == true ]]; then
					invalid_msgs+=("[X] Error: $line is an invalid entry")
				else
					# Defer printing until we know if file is fully invalid; store small preview
					if ((${#preview_invalid_lines[@]} < preview_limit)); then preview_invalid_lines+=("$line"); fi
				fi
				anyinvalid=1
			else
				# If the checkfile is a temp hostname file created by the prompt, hide the temp filename
				if [[ "$checkfile" == /tmp/z0e_single_host.* ]]; then
					if [[ "$geniplistopt" == true ]]; then
						invalid_msgs+=("[X] Error: The specified targets contain an invalid entry -- $line")
					else
						echo -e "\e[31m [X] Error: The specified targets contain an invalid entry -- $line \e[0m" >&2
					fi
					else
						if [[ "$geniplistopt" == true ]]; then
							invalid_msgs+=("[X] Error: $fileSource contains an invalid entry -- $line")
						else
							if ((${#preview_invalid_lines[@]} < preview_limit)); then preview_invalid_lines+=("$line"); fi
						fi
				fi
				anyinvalid=1
			fi
		fi
    done < "$checkfile"

	if [ "$anyinvalid" -ne 0 ]; then
		allvalid=0
		enteredips=false
		# In interactive targets prompt, do not exit; let caller re-prompt
		if [[ "$interactive_targets" = true ]]; then
			return 1
		fi
		if [[ "$geniplistopt" == true ]]; then
			if [[ "$saw_valid_line" = false ]]; then
				# Only summary error when there are zero valid entries
				echo -e "\e[31m [X] Error: $checkfile contains no valid IP addresses, ranges, or CIDRs \e[0m" >&2
			else
				# Mixed case: print each buffered invalid message
				for msg in "${invalid_msgs[@]}"; do
					echo -e "\e[31m $msg \e[0m" >&2
				done
			fi
			exit 1
		else
			# Non-geniplist mode: if zero valid lines and many invalid, emit concise summary + preview
			if [[ "$saw_valid_line" = false ]]; then
				echo -e "\e[31m [X] Error: $checkfile contains only invalid entries \e[0m" >&2
			fi
			# Exit criteria: (defaults mode with no explicit -t) OR (user provided -t outside excludes prompt) OR (user provided -x)
			if [[ ( -z "$t_opt" && "$defaults" = true ) || ( -n "$t_opt" && "$excludesprompt" != true ) || -n "$x_opt" ]]; then
				exit 1
			fi
		fi
	else
	    allvalid=1
	    enteredips=false
	fi
}

function stageinit { # The checkpoint system
	mkdir -p /var/lib/zeroe

	function checkinvalidstage { # Defines the function to check for an invalid stage
		if [[ "$stage" = "script-start" || "$stage" = "discovery-ports" || "$stage" = "discovery-hosts" || "$stage" = "discovery-udp" || "$stage" = "discovery-lists" || "$stage" = "services-tcp" || "$stage" = "services-udp" ]]; then
			return 0
		else	
			echo -e "\e[31m [X] Error: Invalid stage '$stage' -- check help or README for valid stages \e[0m" >&2
			return 1
		fi
	}

	# Determine the appropriate stage file location
	if [[ "$session_flag" = true && -n "$session" ]]; then
		stage_file="/var/lib/zeroe/sessions/$session/stage.z0e"
		initdir_file="/var/lib/zeroe/sessions/$session/initdir.z0e"
	else
		stage_file="/var/lib/zeroe/stage.z0e"
		initdir_file="/var/lib/zeroe/initdir.z0e"
	fi

	if [[ "$s_opt" = false && "$S_opt" = "disabled" && "$defaults" = true ]]; then # If only using --defaults option
		stage="script-start"
		echo "$(pwd)" > "$initdir_file"
		stage_cont=true
		only_flag=false
	elif [[ "$s_opt" = true ]]; then # If stage disabled
		stage="script-start"
		echo "$(pwd)" > "$initdir_file"
		stage_cont=true
	elif [[ ! -f "$stage_file" && "$S_opt" = "disabled" ]] || [[ -f "$stage_file" && "$(cat "$stage_file")" = "script-start" ]]; then # If stage file does not exist and stage option is disabled OR saved stage is script-start
		echo "[?] Start a <n>ew scan, or enter a specific stage:"
		while true; do
			read -e -p " [>] " stage
			if [[ "$stage" = "n" || "$stage" = "new" ]]; then
				stage="script-start"
				echo "$(pwd)" > "$initdir_file"
				stage_cont=true
				break
			else
				echo "$(pwd)" > "$initdir_file"
				if checkinvalidstage; then
					if [[ "$only_flag" = false ]]; then
						stage_cont=true
					fi
					break
				fi
			fi
		done
	elif [[ -f "$stage_file" ]] && [[ -z "$S_opt" ]]; then # Load stage if it exists and resume stage option is enabled
	  	stage=$(cat "$stage_file")
		resume="y"
	elif [[ ! -f "$stage_file" ]] && [[ -z "$S_opt" ]]; then # If stage file does not exist and resume option is enabled
		echo -e "\e[31m [X] Error: No saved stage exists \e[0m" >&2
		echo "[?] Start a <n>ew scan, or enter a specific stage:"
		while true; do
			read -e -p " [>] " stage
				if [[ "$stage" = "n" || "$stage" = "new" ]]; then
					stage="script-start"
					echo "$(pwd)" > "$initdir_file"
					stage_cont=true
					break
				else
					echo "$(pwd)" > "$initdir_file"
					if checkinvalidstage; then
						if [[ "$only_flag" != true ]]; then
							stage_cont=true
						fi
						break
					fi
				fi
		done
	elif [[ -f "$stage_file" && "$S_opt" = "disabled" && "$(cat "$stage_file")" != "script-start" ]]; then # If stage file exists, stage option is disabled, and saved stage is not script-start
		echo "[?] <R>esume from '$(cat "$stage_file")', start a <n>ew scan, or specify stage:"
		while true; do
			read -e -p " [>] " stage
			if [[ "$stage" != "script-start" && "$stage" != "discovery-ports" && "$stage" != "discovery-hosts" && "$stage" != "discovery-udp" && "$stage" != "discovery-lists" && "$stage" != "services-tcp" && "$stage" != "services-udp" && "$stage" != "R" && "$stage" != "r"  && "$stage" != "Resume" && "$stage" != "resume"  && "$stage" != "n" && "$stage" != "new" ]]; then
				echo -e "\e[31m [X] Error: Invalid stage '$stage' -- check help or README for valid stages \e[0m" >&2
			elif [[ "$stage" = "n" || "$stage" = "new" ]]; then
				stage="script-start"
				echo "$(pwd)" > "$initdir_file"
				stage_cont=true
				break
			elif [[ "$stage" = "R" || "$stage" = "r" || "$stage" = "Resume" || "$stage" = "resume" ]]; then
				resume="y"
				stage=$(cat "$stage_file")
				break
			else # Specifying a stage
				if checkinvalidstage; then
					echo "$(pwd)" > "$initdir_file"
					if [[ "$only_flag" == true && "$stage" == "discovery-udp" ]]; then
						stage_cont=false
					elif [[ "$only_flag" != true ]]; then
						stage_cont=true
					fi
					break
				fi
			fi
		done
	elif [[ -n "$S_opt" ]]; then # Start at the specified stage
		if [[ "$S_opt" = "script-start" || "$S_opt" = "discovery-ports" || "$S_opt" = "discovery-hosts" || "$S_opt" = "discovery-udp" || "$S_opt" = "discovery-lists" || "$S_opt" = "services-tcp" || "$S_opt" = "services-udp" ]]; then
			stage="$S_opt"
			echo "$(pwd)" > "$initdir_file"
			if [[ "$only_flag" == true && "$S_opt" == "discovery-udp" ]]; then
				stage_cont=false
			elif [[ "$only_flag" != true ]]; then
				stage_cont=true
			fi
		else
			echo -e "\e[31m [X] Error: Invalid stage '$S_opt' -- check help or README for valid stages \e[0m" >&2
			exit 1
		fi
	fi
}

function stagefilescheck { #Checks if required files are present for the specified stage
    local missing_files=()

    function checkstagefiles {
        for file in "$@"; do
            if [ ! -f "$file" ]; then
                missing_files+=("$file")
            fi
        done
    }
	#Defines required files for each stage
	if [[ "$e_opt" = true || "$type" = "E" || "$type" = "e" || "$type" = "external" || "$type" = "External" || "$type" = "Ext" || "$type" = "ext" ]]; then
    	case "$stage" in
    		"discovery-hosts")
    			checkstagefiles "$nostrikes" "$ips"
    			;;
    		"discovery-ports")
	    		# Require at least one of aliveHosts or original targets
	    		if [ ! -f "$filepath/$typevar-aliveHosts.txt" ] && [ ! -f "$ips" ]; then
	    			# Either aliveHosts or targets file must exist; record both as missing for robustness
	    			missing_files+=("$filepath/$typevar-aliveHosts.txt" "$ips")
	    		fi
    			;;
    		"discovery-udp")
	    		# Prefer discoresults if it exists; otherwise, fallback to original targets
	    		if [ -f "$filepath/logs/processed/$typevar-discoresults.txt" ]; then
	    			checkstagefiles "$filepath/logs/processed/$typevar-discoresults.txt"
	    		else
	    			checkstagefiles "$ips"
	    		fi
    			;;
    		"discovery-lists")
    			# Check for $filepath/$typevar-aliveHosts.txt
    			checkstagefiles "$filepath/logs/processed/$typevar-discoresults.txt"
    			if ! { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]]; }; then
    			    # Check for $filepath/$typevar-openPorts.txt and $filepath/logs/processed/$typevar-portsfornmap-tcp.txt
    			    checkstagefiles  "$filepath/logs/processed/$typevar-discoscan-masscan-tcp-nosusips.txt"
    			fi
    			if [[ "$udp" = "y" || "$udp" = "yes" || "$U_opt" = true ]]; then
    			    if [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ]; then
						# Check for $filepath/logs/processed/$typevar-discoscan-masscan-udp-nosusips.txt and $filepath/logs/processed/$typevar-portsfornmap-udp.txt
						checkstagefiles "$filepath/logs/processed/$typevar-discoscan-masscan-udp-nosusips.txt"
    			    else
						# Check for $filepath/logs/processed/$typevar-discoscan-masscan-udp.txt and $filepath/logs/processed/$typevar-portsfornmap-udp.txt
						checkstagefiles "$filepath/logs/processed/$typevar-discoscan-masscan-udp.txt"
    			    fi
    			fi
    			;;
    		"services-tcp")
    			checkstagefiles "$nostrikes" "$filepath/$typevar-aliveHosts.txt" "$filepath/logs/processed/$typevar-portsfornmap-tcp.txt"
    			;;
    		"services-udp")
    			checkstagefiles "$nostrikes" "$filepath/$typevar-aliveHosts.txt" "$filepath/logs/processed/$typevar-portsfornmap-udp.txt"
    			;;
    	esac
  	elif [[ "$i_opt" = true || "$type" = "I" || "$type" = "i" || "$type" = "internal" || "$type" = "Internal" || "$type" = "Int" || "$type" = "int" ]]; then
    	case "$stage" in
    		"discovery-hosts")
    			checkstagefiles "$nostrikes" "$ips"
    			;;
    		"discovery-ports")
	    		# Require at least one of aliveHosts or original targets
	    		if [ ! -f "$filepath/$typevar-aliveHosts.txt" ] && [ ! -f "$ips" ]; then
	    			# Either aliveHosts or targets file must exist; record both as missing for robustness
	    			missing_files+=("$filepath/$typevar-aliveHosts.txt" "$ips")
	    		fi
    			;;
    		"discovery-udp")
    			if [ -f "$filepath/logs/processed/$typevar-discoresults.txt" ]; then
    				checkstagefiles "$nostrikes" "$filepath/logs/processed/$typevar-discoresults.txt"
    			else
    				checkstagefiles "$nostrikes" "$ips"
    			fi
    			;;
    		"discovery-lists")
    			# Check for $filepath/$typevar-aliveHosts.txt
    			checkstagefiles "$filepath/logs/processed/$typevar-discoresults.txt"
    			if ! { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]]; }; then
    			    # Check for $filepath/$typevar-openPorts.txt and $filepath/logs/processed/$typevar-portsfornmap-tcp.txt
    			    checkstagefiles  "$filepath/logs/processed/$typevar-discoscan-masscan-tcp-nosusips.txt"
    			fi
    			if [[ "$udp" = "y" || "$udp" = "yes" || "$U_opt" = true ]]; then
    			    if [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ]; then
						# Check for $filepath/logs/processed/$typevar-discoscan-masscan-udp-nosusips.txt and $filepath/logs/processed/$typevar-portsfornmap-udp.txt
						checkstagefiles "$filepath/logs/processed/$typevar-discoscan-masscan-udp-nosusips.txt"
    			    else
						# Check for $filepath/logs/processed/$typevar-discoscan-masscan-udp.txt and $filepath/logs/processed/$typevar-portsfornmap-udp.txt
						checkstagefiles "$filepath/logs/processed/$typevar-discoscan-masscan-udp.txt"
    			    fi
    			fi
    			;;
    		"services-tcp")
    			checkstagefiles "$nostrikes" "$filepath/$typevar-aliveHosts.txt" "$filepath/logs/processed/$typevar-portsfornmap-tcp.txt"
    			;;
    		"services-udp")
    			checkstagefiles "$nostrikes" "$filepath/$typevar-aliveHosts.txt" "$filepath/logs/processed/$typevar-portsfornmap-udp.txt"
    			;;
    	esac
  	fi
	if [ ${#missing_files[@]} -ne 0 ]; then
        #echo -e "\e[31m [X] Error: The following required files are missing for the '$stage' stage:"
		#for file in "${missing_files[@]}"; do
        #    echo -e "  - $file"
        #done
		if [[ -f /var/lib/zeroe/stage.z0e ]]; then
        	echo -e "\e[31m [X] Error: Required z0e files for $stage stage do not exist" >&2
			#echo -e " 		     Required files: ${missing_files[@]}" >&2
			echo -e "            Resume z0e from the saved $(cat /var/lib/zeroe/stage.z0e) stage, run preceding stage, or restart z0e \e[0m" >&2
        	exit 1
		else
			echo -e "\e[31m [X] Error: Required z0e files for $stage stage do not exist" >&2
			#echo -e " 		     Required files: ${missing_files[@]}" >&2
			echo -e "            Correct output directory if repeating stage, run preceding stage, or restart z0e \e[0m" >&2
        	exit 1
		fi
    fi
}

function nessusports { #Formats open ports as Nessus-compatible for easy copy/pasting
	rm $filepath/$typevar-portsForNessus.txt #Prevents duplicate entries
	#Outputs TCP ports in Nessus-compatible format (T:#,)
	awk '{printf "T:%s,", $0}' $filepath/logs/processed/$typevar-portsfornmap-tcp.txt | sed 's/,$/\n/' >> $filepath/$typevar-portsForNessus.txt
	if grep -q "\S" "$filepath/logs/processed/$typevar-portsfornmap-udp.txt"; then
		#Outputs UDP ports in Nessus-compatible format (U:#,)
		awk '{printf "U:%s,", $0}' $filepath/logs/processed/$typevar-portsfornmap-udp.txt | sed 's/,$/\n/' >> $filepath/$typevar-portsForNessus.txt
		#Joins TCP and UDP ports into single line
		sed -i -z 's/\n/,/' $filepath/$typevar-portsForNessus.txt
	fi
}

function genwindowshostlist {
    local inputfile="$1"
    local outputfile="$2"

    # Check if inputfile is provided and exists
    if [[ -z "$inputfile" ]]; then
        echo -e "\e[31m [X] Error: Correct syntax: --listwinhosts <StandardNmapFile> [OutputFile]" >&2
        return 1
	elif [[ ! -f "$inputfile" ]]; then
		echo -e "\e[31m [X] Error: File '$inputfile' does not exist \e[0m" >&2
		return 1
	fi

    # awk command to parse Windows hosts
    if [[ -n "$outputfile" ]]; then
        awk '
        /Nmap scan report for/ {
            line = $0
            ip = "Unknown IP"

            # Check if line contains "("
            if (index(line, "(") > 0) {
                # IP is between "(" and ")"
                start = index(line, "(") + 1
                end = index(line, ")") - 1
                ip = substr(line, start, end - start + 1)
            } else {
                # IP is after "Nmap scan report for "
                prefix = "Nmap scan report for "
                start = index(line, prefix)
                if (start > 0) {
                    ip = substr(line, start + length(prefix))
                }
            }
        }
        /OS:.*[Ww]indows/ {
            print ip
        }
        ' "$inputfile" | sort -u > "$outputfile"
    else
        awk '
        /Nmap scan report for/ {
            line = $0
            ip = "Unknown IP"

            # Check if line contains "("
            if (index(line, "(") > 0) {
                # IP is between "(" and ")"
                start = index(line, "(") + 1
                end = index(line, ")") - 1
                ip = substr(line, start, end - start + 1)
            } else {
                # IP is after "Nmap scan report for "
                prefix = "Nmap scan report for "
                start = index(line, prefix)
                if (start > 0) {
                    ip = substr(line, start + length(prefix))
                }
            }
        }
        /OS:.*[Ww]indows/ {
            print ip
        }
        ' "$inputfile" | sort -u
    fi
}

function genwindowshostlist_inscript { #For genwinhostlist when ran inside the script
    if [[ "$stage" == "services-tcp" ]]; then
        resultsfile="$filepath/$typevar-tcp-servicescan-results.nmap"
        outputfile="$filepath/logs/processed/$typevar-windowshoststcp.txt"
        genwindowshostlist "$resultsfile" >> "$outputfile"
    elif [[ "$stage" == "services-udp" ]] && [[ "$udp" == "y" || "$udp" == "yes" || "$U_opt" == true ]]; then
        resultsfile="$filepath/$typevar-udp-servicescan-results.nmap"
        outputfile="$filepath/logs/processed/$typevar-windowshostsudp.txt"
        genwindowshostlist "$resultsfile" >> "$outputfile"
    fi

    # Combine and sort the outputs
    cat "$filepath/logs/processed/$typevar-windowshoststcp.txt" "$filepath/logs/processed/$typevar-windowshostsudp.txt" 2>/dev/null | sort -u > "$filepath/analysis/$typevar-windowsHosts.txt"

	# Remove the output file if it's empty
    if [[ ! -s "$filepath/analysis/$typevar-windowsHosts.txt" ]]; then
        rm "$filepath/analysis/$typevar-windowsHosts.txt"
    fi
}

function parsegnmap {
    local gnmapfile="$1"
    local portsofinterest="$2"
    local outputfilename="$3"

    # Error handling
    if [[ -z "$gnmapfile" || -z "$portsofinterest" ]]; then
        echo -e "\e[31m [X] Error: Correct syntax: --parseports <GrepableNmapFile> <Comma,Separated,Ports> [OutputFileName] \e[0m" >&2
        return 1
    elif [[ ! -f "$gnmapfile" ]]; then
        echo -e "\e[31m [X] Error: File '$gnmapfile' does not exist \e[0m" >&2
        return 1
    fi

    # Parsing function for AWK
    parse_with_awk() {
    	grep '^Host:' "$gnmapfile" | \
    	sed -n 's/^Host: \([^ ]*\).*Ports: \(.*\)/\1\t\2/p' | \
    	awk -F'\t' -v ports="$portsofinterest" '
    	BEGIN {
    	    IGNORECASE = 1
    	    split(ports, portlist, ",")
    	    for (i in portlist) portmap[portlist[i]] = 1
    	}
    	{
    	    ip = $1
    	    ports_field = $2

    	    ports_list = ""
    	    services_list = ""

    	    n = split(ports_field, port_entries, ", ")
    	    for (j = 1; j <= n; j++) {
    	        port_entry = port_entries[j]
    	        split(port_entry, port_parts, "/")
    	        portnum = port_parts[1]
    	        state = port_parts[2]
    	        service = port_parts[5]
    	        if (state == "open" && portmap[portnum]) {
    	            if (ports_list == "") {
    	                ports_list = portnum
    	                services_list = service
    	            } else {
    	                ports_list = ports_list "," portnum
    	                services_list = services_list "," service
    	            }
    	        }
    	    }
    	    if (ports_list != "") {
    	        # Print data with fixed-width columns for alignment
    	        printf "%-15s %-25s %-30s\n", ip, ports_list, services_list
    	    }
    	}'
	}

	if [[ "$parsegnmap_inscript" == true ]]; then
	    # Automated process: Output only to file, no terminal output
	    temp_data_output=$(mktemp)

	    # Parse the gnmap file and store data in temporary file
	    parse_with_awk > "$temp_data_output"

	    # Check if the temporary data output file is empty
	    if [[ -s "$temp_data_output" ]]; then
	        # There is data, write instructions, header, and data to the output file
	        {
	            # Print the header first
	            echo 'To parse the contents for a specific port or service and output the results in IP Address:Port/Service format, use the following command (replace <PORT/SERVICE> with your value):'
	            echo ''
	            echo "awk -F' ' -v t=\"PORT/SERVICE\" 'BEGIN{IGNORECASE=1} \$2\",\"\$3 ~ \"(^|,)\" t \"(,|$)\" {print \$1\":\"t}'" "$outputfilename"
	            echo ''
	            # Append the parsed data
	            cat "$temp_data_output"
	        } > "$outputfilename"
	    else
	        # No data, remove the output file if it exists
	        rm -f "$outputfilename"
	    fi

	    # Clean up the temporary file
	    rm -f "$temp_data_output"
    elif [[ -z "$outputfilename" ]]; then
        # If no output filename is given, output to the terminal with instructions
        echo 'To parse the output for a specific port or service and output the results in IP Address:Port/Service format, use the following command (replace <PORT/SERVICE> with your value):'
        echo ''
        echo 'awk -F'\'' '\'' -v t="PORT/SERVICE" '\''BEGIN{IGNORECASE=1} $2","$3 ~ "(^|,)" t "(,|$)" {print $1":"t}'\'' resultsFilename'
        echo ''
        parse_with_awk
    elif [[ -n "$outputfilename" ]]; then
        # Output instructions to the terminal and data to the file
        {
            echo 'To parse the output file for a specific port or service and output the results in IP Address:Port/Service format, use the following command (replace <PORT/SERVICE> with your value):'
            echo ''
            echo 'awk -F'\'' '\'' -v t="PORT/SERVICE" '\''BEGIN{IGNORECASE=1} $2","$3 ~ "(^|,)" t "(,|$)" {print $1":"t}'\'' '"$outputfilename"
            echo ''
        } 

        # Append the parsed data to the output file
        parse_with_awk > "$outputfilename"
    fi
}

function listiptohostname { #Lists IP addresses and their corresponding hostnames
    local inputfile="$1"
    local outputfile="$2"

    # Check if inputfile is provided and exists
    if [[ -z "$inputfile" ]]; then
        echo -e "\e[31m [X] Error: Correct syntax: --listiphostname <StandardNmapFile> [OutputFile]" >&2
        return 1
	elif [[ ! -f "$inputfile" ]]; then
		echo -e "\e[31m [X] Error: File '$inputfile' does not exist \e[0m" >&2
		return 1
	fi

    if [[ -n "$outputfile" ]]; then
        awk '
        /^Nmap scan report for/ {
            line = $0
            hostname = "Unknown"
            ip = ""

            prefix = "Nmap scan report for "
            prefix_length = length(prefix)
            # Extract the rest of the line after the prefix
            rest = substr(line, prefix_length + 1)

            # Check if rest contains "(" indicating a hostname and IP
            paren_pos = index(rest, "(")
            if (paren_pos > 0) {
                hostname = substr(rest, 1, paren_pos - 1)
                # Remove any trailing spaces from hostname
                sub(/[[:space:]]+$/, "", hostname)
                ip_start = paren_pos + 1
                ip_end = index(rest, ")") - 1
                ip = substr(rest, ip_start, ip_end - paren_pos)
            } else {
                # No hostname, only IP is present
                ip = rest
                # Remove any leading/trailing spaces from IP
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", ip)
            }

            if (ip != "") {
                print ip, hostname
            }
        }
        ' "$inputfile" > "$outputfile"
    else
        awk '
        /^Nmap scan report for/ {
            line = $0
            hostname = "Unknown"
            ip = ""

            prefix = "Nmap scan report for "
            prefix_length = length(prefix)
            # Extract the rest of the line after the prefix
            rest = substr(line, prefix_length + 1)

            # Check if rest contains "(" indicating a hostname and IP
            paren_pos = index(rest, "(")
            if (paren_pos > 0) {
                hostname = substr(rest, 1, paren_pos - 1)
                # Remove any trailing spaces from hostname
                sub(/[[:space:]]+$/, "", hostname)
                ip_start = paren_pos + 1
                ip_end = index(rest, ")") - 1
                ip = substr(rest, ip_start, ip_end - paren_pos)
            } else {
                # No hostname, only IP is present
                ip = rest
                # Remove any leading/trailing spaces from IP
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", ip)
            }

            if (ip != "") {
                print ip, hostname
            }
        }
        ' "$inputfile"
    fi
}

function listiptohostname_inscript { #For genwinhostlist when ran inside the script
    if [[ "$stage" == "services-tcp" ]]; then
        resultsfile="$filepath/$typevar-tcp-servicescan-results.nmap"
        outputfile="$filepath/logs/processed/$typevar-iphostnamestcp.txt"
        listiptohostname "$resultsfile" >> "$outputfile"
    elif [[ "$stage" == "services-udp" ]] && [[ "$udp" == "y" || "$udp" == "yes" || "$U_opt" == true ]]; then
        resultsfile="$filepath/$typevar-udp-servicescan-results.nmap"
        outputfile="$filepath/logs/processed/$typevar-iphostnamesudp.txt"
        listiptohostname "$resultsfile" >> "$outputfile"
    fi

    # Combine and sort the outputs
    cat "$filepath/logs/processed/$typevar-iphostnamestcp.txt" "$filepath/logs/processed/$typevar-iphostnamesudp.txt" 2>/dev/null | sort -u > "$filepath/analysis/$typevar-ipHostnames.txt"

	# Remove the output file if it's empty
    if [[ ! -s "$filepath/analysis/$typevar-ipHostnames.txt" ]]; then
        rm "$filepath/analysis/$typevar-ipHostnames.txt"
    fi
}

function execute_nmap_with_realtime_stats {
    local nmap_cmd="$1"
    local output_redirect="$2"
	local NMAP_STATS_EVERY="10m"
    
	# Inject a global --stats-every if not already present and not resuming
	if [ -n "$NMAP_STATS_EVERY" ]; then
		case "$nmap_cmd" in
			*"--resume"* ) : ;; # don't inject for resume
			*"--stats-every"* ) : ;; # already present
			* ) nmap_cmd="$nmap_cmd --stats-every $NMAP_STATS_EVERY" ;;
		esac
	fi
    
	# Decide stdout and stderr targets
	# - stdout to per-scan logs (or /dev/null)
	# - stderr to errors.log
	# - BOTH also tee into a unified status log for live updates without polluting errors.log
	local stderr_target="$filepath/logs/$typevar-errors.log"
	local status_log="${STATUS_LOG:-$filepath/logs/$typevar-status.log}"
	local stdout_target=""

	# If caller explicitly sent stdout to /dev/null in their redirect, honor it
	if echo "$output_redirect" | grep -q "1>/dev/null"; then
		stdout_target="/dev/null"
	fi

	# If stdout not specified, try to infer from command
	if [ -z "$stdout_target" ]; then
		# Prefer a log next to any -oG path, replacing .gnmap with .log
		if echo "$nmap_cmd" | grep -q -- "-oG "; then
			# Extract the -oG argument path (supports both quoted and unquoted)
			local og_path
			og_path=$(echo "$nmap_cmd" | sed -E -n 's/.*-oG[[:space:]]+([^[:space:]]+).*/\1/p')
			# If quoted, strip quotes safely
			og_path=${og_path%\"}
			og_path=${og_path#\"}
			if [ -n "$og_path" ]; then
				stdout_target="${og_path%.gnmap}.log"
			fi
		fi
	fi

	# For resume, infer from the resume file path
	if [ -z "$stdout_target" ] && echo "$nmap_cmd" | grep -q -- "--resume"; then
		local resume_path
		resume_path=$(echo "$nmap_cmd" | sed -E -n 's/.*--resume[[:space:]]+([^[:space:]]+).*/\1/p')
		resume_path=${resume_path%\"}
		resume_path=${resume_path#\"}
		if [ -n "$resume_path" ]; then
			case "$resume_path" in
				*"-servicescan-results.gnmap" )
					stdout_target="/dev/null"
					;;
				*.gnmap )
					stdout_target="${resume_path%.gnmap}.log"
					;;
				*.nmap )
					stdout_target="${resume_path%.nmap}.log"
					;;
			esac
		fi
	fi

	if [ -z "$stdout_target" ]; then
		stdout_target="/dev/null"
	fi

	if [ "$stdout_target" != "/dev/null" ]; then
		mkdir -p "$(dirname "$stdout_target")" 2>/dev/null || true
	fi

	# Ensure status log directory exists
	mkdir -p "$(dirname "$status_log")" 2>/dev/null || true

	# Use stdbuf if available for real-time stats, otherwise fall back to regular execution
	if command -v stdbuf >/dev/null 2>&1; then
		eval "stdbuf -o0 -e0 $nmap_cmd \
			1> >(tee -a \"$stdout_target\" \"$status_log\" >/dev/null) \
			2> >(tee -a \"$stderr_target\" \"$status_log\" >/dev/null)" &
	elif command -v script >/dev/null 2>&1; then
		eval "script -q -e -f -c \"$nmap_cmd\" /dev/null \
			1> >(tee -a \"$stdout_target\" \"$status_log\" >/dev/null) \
			2> >(tee -a \"$stderr_target\" \"$status_log\" >/dev/null)" &
	else
		eval "$nmap_cmd \
			1> >(tee -a \"$stdout_target\" \"$status_log\" >/dev/null) \
			2> >(tee -a \"$stderr_target\" \"$status_log\" >/dev/null)" &
	fi
}

function statusnmap {
    indicator="^-_-^"
	local last_stats_line=""
	local last_timing_line=""
    local stats_counter=0
	local timing_seen=false
	# Periodic Nmap -sn aggregation in-process
	local now next
	local sn_interval="${z0e_sn_progress_interval:-300}" # default ~5m
	# Initialize next print timestamp if not set
	if [[ "${z0e_sn_aggregate_enabled:-false}" = true && -z "${z0e_sn_next_print_ts:-}" ]]; then
		z0e_sn_next_print_ts=$(( $(date +%s) + sn_interval ))
	fi
    
    # Monitor if stdbuf or script is available for real-time stats
    local enable_realtime_stats=false
    if command -v stdbuf >/dev/null 2>&1; then
        enable_realtime_stats=true
    elif command -v script >/dev/null 2>&1; then
        enable_realtime_stats=true
    fi
    
	# Only consider new lines appended after this function starts (read from per-stage status log if set)
	local errors_log="${STATUS_LOG:-$filepath/logs/$typevar-status.log}"
	local start_lines=0
	if [ -f "$errors_log" ]; then
		start_lines=$(wc -l < "$errors_log" 2>/dev/null || echo 0)
	fi

	while kill -0 $pid >/dev/null 2>&1; do
		# Periodic consolidated progress for Nmap -sn (no background process)
		if [[ "${z0e_sn_aggregate_enabled:-false}" = true && -n "${z0e_sn_base_prefix:-}" && -n "${z0e_sn_total_hosts:-}" ]]; then
			now=$(date +%s)
			if [[ -z "${z0e_sn_next_print_ts:-}" ]]; then z0e_sn_next_print_ts=$(( now + sn_interval )); fi
			if (( now >= z0e_sn_next_print_ts )); then
				local nmap_file="${z0e_sn_base_prefix}.nmap"
				local scanned_ips=0 total_time=0
				if [[ -f "$nmap_file" ]]; then
					scanned_ips=$(grep -E "^# Nmap done .* -- [0-9]+ IP addresses" "$nmap_file" 2>/dev/null | sed -E 's/^# Nmap done .* -- ([0-9]+) IP addresses.*/\1/' | awk '{s+=$1} END{printf "%d", s+0}')
					total_time=$(grep -E "^# Nmap done .* scanned in [0-9.]+ seconds" "$nmap_file" 2>/dev/null | sed -E 's/^# Nmap done .* scanned in ([0-9.]+) seconds.*/\1/' | awk '{s+=$1} END{printf "%f", s+0}')
				fi
				local percent=0
				if [[ ${z0e_sn_total_hosts:-0} -gt 0 && ${scanned_ips:-0} -gt 0 ]]; then
					percent=$(awk -v a="$scanned_ips" -v b="$z0e_sn_total_hosts" 'BEGIN{if (b==0) print 0; else printf("%d", (a*100.0)/b)}')
				fi
				local eta_str="estimating..."
				if [[ ${scanned_ips:-0} -gt 0 && "$total_time" != "0" && "$total_time" != "0.000000" ]]; then
					local remain=$(( (${z0e_sn_total_hosts:-0} - scanned_ips) ))
					if (( remain < 0 )); then remain=0; fi
					local eta_seconds=$(awk -v r="$remain" -v tt="$total_time" -v si="$scanned_ips" 'BEGIN{ if (si==0) print 0; else printf("%d", r*(tt/si)) }')
					local h=$(( eta_seconds/3600 ))
					local m=$(( (eta_seconds%3600)/60 ))
					local s=$(( eta_seconds%60 ))
					printf -v eta_str "%02d:%02d:%02d" "$h" "$m" "$s"
				fi
				printf "\r\e[K\e[36m [i] Alive host progress -- %s%% (%s/%s IPs),   ETA ~%s \e[0m\n" "${percent}" "${scanned_ips}" "${z0e_sn_total_hosts:-0}" "$eta_str"
				z0e_nmap_sn_periodic_printed=true
				z0e_sn_next_print_ts=$(( now + sn_interval ))
			fi
		fi
		# Check for timing/stats every ~1s (5 * 0.2s)
		if [ "$enable_realtime_stats" = true ] && [ $((stats_counter % 5)) -eq 0 ] && [ -f "$errors_log" ]; then
			# Prefer the detailed Timing line (e.g., "SYN Stealth Scan Timing: About X% done; ETC: ...")
			recent_timing=$(tail -n +$((start_lines+1)) "$errors_log" 2>/dev/null | tail -n 400 | grep -E "Timing: About [0-9.]+% done; ETC:" | tail -1)
			if [ -n "$recent_timing" ] && [ "$recent_timing" != "$last_timing_line" ]; then
				# Extract group percent and ETC from the timing line
				# Example: "Service scan Timing: About 50.00% done; ETC: 23:53 (0:00:38 remaining)"
				local __grp_pct="" __etc_full=""
				__grp_pct=$(echo "$recent_timing" | sed -nE 's/.*Timing: About ([0-9.]+)% done; ETC: .*/\1/p')
				__etc_full=$(echo "$recent_timing" | sed -nE 's/.*ETC: (.*)/\1/p')

				# Compute overall progress/ETA if grouped context is available
				local __overall_str="" __eta_overall=""
				if [[ "${Z0E_GROUPED_ENABLED:-false}" = true ]]; then
					local __tw=${Z0E_GROUPED_TOTAL_WEIGHT:-0}
					local __cw=${Z0E_GROUPED_COMPLETED_WEIGHT:-0}
					local __cur=${Z0E_GROUPED_CURRENT_WEIGHT:-0}
					local __start=${Z0E_GROUPED_START_EPOCH:-0}
					local __now=$(date +%s)
					local __g=${__grp_pct:-0}
					# fraction
					local __num=$(( __cw*10000 ))
					local __cur_part=$(( __cur*${__g%.*} ))
					# Use awk for precision
					local __frac
					__frac=$(awk -v tw="$__tw" -v cw="$__cw" -v cur="$__cur" -v gpct="$__g" 'BEGIN{ if (tw==0){print 0.0} else { printf("%0.4f", (cw + cur*(gpct/100.0))/tw ) } }')
					# ETA
					local __elapsed=$(( __now - __start ))
					if (( __elapsed < 0 )); then __elapsed=0; fi
					local __frac_guard
					__frac_guard=$(awk -v f="$__frac" 'BEGIN{ if (f<0.01) print 0.01; else print f }')
					local __total
					__total=$(awk -v e="$__elapsed" -v f="$__frac_guard" 'BEGIN{ printf("%d", (e/f)) }')
					local __remain=$(( __total - __elapsed ))
					if (( __remain < 0 )); then __remain=0; fi
					# format overall percent and ETA
					local __pct_overall
					__pct_overall=$(awk -v f="$__frac" 'BEGIN{ printf("%0.1f", f*100.0) }')
					local oh=$(( __remain/3600 ))
					local om=$(( (__remain%3600)/60 ))
					local os=$(( __remain%60 ))
					printf -v __eta_overall "%02d:%02d:%02d" "$oh" "$om" "$os"
					__overall_str="; Overall: ~${__pct_overall}% ETA ~${__eta_overall}"
				fi

				# Print unified cyan info line; for UDP service scans, suppress overall overlay and adjust prefix
				local __is_udp=false
				if [[ "$contstatus" == *"UDP"* ]]; then __is_udp=true; fi
				if [ -n "$__grp_pct" ] && [ -n "$__etc_full" ]; then
					if [ "$__is_udp" = true ]; then
						printf "\r\e[K\e[36m [i] UDP service scan progress -- about %s%% done; ETC %s \e[0m\n" "$__grp_pct" "$__etc_full"
					else
						printf "\r\e[K\e[36m [i] Service scan progress -- Group: about %s%% done; ETC %s%s \e[0m\n" "$__grp_pct" "$__etc_full" "$__overall_str"
					fi
				else
					# Fallback: print raw timing line if parsing failed
					printf "\r\e[K\e[36m [i] %s \e[0m\n" "$recent_timing"
				fi
				last_timing_line="$recent_timing"
				timing_seen=true
				# Reprint spinner on next line
				printf "%s %s" "${indicator:$((stats_counter % ${#indicator})):1}" "$contstatus"
				stats_counter=$((stats_counter + 1))
				sleep 0.2
				continue
			fi
			# Fallback to generic Stats: line if no Timing line found
			if [ "$timing_seen" != true ]; then
				recent_stats=$(tail -n +$((start_lines+1)) "$errors_log" 2>/dev/null | tail -n 400 | grep "^Stats:" | tail -1)
			else
				recent_stats=""
			fi
			if [ -n "$recent_stats" ] && [ "$recent_stats" != "$last_stats_line" ] && [ "$timing_seen" != true ]; then
				printf "\r\e[K     %s\n" "$recent_stats"
				last_stats_line="$recent_stats"
				printf "%s %s" "${indicator:$((stats_counter % ${#indicator})):1}" "$contstatus"
				stats_counter=$((stats_counter + 1))
				sleep 0.2
				continue
			fi
		fi
        
        # Show spinner
        i=$(( (stats_counter+1) % ${#indicator} ))
        printf "\r\e[K%s %s" "${indicator:$i:1}" "$contstatus"
        sleep 0.2
        stats_counter=$((stats_counter + 1))
    done
	printf "\r\e[K"
}

########## Nmap -sn batching config and helper ##########
# Configuration: default chunk size for nmap -sn batching (can be overridden before scans begin)
# Use 'auto' to compute via tiered table based on total_hosts; or set to a number to force.
: "${z0e_nmap_sn_chunk_size:=auto}"
# Tiered chunk size selection for Nmap -sn batching
z0e_compute_sn_chunk_size() {
	local th="$1"
	if ! [[ "$th" =~ ^[0-9]+$ ]]; then
		echo 50
		return
	fi
	if (( th >= 1 && th <= 150 )); then echo 10; return; fi
	if (( th >= 151 && th <= 500 )); then echo 20; return; fi
	if (( th >= 501 && th <= 1000 )); then echo 30; return; fi
	if (( th >= 1001 && th <= 2500 )); then echo 50; return; fi
	if (( th >= 2501 && th <= 5000 )); then echo 80; return; fi
	if (( th >= 5001 && th <= 10000 )); then echo 100; return; fi
	if (( th >= 10001 && th <= 15000 )); then echo 150; return; fi
	if (( th >= 15001 && th <= 20000 )); then echo 200; return; fi
	if (( th >= 20001 && th <= 25000 )); then echo 250; return; fi
	echo 250
}
# Run Nmap -sn in chunks with resume support via a .progress ledger.
# - Preserves realtime stats/spinner via execute_nmap_with_realtime_stats + statusnmap
# - Appends to the same -oA base using --append-output for a single unified result
# - Transparent to the user: call site prints the same start/done messages
run_batched_nmap_sn() {
	local full_cmd="$1"
	local output_redirect="$2"
	local chunk_size
	if [[ -n "$3" ]]; then
		chunk_size="$3"
	elif [[ "$z0e_nmap_sn_chunk_size" =~ ^[0-9]+$ ]]; then
		chunk_size="$z0e_nmap_sn_chunk_size"
	else
		chunk_size="$(z0e_compute_sn_chunk_size "${total_hosts:-}")"
	fi

	# Extract -iL target file
	local input_file
	input_file=$(echo "$full_cmd" | sed -E -n 's/.*-iL[[:space:]]+"?([^"[:space:]]+)"?.*/\1/p')
	# Extract -oA base prefix
	local base_prefix
	base_prefix=$(echo "$full_cmd" | sed -E -n 's/.*-oA[[:space:]]+"?([^"[:space:]]+)"?.*/\1/p')

	# Fallback safety: if we failed to parse, just run once
	if [[ -z "$input_file" || -z "$base_prefix" || ! -f "$input_file" ]]; then
		execute_nmap_with_realtime_stats "$full_cmd" "$output_redirect"
		pid=$!
		# Ensure spinner status text
		if [[ -z "$contstatus" ]]; then contstatus="Pinging and scanning hosts"; fi
		statusnmap
		checked_cmd="$full_cmd"
		wait $pid
		exitstatus=$?
		errorcheck
		return $exitstatus
	fi

	# Prefer session-scoped progress when a session is active
	local progress_file
	if [[ "$session_flag" = true && -n "$session" ]]; then
		local session_progress_dir="/var/lib/zeroe/sessions/$session/progress"
		mkdir -p "$session_progress_dir" 2>/dev/null || true
		progress_file="$session_progress_dir/$(basename "$base_prefix").progress"
	else
		progress_file="${base_prefix}.progress"
	fi
	local chunks_dir="$filepath/logs/processed/${typevar}-nmap-sn-chunks"
	mkdir -p "$chunks_dir" 2>/dev/null || true

	# Create chunk files deterministically each run
	# Use a stable prefix tied to the input file name
	local chunk_prefix="$chunks_dir/$(basename "$input_file").chunk_"
	# Clean prior chunks for this input to avoid stale resumes across different target sets
	rm -f "${chunk_prefix}"* 2>/dev/null || true
	split -l "$chunk_size" -d -a 5 "$input_file" "$chunk_prefix" 2>/dev/null

	# Collect chunks
	local chunks=( $(ls -1 "${chunk_prefix}"* 2>/dev/null | sort) )
	if [[ ${#chunks[@]} -eq 0 ]]; then
		# No splitting occurred (very small input); run once but still honor append-output
		local one_cmd
		one_cmd=$(echo "$full_cmd" | sed -E "s|(-iL)[[:space:]]+\"?[^\"[:space:]]+\"?|\\1 \"$input_file\"|" )
		[[ "$one_cmd" != *"--append-output"* ]] && one_cmd+=" --append-output"
		execute_nmap_with_realtime_stats "$one_cmd" "$output_redirect"
		pid=$!
		statusnmap
		checked_cmd="$one_cmd"
		wait $pid
		exitstatus=$?
		errorcheck
		return $exitstatus
	fi

	# If a previous progress file exists but its chunk size header doesn't match current chunk_size,
	# reset outputs and progress to avoid duplicate appends with a different chunking scheme.
	if [[ -f "$progress_file" ]]; then
		local hdr
		hdr=$(head -n1 "$progress_file" 2>/dev/null)
		if [[ "$hdr" =~ ^#\ chunk_size=([0-9]+)$ ]]; then
			local pf_cs
			pf_cs="${BASH_REMATCH[1]}"
			if [[ "$pf_cs" != "$chunk_size" ]]; then
				rm -f "${base_prefix}.nmap" "${base_prefix}.gnmap" "${base_prefix}.xml" "$progress_file" 2>/dev/null || true
			fi
		fi
	fi

	# Determine resume strategy per user requirement:
	# 1) If session .progress exists and is non-empty, continue from there
	# 2) Else if legacy .nmap exists and is non-empty, use nmap --resume
	# 3) Else start fresh (clear outputs and progress)
	local have_progress=false
	if [[ -s "$progress_file" ]]; then
		have_progress=true
	fi
	local nmap_state_file="${base_prefix}.nmap"
	local have_nmap_resume=false
	if [[ -s "$nmap_state_file" ]]; then
		have_nmap_resume=true
	fi

	if [[ "$have_progress" = true ]]; then
		# Keep existing outputs; continue chunk loop below
		:
	elif [[ "$have_nmap_resume" = true && "$resume" = "y" ]]; then
		# Use one-shot legacy resume and return; caller messaging preserved by this function
		execute_nmap_with_realtime_stats "nmap --resume \"$nmap_state_file\"" "$output_redirect"
		pid=$!
		contstatus="Pinging and scanning hosts"
		statusnmap
		checked_cmd="nmap --resume $nmap_state_file"
		wait $pid
		exitstatus=$?
		errorcheck
		return $exitstatus
	else
		# Fresh start: clear outputs and progress
		rm -f "${base_prefix}.nmap" "${base_prefix}.gnmap" "${base_prefix}.xml" "$progress_file" 2>/dev/null || true
	fi
	# Ensure progress file exists with size header; reset if chunk size changed
	if [[ -f "$progress_file" ]]; then
		local hdr
		hdr=$(head -n1 "$progress_file" 2>/dev/null)
		if [[ "$hdr" =~ ^#\ chunk_size=([0-9]+)$ ]]; then
			local pf_cs
			pf_cs="${BASH_REMATCH[1]}"
			if [[ "$pf_cs" != "$chunk_size" ]]; then
				rm -f "$progress_file" 2>/dev/null || true
			fi
		fi
	fi

	# Start a global periodic reporter (every ~10 minutes) during batched -sn
	# Enable in-process periodic aggregation for statusnmap
	z0e_sn_aggregate_enabled=true
	z0e_sn_base_prefix="$base_prefix"
	z0e_sn_total_hosts="${total_hosts:-0}"
	z0e_nmap_sn_periodic_printed=false
	if [[ ! -f "$progress_file" ]]; then
		printf "# chunk_size=%s\n" "$chunk_size" > "$progress_file"
	else
		local hdr_check
		hdr_check=$(head -n1 "$progress_file" 2>/dev/null)
		if [[ ! "$hdr_check" =~ ^#\ chunk_size= ]]; then
			printf "# chunk_size=%s\n" "$chunk_size" | cat - "$progress_file" > "$progress_file.tmp" && mv "$progress_file.tmp" "$progress_file"
		fi
	fi

	local chunk
	for chunk in "${chunks[@]}"; do
		# Skip completed chunks
		if grep -Fxq "$chunk" "$progress_file" 2>/dev/null; then
			continue
		fi
		# Build chunk command: swap -iL arg to this chunk and ensure --append-output
		local chunk_cmd
		chunk_cmd=$(echo "$full_cmd" | sed -E "s|(-iL)[[:space:]]+\"?[^\"[:space:]]+\"?|\\1 \"$chunk\"|" )
		[[ "$chunk_cmd" != *"--append-output"* ]] && chunk_cmd+=" --append-output"

		execute_nmap_with_realtime_stats "$chunk_cmd" "$output_redirect"
		pid=$!
		# Ensure spinner status text
		if [[ -z "$contstatus" ]]; then contstatus="Pinging and scanning hosts"; fi
		statusnmap
		checked_cmd="$chunk_cmd"
		wait $pid
		exitstatus=$?
		errorcheck
		if [[ $exitstatus -ne 0 ]]; then
			# Stop periodic reporter
			if [[ -n "$sn_progress_pid" ]] && kill -0 "$sn_progress_pid" >/dev/null 2>&1; then
				rm -f "$sn_active_flag" 2>/dev/null || true
				kill "$sn_progress_pid" 2>/dev/null || true
			fi
			return $exitstatus
		fi
		# Mark completed
		echo "$chunk" >> "$progress_file"
	done

	# Disable in-process periodic aggregation after completion
	z0e_sn_aggregate_enabled=false
	unset z0e_sn_base_prefix z0e_sn_total_hosts z0e_sn_next_print_ts

	return 0
}

function statusmasscan {
	indicator="^-_-^"
	z0e_masscan_periodic_printed=false
	local last_print_ts=$(date +%s)
	local interval=300
	while kill -0 $pid >/dev/null 2>&1; do
		local now=$(date +%s)
		if (( now - last_print_ts >= interval )); then
			# Read last chunk of the log, convert CR to NL, and pick the last full 'rate:' line
			lastchunk="$(tail -c 131072 "$periodicfile" 2>/dev/null | tr '\r' '\n')"
			lastline="$(printf "%s" "$lastchunk" | awk '/rate:/{line=$0} END{if (line) print line}')"
			if [[ -z "$lastline" ]]; then
				lastline="$(printf "%s" "$lastchunk" | sed '/^[[:space:]]*$/d' | tail -n 1)"
			fi
			if [[ -n "$lastline" ]]; then
				printf "\r\e[K\e[36m [i] masscan progress -- %s \e[0m\n" "$lastline"
				z0e_masscan_periodic_printed=true
			fi
			last_print_ts=$now
		fi
		i=$(( (i+1) % ${#indicator} ))
		printf "\r\e[K%s %s" "${indicator:$i:1}" "$contstatus"
		sleep 0.2
	done
	printf "\r\e[K"
}

########## Grouped TCP service scans helpers ##########
# Toggle: set to 'false' to disable grouped TCP service scans
: "${z0e_grouped_tcps_enabled:=true}"

# Build a manifest grouping hosts by identical TCP open-port sets discovered by masscan
# Output format (one line per group):
#   ports_csv|ip1 ip2 ip3
z0e_build_tcp_groups_manifest() {
    local manifest="$1"
    local discofile
    local alive="$filepath/$typevar-aliveHosts.txt"
    mkdir -p "$(dirname "$manifest")" 2>/dev/null || true
    : > "$manifest"

    # Prefer nosusips file if present
    if [ -f "$filepath/logs/processed/$typevar-discoscan-masscan-tcp-nosusips.txt" ]; then
        discofile="$filepath/logs/processed/$typevar-discoscan-masscan-tcp-nosusips.txt"
    else
        discofile="$filepath/logs/processed/$typevar-discoscan-masscan-tcp.txt"
    fi

    # Require discovery file and alive hosts
    if [ ! -f "$discofile" ] || [ ! -s "$alive" ]; then
        return 1
    fi

	local tmp_file="$manifest.tmp"
	# Build lines of: sorted_ports_csv|ip  (only for alive hosts)
	awk -v alive="$alive" '
		BEGIN {
			while ((getline line < alive) > 0) {
				gsub(/\r$/, "", line);
				alivehosts[line]=1
			}
		}
		/Host:/ {
			ip="";
			for (i=1;i<=NF;i++) if ($i=="Host:" && (i+1)<=NF){ ip=$(i+1); break }
			if (ip=="" || alivehosts[ip]!=1) next
			p_index=index($0, "Ports:"); if (p_index==0) next
			ports_str=substr($0, p_index+6)
			n=split(ports_str, arr, ","); cnt=0
			# Clear any previous ports array entries (portable across awk variants)
			for (x in plist) delete plist[x]
			for (j=1;j<=n;j++) {
				gsub(/^[ \t]+|[ \t]+$/, "", arr[j])
				# split fields of entry like "80/open/tcp//..."
				split(arr[j], fld, "/")
				if (fld[2]=="open" && fld[3]=="tcp") {
					port=fld[1]
					if (port ~ /^[0-9]+$/) { plist[++cnt]=port+0 }
				}
			}
			if (cnt==0) next
			# In-place insertion sort (numeric)
			for (a=2; a<=cnt; a++) {
				key=plist[a]+0; b=a-1
				while (b>=1 && (plist[b]+0) > key) { plist[b+1]=plist[b]; b-- }
				plist[b+1]=key
			}
			# De-dup and join as CSV
			prev=""; csv=""
			for (k=1; k<=cnt; k++) {
				p=plist[k]+0
				if (p!=prev) {
					if (csv=="") csv=p; else csv=sprintf("%s,%s", csv, p)
					prev=p
				}
			}
			if (csv!="") print csv "|" ip
		}
	' "$discofile" > "$tmp_file" 2>/dev/null

    if [ ! -s "$tmp_file" ]; then
        rm -f "$tmp_file" 2>/dev/null || true
        return 2
    fi

    # Group by ports key and aggregate host lists
    sort -t '|' -k1,1 "$tmp_file" | awk -F'|' '
        {
            if ($1!=prev) {
                if (prev!="") print prev "|" hosts
                prev=$1; hosts=$2
            } else {
                hosts = hosts " " $2
            }
        }
        END { if (prev!="") print prev "|" hosts }
    ' > "$manifest"

    rm -f "$tmp_file" 2>/dev/null || true
    [ -s "$manifest" ]
}

z0e_grouped_state_exists() {
	local groups_dir="$filepath/logs/processed/${typevar}-tcp-groups"
	local manifest="$filepath/logs/processed/$typevar-tcp-groups.manifest"
	if [ -s "$manifest" ] || [ -d "$groups_dir" ]; then
		return 0
	fi
	return 1
}

# Merge per-group Nmap outputs into canonical artifacts
z0e_merge_grouped_nmap_outputs() {
    local groups_dir="$1"
    local dest_base="$filepath/$typevar-tcp-servicescan-results"
    local merged_nmap="${dest_base}.nmap"
    local merged_gnmap="${dest_base}.gnmap"
    local merged_xml="${dest_base}.xml"

    rm -f "$merged_nmap" "$merged_gnmap" "$merged_xml" 2>/dev/null || true

    # Concatenate .nmap and .gnmap (retain Host lines for gnmap)
    find "$groups_dir" -maxdepth 1 -type f -name "*.nmap" -print0 2>/dev/null | xargs -0 -I{} sh -c 'cat "$1" >> "$2"' _ {} "$merged_nmap" 2>/dev/null || true
    find "$groups_dir" -maxdepth 1 -type f -name "*.gnmap" -print0 2>/dev/null | xargs -0 -I{} sh -c 'grep -E "^Host:|^# Nmap" "$1" >> "$2"' _ {} "$merged_gnmap" 2>/dev/null || true

    # Build merged XML: header from first, all <host> blocks, runstats/footer from last
    local first_xml last_xml
    first_xml=$(ls -1 "$groups_dir"/*.xml 2>/dev/null | head -n 1)
    last_xml=$(ls -1 "$groups_dir"/*.xml 2>/dev/null | tail -n 1)
    if [ -n "$first_xml" ] && [ -n "$last_xml" ]; then
        # Header (before first <host>)
        awk 'BEGIN{printed=0} /<host/{exit} {print}' "$first_xml" > "$merged_xml"
        # All host blocks
        for x in "$groups_dir"/*.xml; do
            awk '/<host[[:space:]>]/{flag=1} flag{print} /<\/host>/{flag=0}' "$x" >> "$merged_xml"
        done
        # Footer from <runstats> to end
        awk '/<runstats>/{flag=1} flag{print}' "$last_xml" >> "$merged_xml"
    fi

    # Success if we produced at least any of the outputs
    if [ -s "$merged_gnmap" ] || [ -s "$merged_xml" ] || [ -s "$merged_nmap" ]; then
        return 0
    fi
    return 1
}

# Orchestrate grouped TCP service scans and merge results
run_grouped_tcp_services_scan() {
    # Build manifest of port groups
    local manifest="$filepath/logs/processed/$typevar-tcp-groups.manifest"
    if ! z0e_build_tcp_groups_manifest "$manifest"; then
        return 1
    fi

	local groups_dir="$filepath/logs/processed/${typevar}-tcp-groups"
	if [[ "$resume" = "y" ]] && [ -d "$groups_dir" ]; then
		mkdir -p "$groups_dir" 2>/dev/null || true
	else
		rm -rf "$groups_dir" 2>/dev/null || true
		mkdir -p "$groups_dir" 2>/dev/null || true
	fi

	local total_groups
	total_groups=$(wc -l < "$manifest" 2>/dev/null || echo 0)
    if [ "$total_groups" -eq 0 ]; then
        return 1
    fi

	# Compute total grouped weight (hosts √ó ports per group) for overall progress
	local __z0e_total_weight=0
	while IFS='|' read -r __ports_csv __hosts; do
		[[ -z "$__ports_csv" || -z "$__hosts" ]] && continue
		# Count hosts in this group
		local __hc=0
		read -r -a __harr <<< "$__hosts"; __hc=${#__harr[@]}
		# Count ports in this group
		local __pc
		__pc=$(echo "$__ports_csv" | awk -F',' '{print NF}')
		[[ -z "$__pc" || "$__pc" = 0 ]] && __pc=0
		__z0e_total_weight=$(( __z0e_total_weight + (__hc * __pc) ))
	done < "$manifest"

	# Initialize grouped progress context for periodic printer
	Z0E_GROUPED_ENABLED=true
	Z0E_GROUPED_START_EPOCH=$(date +%s)
	Z0E_GROUPED_TOTAL_GROUPS=$total_groups
	Z0E_GROUPED_TOTAL_WEIGHT=${__z0e_total_weight:-0}
	Z0E_GROUPED_COMPLETED_WEIGHT=0

	# If resuming from an existing groups directory, inform the user once
	if [[ "$resume" = "y" ]] && [ -d "$groups_dir" ]; then
		echo -e "\e[36m [i] Resuming grouped TCP service scans (continuing remaining groups) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
	fi

	# Compact, user-friendly headers
	echo -e "\e[36m [i] Grouping hosts by open ports for efficiency ($total_groups groups) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
	echo -e "\e[34m [-] Scanning services on open TCP ports of alive hosts with Nmap -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"

    local idx=0
    while IFS='|' read -r ports_csv hosts; do
        idx=$((idx+1))
        # Normalize an id for filenames (replace commas with underscores)
		local gid
        gid=$(echo "$ports_csv" | tr ',' '_')
        local hosts_file="$groups_dir/hosts_${gid}.txt"
        local base_prefix="$groups_dir/${typevar}-tcp-group_${gid}"
        printf "%s\n" $hosts > "$hosts_file"

		local nmap_file="${base_prefix}.nmap"
		local xml_file="${base_prefix}.xml"

		# Compute current group weight for overall progress (hosts √ó ports)
		local __cur_hc=0 __cur_pc=0 __cur_weight=0
		read -r -a __cur_harr <<< "$hosts"; __cur_hc=${#__cur_harr[@]}
		__cur_pc=$(echo "$ports_csv" | awk -F',' '{print NF}')
		[[ -z "$__cur_pc" || "$__cur_pc" = 0 ]] && __cur_pc=0
		__cur_weight=$(( __cur_hc * __cur_pc ))
		Z0E_GROUPED_CURRENT_WEIGHT=${__cur_weight:-0}

		# Skip only if truly complete; otherwise resume if state exists
		local group_done=0
		if [[ -s "$nmap_file" ]] && grep -q "Nmap done" "$nmap_file" 2>/dev/null; then
			group_done=1
		elif [[ -s "$xml_file" ]] && grep -q "</nmaprun>" "$xml_file" 2>/dev/null; then
			group_done=1
		fi

		local cmd
		if [[ $group_done -eq 1 ]]; then
			# Count already-complete group toward overall progress
			Z0E_GROUPED_COMPLETED_WEIGHT=$(( ${Z0E_GROUPED_COMPLETED_WEIGHT:-0} + ${Z0E_GROUPED_CURRENT_WEIGHT:-0} ))
			echo -e "\e[36m [i] Group $idx/$total_groups already complete; skipping \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			continue
		elif [[ -s "$nmap_file" ]]; then
			cmd="nmap --resume \"$nmap_file\""
		else
			if [[ "$ngineer_mode" == true ]]; then
				if [[ "$ngineer_tcps_default" == true ]]; then
					cmd="nmap -sC -sV -Pn -O -p $ports_csv --open --reason -oA $base_prefix --excludefile $nostrikes -iL $hosts_file"
				else
					cmd="nmap $z0eng_tcps_opts -sV -Pn -p $ports_csv -oA $base_prefix --excludefile $nostrikes -iL $hosts_file"
				fi
			else
				cmd="nmap -sC -sV -Pn -O -p $ports_csv --open --reason -oA $base_prefix --excludefile $nostrikes -iL $hosts_file"
			fi
		fi

		# Suppress per-group command echo; spinner will indicate current group
		execute_nmap_with_realtime_stats "$cmd" "1>/dev/null 2>>$filepath/logs/$typevar-errors.log"
        pid=$!
        contstatus="Scanning TCP ports (group $idx/$total_groups)"
        statusnmap
        checked_cmd="$cmd"
        wait $pid
        exitstatus=$?
		if [ "$exitstatus" -ne 0 ]; then
            errorcheck
            echo -e "\e[33m [!] Group $idx failed, aborting grouped scans (will fallback) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
            return 1
        fi
		# On success, accumulate completed weight
		Z0E_GROUPED_COMPLETED_WEIGHT=$(( ${Z0E_GROUPED_COMPLETED_WEIGHT:-0} + ${Z0E_GROUPED_CURRENT_WEIGHT:-0} ))
    done < "$manifest"

    # Merge artifacts to canonical outputs
	if z0e_merge_grouped_nmap_outputs "$groups_dir"; then
        return 0
    fi
    return 1
}

function statusgeniplist {
	if [ "$use_stderr" = true ]; then
	    status_target="/dev/stderr"
	else
	    status_target="/dev/stdout"
	fi
	local pid=$1
    local delay=0.2
    local chars='.oO0@'
    while kill -0 "$pid" 2>/dev/null; do
        for (( i=0; i<${#chars}; i++ )); do
            # \r returns to the beginning of the line
            printf "\r%s %s" "$status_msg" "${chars:$i:1}" > "$status_target"
            sleep "$delay"
        done
    done
    # Print the final message once done (with newline to avoid line mixing)
	printf "\r%s Done\n" "$status_msg" > "$status_target"
	use_stderr=false
}

function errorcheck { #Checks for errors in command output
	errorlog="/logs/$typevar-errors.log"

	if [ "$exitstatus" -ne 0 ]; then
		echo "--------" >> "$errorlog"
		echo "COMMAND: $checked_cmd" >> "$errorlog"
		echo "===================================" >> "$errorlog"
		echo '' >> "$errorlog"
		echo -e "\e[31m [X] Error occured -- check logs in $errorlog \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log" >&2
	fi
}

function whenkilled {
	#Kill the periodic status process if it's running
    if [[ -n $status_pid ]] && kill -0 $status_pid >/dev/null 2>&1; then       
		kill $status_pid
    fi
	# Clear any active spinner/status line before printing messages
	printf "\r\e[K"
	#Display exiting status
	if [[ "$firewallset" = true ]]; then
		removefirewallrule
	fi
	status_msg="[!] Zero-E stopped -- saving progress..."  
	echo -e "\e[33m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
	ntfy "$status_msg"
	sleep 3
	sed -i -e 's/\x1b\[[0-9;]*m//g' -e 's/\x1b\[A//g' -e 's/\x1b\[K//g' "$filepath/logs/$typevar-timestamps.log" #cleans up timestamps log
	sed -i '/nocapture = servername/d' paused.conf 2>/dev/null #Removes line that breaks masscan --resume function
	sed -i 's/adapter-port = [0-9]*-[0-9]*/adapter-port = 40000-41023/' paused.conf 2>/dev/null #Fixes another line that breaks masscan --resume function... cmon masscan, do better
	#Remove the trap to prevent it from repeating
	trap - INT TERM  
	exit 1
}

function z0ecleanup {
    sed -i 's/\x1b\[[0-9;?]*[A-Za-z]//g' "$filepath/logs/$typevar-timestamps.log" # Cleans up timestamps log
    
    if [[ "$session_flag" = true && -n "$session" ]]; then
        # Remove only session-specific files
        rm -rf "/var/lib/zeroe/sessions/$session" 2>/dev/null
    else
        # No active session; remove only global files, keep session data
        rm -rf /var/lib/zeroe/stage.z0e /var/lib/zeroe/vars.z0e /var/lib/zeroe/initdir.z0e \
               /var/lib/zeroe/excludes-single-ips.z0e /var/lib/zeroe/targets-single-ips.z0e 2>/dev/null
    fi

    rm paused.conf 2>/dev/null
}

function checktools {
  	oscheck=$(uname)
  	if [ "$oscheck" = "Darwin" ]; then  # For macOS
    	missing=()
    	for tool in "${mactools[@]}"; do
      		if ! command -v "$tool" >/dev/null 2>&1; then
				if [ "$tool" = "realpath" ]; then
					missing+=(coreutils)
				else
					missing+=("$tool")
				fi
	  		fi
    	done
    	if [ ${#missing[@]} -gt 0 ]; then
      		echo -e "\e[33m[!] The following required tools are not installed: ${missing[*]}\e[0m"
      		# Ask if user wants to install
      		read -p "Install them now using Homebrew? <y/n> " resp
      		if [[ "$resp" =~ ^[Yy]$ ]]; then
        		# Install missing tools
        		for tool in "${missing[@]}"; do
          			echo "Installing $tool..."
          			brew install "$tool"
        		done
        		echo -e "\e[32m[+] All missing required tools have been installed\e[0m\n"
      		else
        		echo -e "\nYou can install them manually with:\n  brew install <tool>\n"
        		exit 1
      		fi
    	fi
  	else  # For Linux
    	missing=()
    	for tool in "${linuxtools[@]}"; do
      		if ! command -v "$tool" >/dev/null 2>&1; then
        		if [ "$tool" = "realpath" ]; then
					missing+=(coreutils)
				else
					missing+=("$tool")
				fi
      		fi
    	done
    	if [ ${#missing[@]} -gt 0 ]; then
      		echo -e "\e[33m[!] The following required tools are not installed: ${missing[*]}\e[0m"
      		# Ask if user wants to install
      		read -p "Install them now using apt? <y/n> " resp
      		if [[ "$resp" =~ ^[Yy]$ ]]; then
        		# Update apt cache and install missing tools
        		sudo apt update
        		for tool in "${missing[@]}"; do
          			echo "Installing $tool..."
          			sudo apt install -y "$tool"
        		done
        		echo -e "\e[32m[+] All missing required tools have been installed\e[0m\n"
      		else
        		echo -e "\nYou can install them manually with:\n  sudo apt install <tool>\n"
        		exit 1
      		fi
    	fi
  	fi
}

function ensure_nmap_service_probes { # Ensures masscan can use Nmap payloads
	local probes_path="/usr/share/nmap/nmap-service-probes"
	# Silent success if present
	if [ -f "$probes_path" ]; then
		return 0
	fi

	# Not found: ask to download
	echo -e "\e[33m [!] nmap-service-probes not found at $probes_path\e[0m" 1>&2
	echo -e "\e[33m     This file is required for masscan UDP discovery scans\e[0m" 1>&2
	read -r -p "Download it now from the official Nmap repo? [Y/n]: " yn
	yn=${yn:-Y}
	case "$yn" in
		[Yy]*)
			mkdir -p "$(dirname "$probes_path")" 2>/dev/null || true
			if command -v wget >/dev/null 2>&1; then
				sudo wget https://raw.githubusercontent.com/nmap/nmap/refs/heads/master/nmap-service-probes -O "$probes_path" 1>&2 || true
			elif command -v curl >/dev/null 2>&1; then
				sudo curl -fsSL https://raw.githubusercontent.com/nmap/nmap/refs/heads/master/nmap-service-probes -o "$probes_path" 1>&2 || true
			else
				echo -e "\e[31m [!] Neither wget nor curl is installed -- cannot download nmap-service-probes.\e[0m" 1>&2
				return 1
			fi
			;;
		*)
			# User declined; continue without forcing
			return 1
			;;
	esac

	# Final check: ensure file now exists
	if [ -f "$probes_path" ]; then
		return 0
	else
		echo -e "\e[31m [X] Required file $probes_path still not present. Aborting.\e[0m" 1>&2
		return 1
	fi
}

function z0engineer { #Enables users to customize commands
	echo -e "\e[33m[!] z0e ngineer mode is experimental"
	echo -e "[!] It tries to prevent command options that will cause errors"
	echo -e "[!] But given the large number of possible options, it does not catch everything"
	echo -e "[!] If z0e errors, it is likely due to input passed in these commands \e[0m"
	#create prompts for all necessary commands depending on if internal or external, saying not to include targets, excludes, output, etc
	if [[ "$e_opt" = true || "$type" = "E" || "$type" = "e" || "$type" = "external" || "$type" = "External" || "$type" = "Ext" || "$type" = "ext" ]]; then
		# Custom options for external Nmap discovery-hosts scan
		echo "[?] Provide custom options for the Nmap alive host discovery command:"
		echo "    Leave blank to use the z0e default"
		echo "    Hardcoded: <--excludefile> <-iL> <-oG>"
		while true; do
			read -e -p " [>] " z0eng_ext_alives_opts
			if [[ -z "$z0eng_ext_alives_opts" ]]; then
				ngineer_ext_alives_default=true
				break
			elif [[ "$z0eng_ext_alives_opts" =~ (--excludefile|-iL|>>|>|&|-oG|-oA) ]]; then
				echo -e "\e[31m [X] Error: The options cannot contain [ --excludefile | -iL | >> | > | & | -oG | -oA ] -- these are provided by z0e \e[0m" >&2
			elif [[ "$z0eng_ext_alives_opts" == *"nmap"* ]]; then
				echo -e "\e[31m [X] Error: Only provide the desired options, not the command name \e[0m" >&2
			else
				break
			fi
		done
		echo "[?] Provide custom options for the masscan open port discovery scan command:"
		echo "    Leave blank to use the z0e default"
		echo "    Hardcoded: <--open-only> <--excludefile> <--include-file> <-oG>"
		while true; do
			read -e -p " [>] " z0eng_masscan_tcp_opts
			if [[ -z "$z0eng_masscan_tcp_opts" ]]; then #leave blank to use default
				ngineer_ports_default=true
				break
			elif [[ "$z0eng_masscan_tcp_opts" =~ (--excludefile|--include-file|>>|>|&|-oG|-oA) ]] || [[ "$z0eng_masscan_tcp_opts" == "- " ]] || { [[ "$z0eng_masscan_tcp_opts" =~ (-)$ ]] && [[ ! "$z0eng_masscan_tcp_opts" =~ "-p-" ]]; }; then
				echo -e "\e[31m [X] Error: The command cannot contain [ --excludefile | --include-file | >> | > | & | - | -p- | -oG | -oA ] -- this will likely cause errors\e[0m" >&2
			elif [[ "$z0eng_masscan_tcp_opts" == *"masscan"* ]]; then
				echo -e "\e[31m [X] Error: Only provide the desired options \e[0m" >&2
			elif [[ "$z0eng_masscan_tcp_opts" == *"nmap"* ]]; then
				echo -e "\e[31m [X] Error: Currently, Nmap cannot be used here \e[0m" >&2
			elif ! [[ "$z0eng_masscan_tcp_opts" =~ (-p[[:space:]]*([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])(-([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))?|--top-ports[[:space:]]+([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))|-p- ]]; then
				echo -e "\e[31m [X] Error: At minimum, you must specify ports with -p or --top-ports with proper syntax \e[0m" >&2
			else
				break
			fi
		done

		if [[ "$U_opt" = true || "$udp" = "y" || "$udp" = "yes" ]]; then
			echo "[?] Provide custom options for the masscan UDP discovery scan command:"
			echo "    Leave blank to use the z0e default"
			echo "    Hardcoded: <--nmap-payloads> <--open-only> <--excludefile> <--include-file> <-oG>"
			while true; do
				read -e -p " [>] " z0eng_udpa_opts
				if [[ -z "$z0eng_udpa_opts" ]]; then #leave blank to use default
					ngineer_udpa_default=true
					break
				elif [[ "$z0eng_udpa_opts" =~ (--excludefile|--include-file|>>|>|&|-oG|-oA) ]] || [[ "$z0eng_udpa_opts" == *"- "* ]] || { [[ "$z0eng_udpa_opts" =~ (-)$ ]] && [[ ! "$z0eng_udpa_opts" =~ "-p-" ]]; }; then
					echo -e "\e[31m [X] Error: The command cannot contain [ --excludefile | --include-file | >> | > | & | - | -oG | -oA ] -- this will likely cause errors \e[0m" >&2
				elif [[ "$z0eng_udpa_opts" == *"nmap"* ]]; then
					echo -e "\e[31m [X] Error: Only provide the desired options \e[0m" >&2
				elif [[ "$z0eng_udpa_opts" == *"masscan"* ]]; then
					echo -e "\e[31m [X] Error: Only provide options, not the command name \e[0m" >&2
				elif ! [[ "$z0eng_udpa_opts" =~ (-p[[:space:]]*([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])(-([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))?|--top-ports[[:space:]]+([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))|-p- ]]; then
					echo -e "\e[31m [X] Error: At minimum, you must specify ports with -p or --top-ports with proper syntax \e[0m" >&2
				else
					break
				fi
			done
		fi

		echo "[?] Provide custom options for the Nmap TCP service scan command:"
		echo "    Leave blank to use the z0e default"
		echo "    Hardcoded: <-sV> <-Pn> <-p> <--excludefile> <-iL> <-oA>"
		while true; do
			read -e -p " [>] " z0eng_tcps_opts
			if [[ -z "$z0eng_tcps_opts" ]]; then #leave blank to use default
				ngineer_tcps_default=true
				break
			elif [[ "$z0eng_tcps_opts" =~ (--excludefile|-iL|>>|>|&|-o\*) ]] || [[ "$z0eng_tcps_opts" == *"- "* ]] || { [[ "$z0eng_tcps_opts" =~ (-)$ ]] && [[ ! "$z0eng_tcps_opts" =~ "-p-" ]]; }; then
				echo -e "\e[31m [X] Error: The command cannot contain [ --excludefile | -iL | >> | > | & | - | -o* ] -- this will likely cause errors \e[0m" >&2
			elif [[ "$z0eng_tcps_opts" == *"nmap"* ]]; then
				echo -e "\e[31m [X] Error: Only provide the desired options \e[0m" >&2
			elif [[ "$z0eng_tcps_opts" == *"masscan"* ]]; then
				echo -e "\e[31m [X] Error: Currently, masscan cannot be used here \e[0m" >&2
			elif [[ "$z0eng_tcps_opts" == *"-p"* ]] || [[ "$z0eng_tcps_opts" == *"--top-ports"* ]]; then
				echo -e "\e[31m [X] Error: z0e will provide only open ports to this scan \e[0m" >&2
			else
				break
			fi
		done

		if [[ "$U_opt" = true || "$udp" = "y" || "$udp" = "yes" ]]; then
			echo "[?] Provide custom options for the Nmap UDP service scan command:"
			echo "    Leave blank to use the z0e default"
			echo "    Hardcoded: <-sU> <-sV> <-Pn> <-p> <--excludefile> <-iL> <-oA>"
			while true; do
				read -e -p " [>] " z0eng_udps_opts
				if [[ -z "$z0eng_udps_opts" ]]; then #leave blank to use default
					ngineer_udps_default=true
					break
				elif [[ "$z0eng_udps_opts" =~ (--excludefile|-iL|>>|>|&|-o\*) ]] || [[ "$z0eng_udps_opts" == *"- "* ]] || { [[ "$z0eng_udps_opts" =~ (-)$ ]] && [[ ! "$z0eng_udps_opts" =~ "-p-" ]]; }; then
					echo -e "\e[31m [X] Error: The command cannot contain [ --excludefile | -iL | >> | > | & | - | -o* ] -- this will likely cause errors \e[0m" >&2
				elif [[ "$z0eng_udps_opts" == *"nmap"* ]]; then
					echo -e "\e[31m [X] Error: Only provide the desired options \e[0m" >&2
				elif [[ "$z0eng_udps_opts" == *"masscan"* ]]; then
					echo -e "\e[31m [X] Error: Currently, masscan cannot be used here \e[0m" >&2
				elif [[ "$z0eng_udps_opts" == *"-p"* ]] || [[ "$z0eng_udps_opts" == *"--top-ports"* ]]; then
					echo -e "\e[31m [X] Error: z0e will provide only open ports to this scan \e[0m" >&2
				else
					break
				fi
			done
		fi

	elif [[ "$i_opt" = true || "$type" = "I" || "$type" = "i" || "$type" = "internal" || "$type" = "Internal" || "$type" = "Int" || "$type" = "int" ]]; then
		###Internal###
		# Internal alive-host discovery customization based on tool selection threshold
		if (( ${total_hosts:-0} >= 1 && ${total_hosts:-0} <= 24999 )); then
			echo "[?] Provide custom options for the Nmap alive host discovery command:"
			echo "    Leave blank to use the z0e default"
			echo "    Hardcoded: <-sn> <--excludefile> <-iL> <-oA> <--reason> <--stats-every>"
			while true; do
				read -e -p " [>] " z0eng_int_alives_nmap_opts
				if [[ -z "$z0eng_int_alives_nmap_opts" ]]; then
					ngineer_int_alives_default=true
					break
				elif [[ "$z0eng_int_alives_nmap_opts" =~ (--excludefile|-iL|>>|>|&|-oG|-oA) ]]; then
					echo -e "\e[31m [X] Error: The options cannot contain [ --excludefile | -iL | >> | > | & | -oG | -oA ] -- these are provided by z0e \e[0m" >&2
				elif [[ "$z0eng_int_alives_nmap_opts" == *"nmap"* ]]; then
					echo -e "\e[31m [X] Error: Only provide the desired options, not the command name \e[0m" >&2
				else
					break
				fi
			done
		elif (( ${total_hosts:-0} >= 25000 )); then
			echo "[?] Provide custom options for the masscan alive host discovery command:"
			echo "    Leave blank to use the z0e default"
			echo "    Hardcoded: <--src-port 55555> <--excludefile> <--include-file> <-oG>"
			while true; do
				read -e -p " [>] " z0eng_int_alives_masscan_opts
				if [[ -z "$z0eng_int_alives_masscan_opts" ]]; then
					ngineer_int_alives_default=true
					break
				elif [[ "$z0eng_int_alives_masscan_opts" =~ (--src-port|--excludefile|--include-file|>>|>|&|-oG|-oA) ]] || [[ "$z0eng_int_alives_masscan_opts" == *"- "* ]] || { [[ "$z0eng_int_alives_masscan_opts" =~ (-)$ ]] && [[ ! "$z0eng_int_alives_masscan_opts" =~ "-p-" ]]; }; then
					echo -e "\e[31m [X] Error: The command cannot contain [ --src-port | --excludefile | --include-file | >> | > | & | - | -p- | -oG | -oA ] -- this will likely cause errors \e[0m" >&2
				elif [[ "$z0eng_int_alives_masscan_opts" == *"nmap"* ]] || [[ "$z0eng_int_alives_masscan_opts" == *"masscan"* ]]; then
					echo -e "\e[31m [X] Error: Only provide options, not the command name \e[0m" >&2
				else
					break
				fi
			done
		fi
		echo "[?] Provide custom options for the masscan open port discovery scan command:"
		echo "    Leave blank to use the z0e default"
		echo "    Hardcoded: <--src-port 55555> <--open-only> <--excludefile> <--include-file> <-oG>"
		while true; do
			read -e -p " [>] " z0eng_masscan_tcp_opts
			if [[ -z "$z0eng_masscan_tcp_opts" ]]; then #leave blank to use default
				ngineer_ports_default=true
				break
			elif [[ "$z0eng_masscan_tcp_opts" =~ (--src-port|--excludefile|--include-file|>>|>|&|-oG|-oA) ]] || [[ "$z0eng_masscan_tcp_opts" == *"- "* ]] || { [[ "$z0eng_masscan_tcp_opts" =~ (-)$ ]] && [[ ! "$z0eng_masscan_tcp_opts" =~ "-p-" ]]; }; then
				echo -e "\e[31m [X] Error: The command cannot contain [ --src-port | --excludefile | --include-file | >> | > | & | - | -oG | -oA ] -- this will likely cause errors \e[0m" >&2
			elif [[ "$z0eng_masscan_tcp_opts" == *"masscan"* ]]; then
				echo -e "\e[31m [X] Error: Only provide the desired options \e[0m" >&2
			elif [[ "$z0eng_masscan_tcp_opts" == *"nmap"* ]]; then
				echo -e "\e[31m [X] Error: Currently, Nmap cannot be used here \e[0m" >&2
			elif ! [[ "$z0eng_masscan_tcp_opts" =~ (-p[[:space:]]*([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])(-([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))?|--top-ports[[:space:]]+([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))|-p- ]]; then
				echo -e "\e[31m [X] Error: At minimum, you must specify ports with -p or --top-ports with proper syntax \e[0m" >&2
			else
				break
			fi
		done

		if [[ "$U_opt" = true || "$udp" = "y" || "$udp" = "yes" ]]; then
			echo "[?] Provide custom options for the masscan UDP discovery scan command:"
			echo "    Leave blank to use the z0e default"
			echo "    Hardcoded: <--nmap-payloads> <--open-only> <--excludefile> <--include-file> <-oG>"
			while true; do
				read -e -p " [>] " z0eng_udpa_opts
				if [[ -z "$z0eng_udpa_opts" ]]; then #leave blank to use default
					ngineer_udpa_default=true
					break
				elif [[ "$z0eng_udpa_opts" =~ (--excludefile|--include-file|>>|>|&|-oG|-oA) ]] || [[ "$z0eng_udpa_opts" == *"- "* ]] || { [[ "$z0eng_udpa_opts" =~ (-)$ ]] && [[ ! "$z0eng_udpa_opts" =~ "-p-" ]]; }; then
					echo -e "\e[31m [X] Error: The command cannot contain [ --excludefile | --include-file | >> | > | & | - | -oG | -oA ] -- this will likely cause errors \e[0m" >&2
				elif [[ "$z0eng_udpa_opts" == *"nmap"* ]]; then
					echo -e "\e[31m [X] Error: Only provide the desired options \e[0m" >&2
				elif [[ "$z0eng_udpa_opts" == *"masscan"* ]]; then
					echo -e "\e[31m [X] Error: Only provide options, not the command name \e[0m" >&2
				elif ! [[ "$z0eng_udpa_opts" =~ (-p[[:space:]]*([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])(-([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))?|--top-ports[[:space:]]+([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))|-p- ]]; then
					echo -e "\e[31m [X] Error: At minimum, you must specify ports with -p or --top-ports with proper syntax \e[0m" >&2
				else
					break
				fi
			done
		fi

		echo "[?] Provide custom options for the Nmap TCP service scan command:"
		echo "    Leave blank to use the z0e default"
		echo "    Hardcoded: <-sV> <-Pn> <-p> <--excludefile> <-iL> <-oA>"
		while true; do
			read -e -p " [>] " z0eng_tcps_opts
			if [[ -z "$z0eng_tcps_opts" ]]; then #leave blank to use default
				ngineer_tcps_default=true
				break
			elif [[ "$z0eng_tcps_opts" =~ (--excludefile|-iL|>>|>|&|-o\*) ]] || [[ "$z0eng_tcps_opts" == *"- "* ]] || { [[ "$z0eng_tcps_opts" =~ (-)$ ]] && [[ ! "$z0eng_tcps_opts" =~ "-p-" ]]; }; then
				echo -e "\e[31m [X] Error: The command cannot contain [ --excludefile | -iL | >> | > | & | - | -o* ] -- this will likely cause errors \e[0m" >&2
			elif [[ "$z0eng_tcps_opts" == *"nmap"* ]]; then
				echo -e "\e[31m [X] Error: Only provide the desired options \e[0m" >&2
			elif [[ "$z0eng_tcps_opts" == *"masscan"* ]]; then
				echo -e "\e[31m [X] Error: Currently, masscan cannot be used here \e[0m" >&2
			elif [[ "$z0eng_tcps_opts" == *"-p"* ]] || [[ "$z0eng_tcps_opts" == *"--top-ports"* ]]; then
				echo -e "\e[31m [X] Error: z0e will provide only open ports to this scan \e[0m" >&2
			else
				break
			fi
		done

		if [[ "$U_opt" = true || "$udp" = "y" || "$udp" = "yes" ]]; then
			echo "[?] Provide custom options for the Nmap UDP service scan command:"
			echo "    Leave blank to use the z0e default"
			echo "    Hardcoded: <-sU> <-sV> <-Pn> <-p> <--excludefile> <-iL> <-oA>"
			while true; do
				read -e -p " [>] " z0eng_udps_opts
				if [[ -z "$z0eng_udps_opts" ]]; then #leave blank to use default
					ngineer_udps_default=true
					break
				elif [[ "$z0eng_udps_opts" =~ (--excludefile|-iL|>>|>|&|-o\*) ]] || [[ "$z0eng_udps_opts" == *"- "* ]] || { [[ "$z0eng_udps_opts" =~ (-)$ ]] && [[ ! "$z0eng_udps_opts" =~ "-p-" ]]; }; then
					echo -e "\e[31m [X] Error: The command cannot contain [ --excludefile | -iL | >> | > | & | - | -o* ] -- this will likely cause errors \e[0m" >&2
				elif [[ "$z0eng_udps_opts" == *"nmap"* ]]; then
					echo -e "\e[31m [X] Error: Only provide the desired options \e[0m" >&2
				elif [[ "$z0eng_udps_opts" == *"masscan"* ]]; then
					echo -e "\e[31m [X] Error: Currently, masscan cannot be used here \e[0m" >&2
				elif [[ "$z0eng_udps_opts" == *"-p"* ]] || [[ "$z0eng_udps_opts" == *"--top-ports"* ]]; then
					echo -e "\e[31m [X] Error: z0e will provide only open ports to this scan \e[0m" >&2
				else
					break
				fi
			done
		fi
	fi	
}

function totaltargets {  # Counts total number of hosts in a targets file

    # Function to convert a dotted-decimal IP to an integer.
    # Returns -1 if the IP is invalid.
    ip_to_int() {
        local ip="$1"
        local IFS='.'
        read -ra octets <<< "$ip"
        # Ensure exactly 4 octets are provided.
        if (( ${#octets[@]} != 4 )); then
            echo "-1"
            return 1
        fi

        local result=0
        for octet in "${octets[@]}"; do
            # Check that each octet is a number between 0 and 255.
            if ! [[ "$octet" =~ ^[0-9]+$ ]] || (( octet < 0 || octet > 255 )); then
                echo "-1"
                return 1
            fi
            result=$(( (result << 8) + octet ))
        done
        echo "$result"
    }

    # Function to calculate the number of hosts in a CIDR block.
    # It includes network addresses (.0) but excludes broadcast addresses (.255) for prefixes < 31.
    calculate_cidr_hosts() {
        local cidr="$1"
        local ip prefix
        IFS=/ read -r ip prefix <<< "$cidr"

        # Validate CIDR prefix.
        if ! [[ "$prefix" =~ ^[0-9]+$ ]] || (( prefix < 0 || prefix > 32 )); then
            echo "0"
            return
        fi

        # Calculate the total number of addresses.
        local total_addresses=$(( 1 << (32 - prefix) ))
        # For subnets with more than 1 address, subtract only broadcast address.
        if (( prefix < 31 )); then
            total_addresses=$(( total_addresses - 1 ))
        fi

        # Ensure we don't get a negative number.
        if (( total_addresses < 0 )); then
            total_addresses=0
        fi

        echo "$total_addresses"
    }

    # Function to calculate the number of hosts in an IP range.
    calculate_ip_range_hosts() {
        local ip_range="$1"
        local IFS='-'
        local start end

        read -r start end <<< "$ip_range"

        # Convert both IP addresses to their integer representations.
        local start_long=$(ip_to_int "$start")
        local end_long=$(ip_to_int "$end")

        # If either conversion failed (indicated by a negative value) or
        # if the start IP is greater than the end IP, return 0.
        if (( start_long < 0 || end_long < 0 || start_long > end_long )); then
            echo "0"
            return
        fi

        # Calculate the number of IP addresses in the range.
        local num_hosts=$(( end_long - start_long + 1 ))
        echo "$num_hosts"
    }

    total_hosts=0  # Global variable to accumulate the total number of hosts.
    local line hosts

    # Process the input file specified by the variable 'checkfile'.
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Remove comments and whitespace.
        line="${line%%#*}"
        line="${line//[[:space:]]/}"
        # Skip empty lines.
        if [[ -z "$line" ]]; then
            continue
        fi

        if [[ "$line" == *"/"* ]]; then
            # CIDR notation.
            hosts=$(calculate_cidr_hosts "$line")
        elif [[ "$line" == *"-"* ]]; then
            # IP range.
            hosts=$(calculate_ip_range_hosts "$line")
        else
            # Single IP.
            hosts=1
        fi
        total_hosts=$(( total_hosts + hosts ))
    done < "$checkfile"
}

# Read-only sanitizer: normalize a targets file into a temporary sanitized file in /tmp.
# - Strips optional metadata prefixes (e.g., "__SRC:...__ ")
# - Removes comments and all whitespace
# - Drops blank lines
# Prints the path to the sanitized temp file on stdout.
sanitize_targets_to_temp_ro() {
	local src="$1"
	if [[ -z "$src" || ! -f "$src" ]]; then
		echo ""; return 1
	fi
	local dst
	dst=$(mktemp /tmp/zeroe_count_hosts.XXXXXX)
	# Use awk to strip metadata prefixes, comments, whitespace; preserve CIDR, ranges, and single IPs.
	awk '
		{
			# If a metadata prefix exists like "__SRC:...__ ", take the content after the last "__ "
			n = split($0, parts, /__ /);
			line = parts[n];
			# Strip comments
			sub(/#.*/, "", line);
			# Remove all whitespace (includes CR, tabs, spaces)
			gsub(/[\t\r\n\v\f ]/, "", line);
			if (length(line) > 0) {
				print line;
			}
		}
	' "$src" > "$dst"
	echo "$dst"
}

function geniplist { 
	ip_to_int() { 
	    # Function to convert dotted-decimal IP to integer
	    local ip="$1"
	    local o1 o2 o3 o4
	    # Extract octets
	    o1="${ip%%.*}"
	    ip="${ip#*.}"
	    o2="${ip%%.*}"
	    ip="${ip#*.}"
	    o3="${ip%%.*}"
	    o4="${ip#*.}"
	    # Convert to integers
	    echo $(( (o1 << 24) + (o2 << 16) + (o3 << 8) + o4 ))
	}
	
	int_to_ip() { 
	    # Function to convert integer IP to dotted-decimal format
	    local ip="$1"
	    local octet1=$(( (ip >> 24) & 255 ))
	    local octet2=$(( (ip >> 16) & 255 ))
	    local octet3=$(( (ip >> 8) & 255 ))
	    local octet4=$(( ip & 255 ))
	    echo "$octet1.$octet2.$octet3.$octet4"
	}
	
	cidr_to_ip_range() { 
	    # Function to convert CIDR to IP range
	    local cidr="$1"
	    local ip cidr_val netmask ip_int network broadcast
	    IFS=/ read -r ip cidr_val <<< "$cidr"
	    ip_int=$(ip_to_int "$ip")
	    netmask=$(( (0xFFFFFFFF << (32 - cidr_val)) & 0xFFFFFFFF ))
	    network=$(( ip_int & netmask ))
	    broadcast=$(( network | ((~netmask) & 0xFFFFFFFF) ))
	    echo "$(int_to_ip "$network")-$(int_to_ip "$broadcast")"
	}
	
	expand_ips() { 
	    # Function to expand IPs from a file that can include single IPs, ranges, and CIDRs.
	    local inputfile="$1"
	    # Declare all variables local to this function.
	    local ip range start end start_int end_int network prefix i ip_addr
	
	    while IFS= read -r ip || [[ -n "$ip" ]]; do
	        # Remove comments and whitespace.
	        ip="${ip%%#*}"
	        ip="${ip//[[:space:]]/}"        # Skip empty lines.
        if [[ -z "$ip" ]]; then
            continue
        fi
        
        if [[ "$ip" == *"/"* ]]; then
            # Handle CIDR notation.
            range=$(cidr_to_ip_range "$ip")
            IFS=- read -r start end <<< "$range"
            start_int=$(ip_to_int "$start")
            end_int=$(ip_to_int "$end")
            # Get the CIDR prefix to determine if broadcast address should be excluded.
            IFS=/ read -r network prefix <<< "$ip"
            if (( prefix < 31 )); then
                # Include network address (.0) but exclude broadcast address (.255)
                end_int=$(( end_int - 1 ))
            fi
            for (( i = start_int; i <= end_int; i++ )); do
                int_to_ip "$i"
            done
		    elif [[ "$ip" == *"-"* ]]; then
	            # Handle IP range.
	            IFS=- read -r start end <<< "$ip"
	            start_int=$(ip_to_int "$start")
	            end_int=$(ip_to_int "$end")
	            for (( i = start_int; i <= end_int; i++ )); do
	                ip_addr=$(int_to_ip "$i")
	                echo "$ip_addr"
	            done
		    else
		        # Only emit if single IPv4 matches pattern; silently skip otherwise (mixed mode warning already shown upstream)
		        if [[ $ip =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
		            echo "$ip"
		        fi
	        fi
	    done < "$inputfile"
	}
	# Main function to generate a sorted, unique IP list.
	# Validate file contains at least one IP/CIDR/range pattern; otherwise emit concise error similar to -x handling
	if ! grep -Eq '^[0-9]+(\.[0-9]+){3}(/([0-9]|[12][0-9]|3[0-2]))?$|^[0-9]+(\.[0-9]+){3}-[0-9]+(\.[0-9]+){3}$' "$checkfile"; then
		echo -e "\e[31m [X] Error: $checkfile contains no valid IP addresses, ranges, or CIDRs \e[0m" >&2
		exit 1
	fi
	expand_ips "$checkfile" | sort -n -t . -k 1,1 -k 2,2 -k 3,3 -k 4,4 | uniq
}

function alivesandportscheck { #checks if alives and openPorts lists are populated
	if grep -q "\S" "$filepath/$typevar-aliveHosts.txt" && grep -q "\S" "$filepath/$typevar-openPorts.txt"; then
		if [[ "$only_flag" = true && "$stage_cont" != true ]]; then
			echo -e "\e[32m [+] Created lists of alive hosts and open ports \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		else
			status_msg="[+] Discovery scans completed -- $(date)"
			echo -e "\e[32m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			ntfy "$status_msg"
		fi
	elif ! grep -q "\S" "$filepath/$typevar-aliveHosts.txt" && grep -q "\S" "$filepath/$typevar-openPorts.txt"; then
		status_msg="[!] No alive hosts detected, check targets or inquire about scan defenses or other interference -- Exiting Zero-E..."
		echo -e "\e[33m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		ntfy "$status_msg"
		z0ecleanup
		exit 1
	elif grep -q "\S" "$filepath/$typevar-aliveHosts.txt" && ! grep -q "\S" "$filepath/$typevar-openPorts.txt"; then
		status_msg="[!] No open ports detected, check targets or inquire about scan defenses or other interference -- Exiting Zero-E..."
		echo -e "\e[33m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		ntfy "$status_msg"
		z0ecleanup
		exit 1
	else
		status_msg="[!] No alive hosts or open ports detected, check targets or inquire about scan defenses or other interference -- Exiting Zero-E..."
		echo -e "\e[33m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		ntfy "$status_msg"
		z0ecleanup
		exit 1
	fi
}

# Count total number of ports from an openPorts-style file (e.g., lines like "80/TCP" or "1000-1005/UDP")
function count_ports_from_file {
	local ports_file="$1"
	local total_ports=0
	local tcp_ports=0
	local udp_ports=0
	local line portspec proto start end count
	while IFS= read -r line || [[ -n "$line" ]]; do
		# Trim whitespace and skip empty/comment lines
		line="${line%%#*}"
		line="${line//[[:space:]]/}"
		[[ -z "$line" ]] && continue

		# Expect format: "N/PROTO" or "A-B/PROTO"
		portspec="${line%%/*}"
		proto="${line##*/}"
		proto="${proto^^}"

		count=0
		if [[ "$portspec" =~ ^[0-9]+$ ]]; then
			count=1
		elif [[ "$portspec" =~ ^([0-9]+)-([0-9]+)$ ]]; then
			start="${BASH_REMATCH[1]}"
			end="${BASH_REMATCH[2]}"
			if (( end >= start )); then
				count=$(( end - start + 1 ))
			fi
		fi

		(( total_ports += count ))
		if [[ "$proto" == "TCP" ]]; then
			(( tcp_ports += count ))
		elif [[ "$proto" == "UDP" ]]; then
			(( udp_ports += count ))
		fi
	done < "$ports_file"

	echo "$total_ports $tcp_ports $udp_ports"
}

function removefirewallrule { #removes the firewall rule used in int methodology
	firewallset=false
	oscheck=$(uname)
	if [ "$oscheck" = "Darwin" ]; then #For st00pid Macs
		cp "/etc/pf.conf" "$filepath/logs/pf.conf.bak-postscript"
		sudo sed -i "/block drop in proto tcp from any to any port 55555/d" /etc/pf.conf
		pfctl -f /etc/pf.conf >> $filepath/logs/mac-pfctl.log 2>&1
		if [ "$macpf" = "Disabled" ]; then
			pfctl -d >> $filepath/logs/mac-pfctl.log 2>&1 #disable pfctl
		fi
	else #For Linux	
		sudo iptables -D INPUT -p tcp --dport 55555 -j DROP 2>/dev/null
	fi
	echo -e "\e[33m [!] Firewall rule removed \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
}

function setfirewallrule { #sets the firewall rule used in int methodology
	firewallset=true
	oscheck=$(uname)
	if [ "$oscheck" = "Darwin" ]; then #For st00pid Macs
		macpf=$(pfctl -s info | grep -o "Status: .*" | cut -d' ' -f2) #gets pfctl status
		if [ "$macpf" = "Disabled" ]; then
			pfctl -e >> $filepath/logs/mac-pfctl.log 2>&1 #enable pfctl
		fi
		if pfctl -sr 2>> $filepath/logs/mac-pfctl.log | grep -q "block drop in proto tcp from any to any port 55555"; then #check if rule exists
    		echo -e "\e[33m [!] Firewall rule on port 55555 to prevent RST packets already exists -- skipping rule creation \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		else
			cp "/etc/pf.conf" "$filepath/logs/pf.conf.bak-prescript"
    		echo "block drop in proto tcp from any to any port 55555" | sudo tee -a /etc/pf.conf >> $filepath/logs/mac-pfctl.log #creates the rule
    		sudo pfctl -f /etc/pf.conf >> $filepath/logs/mac-pfctl.log 2>&1 #loads the pfctl configuration
			echo -e "\e[33m [!] Firewall rule created on port 55555 to prevent RST packet interference \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		fi
	else #For Linux
		if sudo iptables -C INPUT -p tcp --dport 55555 -j DROP 2> /dev/null; then
			echo -e "\e[33m [!] Firewall rule on port 55555 to prevent RST packets already exists -- skipping rule creation \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		else	
			sudo iptables -A INPUT -p tcp --dport 55555 -j DROP
			echo -e "\e[33m [!] Firewall rule created on port 55555 to prevent RST packet interference \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		fi
	fi
}

function ntfy { # enables ntfy functionality
    if [ "$ntfy_flag" = true ]; then
        
		if [ "$z0e_started" != true ]; then 
			# Remove any spaces from the provided value
	        ntfy_arg=$(echo "$ntfy_arg" | tr -d '[:space:]')
        	# Check if the value contains a comma
        	if [[ "$ntfy_arg" == *,* ]]; then
        	    ntfy_pri=$(echo "$ntfy_arg" | cut -d',' -f1)
        	    ntfy_url=$(echo "$ntfy_arg" | cut -d',' -f2-)
        	    # Validate that the priority is a number between 1 and 5
        	    if ! [[ "$ntfy_pri" =~ ^[1-5]$ ]]; then
        	        echo -e "\e[31m [X] Error: ntfy priority must be a number between 1 and 5 \e[0m" >&2
        	        exit 1
        	    fi
        	else
        	    # Default priority to 3 if not provided
        	    ntfy_pri=3
        	    ntfy_url="$ntfy_arg"
        	fi
        	# Validate that the URL starts with http:// or https://
        	if ! [[ "$ntfy_url" =~ ^https?:// ]]; then
        	    echo -e "\e[31m [X] Error: ntfy URL must start with http:// or https:// \e[0m" >&2
        	    exit 1
        	fi
		fi

		if [ "$z0e_started" == true ]; then
        	# Send the POST request to the ntfy server
			local msg="$1"
        	curl -H "X-Priority: $ntfy_pri" -d "$msg" "$ntfy_url" >> "$filepath/logs/$typevar-ntfy.log" 2>&1
		fi
    fi
}

function logconfig { # Logs the configuration of the scan
    local file="$1"
    if [[ ! -f "$file" ]]; then
        echo "Error: File '$file' not found." >&2
        return 1
    fi

    # Read the entire file content into a variable.
    local config_str
    config_str=$(< "$file")

    local udp_line=""
    # Determine UDP configuration:
    if grep -q 'U_opt="true"' "$file"; then
        udp_line="udp=enabled"
    elif grep -q 'u_opt="true"' "$file"; then
        udp_line="udp=disabled"
    fi

    # Variables for specific keys in desired order.
	local session_line=""
	local output_dir=""
	local targets_path=""           # absolute path of user-provided targets file (if determinable)
	local targets_z0eConverted=""   # canonical expanded single-IP list file path
	local targets_z0eConverted_hash="" # sha256 of canonical file (if file exists)
	local total_targets=""
	local excludes_file=""
	local excludes_path=""          # absolute path of user-provided excludes file (if any)
	local other_lines=()

    # Add session name if session is active
    if [[ "$session_flag" = true && -n "$session" ]]; then
        session_line="sessionName=\"$session\""
    fi

    # Process each token (assumes tokens are whitespace-separated).
    for token in $config_str; do
        local key=${token%%=*}
        local value=${token#*=}
        # Remove surrounding quotes.
        value=${value%\"}
        value=${value#\"}

		case "$key" in
			# These keys are removed.
			e_opt|i_opt|typevar|stage_cont|only_flag|U_opt|u_opt)
				;;
			filepath)
				output_dir="outputDirectory=\"$(realpath "$value")\""
				;;
			ips)
				# 'ips' points to canonical expanded targets file produced by Zero-E
				if [ -n "$value" ] && [ -e "$value" ]; then
					local canon_path="$(realpath "$value")"
					targets_z0eConverted="targets_z0eConverted=\"$canon_path\""
					if command -v sha256sum >/dev/null 2>&1; then
						local hash_val="$(sha256sum "$canon_path" 2>/dev/null | awk '{print $1}')"
						[ -n "$hash_val" ] && targets_z0eConverted_hash="targets_z0eConverted_hash=\"$hash_val\""
					fi
				fi
				;;
			total_hosts)
				total_targets="totalTargets=\"$value\""
				;;
			nostrikes)
				if [ "$value" = "/var/lib/zeroe/nullexcludes.z0e" ]; then
					excludes_file="excludes=\"none\""
				else
					if [ -n "$value" ] && [ -e "$value" ]; then
						local abs_exc="$(realpath "$value")"
						excludes_file="excludes=\"$abs_exc\""
						excludes_path="excludes_path=\"$abs_exc\""
					else
						excludes_file="excludes=\"$value\""
					fi
				fi
				;;
			*)
				other_lines+=("$key=\"$value\"")
				;;
		esac
    done

	# Determine user-provided targets file absolute path (single file only)
	for entry in "${other_lines[@]}"; do
		case "$entry" in
			targets_userInput=\"*\")
				local raw_val=${entry#targets_userInput=\"}
				raw_val=${raw_val%\"}
				if [[ "$raw_val" != *","* ]] && [ -f "$raw_val" ]; then
					local abs_in="$(realpath "$raw_val" 2>/dev/null)"
					[ -n "$abs_in" ] && targets_path="targets_path=\"$abs_in\""
				fi
				break
				;;
		esac
	done

    # Output in the specified order:
   	# 1. Session name (if active)
    # 2. Output directory
	# 3. targets_path (absolute path of user-provided file, if determinable)
	# 4. targets_z0eConverted (canonical working targets file)
	# 5. targets_z0eConverted_hash (sha256 of canonical)
	# 6. Total targets
	# 7. Excludes file
	# 8. excludes_path (absolute excludes file path, if any)
	# 9. Any other key-value pairs
	# 10. UDP status (last)
    if [ -n "$session_line" ]; then
        echo "$session_line"
    fi
    if [ -n "$output_dir" ]; then
        echo "$output_dir"
    fi
	if [ -n "$targets_raw" ]; then
		echo "$targets_raw"
	fi
	if [ -n "$targets_path" ]; then
		echo "$targets_path"
	fi
	if [ -n "$targets_z0eConverted" ]; then
		echo "$targets_z0eConverted"
	fi
	if [ -n "$targets_z0eConverted_hash" ]; then
		echo "$targets_z0eConverted_hash"
	fi
	if [ -n "$excludes_file" ]; then
		echo "$excludes_file"
	fi
	if [ -n "$excludes_path" ]; then
		echo "$excludes_path"
	fi
    for line in "${other_lines[@]}"; do
        echo "$line"
    done
    if [ -n "$udp_line" ]; then
        echo "$udp_line"
    fi
}

function sessioninit { # Initializes sessions
	if [ "$session_flag" = true ]; then
		session_path="/var/lib/zeroe/sessions/$session"

		if [[ -z "$S_opt" && -d "$session_path" ]]; then # If -S is provided and the session exists, skip prompts and just resume
			echo "[#] Resuming session '$session'"
			return
		elif [ -d "$session_path" ]; then
			echo -e "[?] Session '$session' already exists -- Overwrite? <y/n>: "
			echo -e "    If trying to resume the session, exit and also provide the '-S' option" 
			while true; do
				read -e -p " [>] " response
    			if [ "$response" == "y" ]; then
    			    rm -rf "$session_path"
    			    mkdir -p "$session_path"  # Ensure directory is recreated
					echo "     Overwriting session '$session'"
					break
				elif [ "$response" == "n" ]; then
					while true; do
						echo -e "[?] Enter a new session name: "
						read -e -p " [>] " session
						session_path="/var/lib/zeroe/sessions/$session"
						if [ -d "$session_path" ]; then
							echo -e "\e[31m [X] Error: You opted to not overwrite, but Session '$session' already exists \e[0m" >&2
						else
							echo "     Creating new session '$session'"
							mkdir -p "$session_path" 
							break
						fi
					done
					break
    			else
    			    echo "     Invalid response -- exiting Zero-E"
					exit 1
    			fi
			done
		else 
			echo "     Creating new session '$session'"
			mkdir -p "$session_path"  # Ensure session directory exists
		fi
	fi
}

list_sessions() { # List available sessions and basic metadata
	local root="/var/lib/zeroe/sessions"
	if [ ! -d "$root" ] || [ -z "$(ls -A "$root" 2>/dev/null)" ]; then
		echo "No sessions found under $root"
		return 0
	fi
	echo "Available sessions under $root:"
	for d in "$root"/*; do
		[ -d "$d" ] || continue
		local name stage mtime stage_val
		name="$(basename "$d")"
		stage="(no saved stage)"
		if [ -f "$d/stage.z0e" ]; then
			stage="$(cat "$d/stage.z0e" 2>/dev/null)"
		fi
		if stat --version >/dev/null 2>&1; then
			mtime=$(stat -c '%y' "$d" 2>/dev/null | cut -d'.' -f1)
		elif stat -f '%Sm' -t '%Y-%m-%d %H:%M:%S' "$d" >/dev/null 2>&1; then
			mtime=$(stat -f '%Sm' -t '%Y-%m-%d %H:%M:%S' "$d" 2>/dev/null)
		else
			mtime=""
		fi
		stage_val="$stage"
		if [ "$stage_val" = "(no saved stage)" ]; then
			stage_val="no saved stage"
		fi
		if [ -n "$mtime" ]; then
			echo " - $name -- last update: $mtime -- stage: ${stage_val}"
		else
			echo " - $name -- stage: ${stage_val}"
		fi
	done
}

#Banner
echo "$banner" >&2

updatecheck

#--Switches
#auxiliary options
help_flag=false
version_flag=false
geniplistopt=false
geniplist_file=""
count_hosts_flag=false
count_ports_flag=false
count_hosts_arg=""
count_ports_path=""
checkfile=""
defaults=false
only_flag=false
ngineer_mode=false
listwinhosts_flag=false
parseports_flag=false
listiphostnames_flag=false
ntfy_flag=false
session=""
session_flag=false
session_list_flag=false
# Resolve-only option (DNS -> IPs)
dns_ip_flag=false
dns_ip_arg=""

while [[ $# -gt 0 ]]; do
	case "$1" in
		--help)
            help_flag=true
            shift # Remove --help from processing
            ;;
		--version)
            version_flag=true
            shift # Remove --version from processing
            ;;
        --geniplist)
            shift  # remove --geniplist from $@
            if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
                arg="$1"
                shift  # remove the file/IP argument
                # 1) Single existing, non-empty file with no commas or IP pattern => use it directly
                if [ -f "$arg" ] && [ -s "$arg" ] \
                   && ! [[ "$arg" =~ [0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ ]] \
                   && [[ "$arg" != *","* ]]
                then
                    geniplistopt=true
                    geniplist_file="$arg"
                    # Optionally validate:
                    checkfile="$geniplist_file"
                    checkinvalidips
                # 2) If the arg has commas or IP pattern => two-file approach
                elif { ! [ -f "$arg" ] && [[ "$arg" =~ [0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ ]]; } \
                      || [[ "$arg" == *","* ]]
                then
                    geniplistopt=true
                    # Create metadata + raw files
                    metadata_file=$(mktemp /tmp/geniplist_ips.metadata.XXXXXX)
                    raw_file=$(mktemp /tmp/geniplist_ips.raw.XXXXXX)
                    IFS=',' read -ra token_array <<< "$arg"
                    anyerrors=false
                    for token in "${token_array[@]}"; do
						trimmed="$(trim_ws "$token")"
                        if [ -f "$trimmed" ]; then
                            # If it's a file, ensure non-empty
                            if [ ! -s "$trimmed" ]; then
                                echo -e "\e[31m [X] Error: '$trimmed' is empty \e[0m" >&2
                                anyerrors=true
                                break
                            fi
                            # Merge lines with a prefix in metadata_file
							while IFS= read -r line; do
                                echo "__SRC:FILE:${trimmed}__ $line" >> "$metadata_file"
                                echo "$line" >> "$raw_file"
                            done < "$trimmed"
                        else
                            # It's an IP / range / CIDR
                            echo "__SRC:INPUT__ $trimmed" >> "$metadata_file"
                            echo "$trimmed" >> "$raw_file"
                        fi
                    done
                    if $anyerrors; then
                        exit 1
                    fi
                    # Validate the metadata file
                    checkfile="$metadata_file"
                    checkinvalidips
                    if [[ "$allvalid" -eq 1 ]]; then
                        geniplist_file="$raw_file"
                    else
                        exit 1
                    fi
                else
                    echo -e "\e[31m [X] Error: --geniplist requires an existing file and/or a comma-separated IP list \e[0m" >&2
                    exit 1
                fi
            else
                echo -e "\e[31m [X] Error: --geniplist requires a file and/or IP list argument \e[0m" >&2
                exit 1
            fi
            ;;
		--count-hosts)
            shift  # Remove --count
            if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
                arg="$1"
				count_hosts_arg="$1"
                shift

				# 1) If argument includes commas => treat as list of tokens (files/IPs/DNS)
				if [[ "$arg" == *","* ]]; then
					count_hosts_flag=true
					metadata_file=$(mktemp /tmp/count_ips.metadata.XXXXXX)
					raw_file=$(mktemp /tmp/count_ips.raw.XXXXXX)

					IFS=',' read -ra ip_array <<< "$arg"
					anyerrors=false
					for token in "${ip_array[@]}"; do
						trimmed="$(trim_ws "$token")"
						if [ -f "$trimmed" ]; then
							if [ ! -s "$trimmed" ]; then
								echo -e "\e[31m [X] Error: '$trimmed' is empty \e[0m" >&2
								anyerrors=true
								break
							fi
							while IFS= read -r line; do
								echo "__SRC:FILE:${trimmed}__ $line" >> "$metadata_file"
								echo "$line" >> "$raw_file"
							done < "$trimmed"
						else
							echo "__SRC:INPUT__ $trimmed" >> "$metadata_file"
							echo "$trimmed" >> "$raw_file"
						fi
					done
					if $anyerrors; then
						exit 1
					fi
					# Resolve any DNS names in-place for metadata/raw, then validate and count from raw
					if ! resolve_dns_in_metadata "$metadata_file" "$raw_file"; then
						exit 1
					fi
					checkfile="$raw_file"
					checkinvalidips
					if [[ "$allvalid" -ne 1 ]]; then
						exit 1
					fi

				# 2) Single existing non-empty file => resolve any DNS inside, then validate
				elif [ -f "$arg" ] && [ -s "$arg" ]; then
					count_hosts_flag=true
					resolve_dns_in_file "$arg"
					resolved_file="${RESOLVED_DNS_FILE:-$arg}"
					checkfile="$resolved_file"
					checkinvalidips

				# 3) Single hostname token (not a file, not commas)
				elif looks_like_hostname "$arg"; then
					count_hosts_flag=true
					tmp_host_file=$(mktemp /tmp/z0e_single_host.XXXXXX)
					echo "$arg" > "$tmp_host_file"
					if resolve_dns_in_file "$tmp_host_file"; then
						resolved_file="${RESOLVED_DNS_FILE:-$tmp_host_file}"
						checkfile="$resolved_file"
						checkinvalidips
					else
						exit 1
					fi

				# 4) Single inline IP/range/CIDR => treat like list with one INPUT token
				elif [[ "$arg" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(/([0-9]|[12][0-9]|3[0-2]))?$ ]] || [[ "$arg" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+-[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
					count_hosts_flag=true
					metadata_file=$(mktemp /tmp/count_ips.metadata.XXXXXX)
					raw_file=$(mktemp /tmp/count_ips.raw.XXXXXX)
					echo "__SRC:INPUT__ $arg" >> "$metadata_file"
					echo "$arg" >> "$raw_file"
					# No DNS to resolve; validate directly
					checkfile="$raw_file"
					checkinvalidips
					if [[ "$allvalid" -ne 1 ]]; then
						exit 1
					fi

				else
					echo -e "\e[31m [X] Error: --count-hosts requires an existing file or a comma-separated list of IPs/DNS (or a single IP/range/CIDR/hostname) \e[0m" >&2
					exit 1
				fi
            else
				echo -e "\e[31m [X] Error: --count-hosts requires a file and/or IPs/DNS argument \e[0m" >&2
                exit 1
            fi
            ;;
		--count-ports)
			shift  # Remove --count-ports
			if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
				count_ports_path="$1"
				shift
				if [ ! -f "$count_ports_path" ] || [ ! -s "$count_ports_path" ]; then
					echo -e "\e[31m [X] Error: --count-ports requires an existing, non-empty openPorts file \e[0m" >&2
					exit 1
				fi
				count_ports_flag=true
			else
				echo -e "\e[31m [X] Error: --count-ports requires the filepath to an openPorts file \e[0m" >&2
				exit 1
			fi
			;;
		--dns-ip)
			shift  # Remove --dns-ip
			if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
				dns_ip_flag=true
				dns_ip_arg="$1"
				shift
			else
				echo -e "\e[31m [X] Error: --dns-ip requires a file and/or comma-separated list of IPs/DNS (hostnames will be resolved; IPs are ignored) \e[0m" >&2
				exit 1
			fi
			;;
		--ntfy)
			shift # Remove --ntfy from processing
			if [[ $# -gt 0 && ! $1 =~ ^- ]]; then
				ntfy_flag=true
				ntfy_arg="$1"
				shift # Remove the ntfy argument from processing
			else
				echo -e "\e[31m [X] Error: --ntfy requires an argument of [an optional priority of 1-5,]<the server/topic url starting with http[s]://> \e[0m" >&2
				exit 1
			fi
			;;
		--session)
			shift # Remove --session from processing
			if [[ $# -gt 0 && ! $1 =~ ^- ]]; then
				session="$1"
				session_flag=true
				shift # Remove the argument from processing
			else
				echo -e "\e[31m [X] Error: --session requires the name of a new or existing session \e[0m" >&2
				exit 1
			fi
			;;
		--session-list)
			session_list_flag=true
			shift
			break
			;;
		--rate)
			shift # Remove --rate from processing
			if [[ $# -gt 0 && ! $1 =~ ^- ]]; then
				if [[ "$1" =~ ^[0-9]+$ ]]; then
					masscan_rate_override="$1"
					shift # Remove the rate value from processing
				else
					echo -e "\e[31m [X] Error: --rate requires a positive integer value (packets per second) \e[0m" >&2
					exit 1
				fi
			else
				echo -e "\e[31m [X] Error: --rate requires a value (packets per second) \e[0m" >&2
				exit 1
			fi
			;;
		--defaults)
			defaults=true
			shift #Removes --defaults from processing
			;;
		--only)
			only_flag=true
			shift
			;;
		--ngineer)
			ngineer_mode=true
			shift
			;;
		--listwinhosts)
            listwinhosts_flag=true
            shift
            break
            ;;
		--parseports)
			parseports_flag=true
			shift #Remove --parseports from processing
			break #Exit the loop to preserve remaining arguments
			;;
		--listiphostnames)
            listiphostnames_flag=true
            shift
            break
            ;;
        *)
			remaining_args+=("$1") #Stores other opts/args for processing in post-sudo functions
			shift
            ;;
	esac
done
if [ "$help_flag" = true ]; then
    echo ''
	echo "USAGE: sudo $(basename $0) [options]"
	echo "While there are options, providing them is not necessary with Zero-E"
	echo "z0e will prompt you for required configuration settings if not provided"
	echo ''
	echo "For advanced usage:"
	echo "sudo $(basename $0) [-e | -i] [-o <output_directory>] [-t <targets_file(s) and/or IP(s)>] [-x [excludes_file and/or IP(s)]]"
	echo "                     [-U | -u] [-S [stage] | -s]"
	echo "                     [--defaults] [--ngineer] [--only] [--rate <pps>]"
	echo "                     [--count-hosts <filename(s) and/or IPs/DNS]> [--count-ports <openPortsFile>] [--geniplist <filename(s) and/or IPs>]"
	echo "                     [--dns-ip <filename(s) and/or IPs/DNS>]"
	echo "                     [--listwinhosts <StandardNmapFile> [OutputFile]]"
	echo "                     [--parseports <GrepableNmapFile> <Comma,Separated,Ports> [OutputFileName]]"
	echo "                     [--listiphostname <StandardNmapFile> [OutputFile]]"
	echo "                     [--ntfy [priority,]<server/topic_url>] [--session <session_name>] [--session-list]"
	echo "                     [--help] [--version]"
	echo ''	
	echo "PRIMARY OPTIONS (z0e will prompt for these if not provided):"
	echo "  -e                      Run external assessment scans (cannot be used with -i)"
	echo "  -i                      Run internal assessment scans (cannot be used with -e)"
	echo "  -o <dir>                Set output directory for generated files"
	echo "  -t <file(s) and/or IPs/DNS> Provide targets (IPs, ranges, CIDRs, DNS names) and/or files in a comma-separated list"
	echo "                               Examples: file.txt,1.1.1.1,corp.example.com,10.0.0.0/24"
	echo "                               DNS names are auto-resolved to IPv4 via getent"
	echo "  -x [file(s) and/or IPs] Provide target IP addresses and/or files to exclude in a comma-separated list (file.txt,1.1.1.1)"
	echo "                            Supports single IPs, ranges, or CIDR notation -- Omit argument to disable exclusion prompt"
	echo "  -U                      Enable UDP scans (cannot be used with -u)"
	echo "  -u                      Disable UDP scans (cannot be used with -U)"
	echo "  -S [stage]              If no stage provided, resume from saved stage (cannot be used with -s)"
	echo "                            If stage provided, skip to the specified stage"
	echo "                            Available stages:"
	echo "                              - discovery-hosts (TCP-only)"
	echo "                              - discovery-ports (TCP-only)"
	echo "                              - discovery-udp"
	echo "                              - discovery-lists"
	echo "                              - services-tcp"
	echo "                              - services-udp"
	echo "  -s                      Start from the beginning (disables stage resuming but still saves stages for later resumption)"
	echo ''
	echo "AUXILIARY OPTIONS (Enable additional functionality):"
	echo "  --defaults                   Run z0e with default settings (overridden by explicitly provided options)"
	echo "                                 Default settings:"
	echo "                                   - Stage (-S/-s): Starts at initial alives scan"
	echo "                                   - Targets file (-t): ./targets.txt"
	echo "                                   - Output directory (-o): ./z0e-output"
	echo "                                   - Excluded targets (-x): None"
	echo "                                   - UDP scans (-U/-u): Enabled"
	echo "  --ngineer                    Enable entry of custom command options"
	echo "  --only                       Run only UDP scans (if enabled) and/or specified stage (does not apply to other options)"
	echo "  --rate <pps>                 Override masscan packet rate (packets per second) for discovery scans and when resuming"
	echo "  --count-hosts <file(s) and/or IPs/DNS>"
	echo "                               Count total IP addresses in the provided comma-separated file(s), IPs/ranges/CIDRs, and/or DNS names (auto-resolves) (does not require sudo)"
	echo "  --count-ports <openPortsFile>"
	echo "                               Count total number of ports in an openPorts file (expands ranges like 1000-1005)"
	echo "  --dns-ip <file(s) and/or IPs/DNS>"
	echo "                               Resolve DNS names to IPv4 addresses and print them (IPs/ranges/CIDRs provided are ignored)"
	echo "                                 Accepts a single file, a single token, or a comma-separated list of files/tokens"
	echo "  --geniplist <file(s) and/or IPs>"
	echo "                               Generate a list of single IP addresses from the provided comma-separated file(s) and/or IPs"
	echo "                                 (does not require sudo)"
	echo "  --listwinhosts <NmapFile> [OutputFile]"
	echo "                               Parse a standard Nmap file (.nmap) to list IP addresses of Windows hosts (does not require sudo)"
	echo "  --parseports <GrepableNmapFile> <Comma,Separated,Ports> [OutputFileName]"
	echo "                               Parse a grepable Nmap file (.gnmap) for hosts with specified open ports"
	echo "                                 and output results in a readable format (does not require sudo)"
	echo "  --listiphostnames <NmapFile> [OutputFile]"
	echo "                               Parse a standard Nmap file (.nmap) to list IP address and hostname pairs"
	echo "                                 (does not require sudo)"
	echo "  --ntfy [priority,]<server/topic_url>"
	echo "                               Enable ntfy notifications (priority 1-5 optional, followed by server/topic URL)"
	echo "  --session <name>             Enable session functionality (provide a new or existing session name)"
	echo "                                 To resume a session, provide the session name with the -S option"
	echo "  --session-list               List available sessions under /var/lib/zeroe/sessions (does not require sudo)"
	echo "  --help                       Display this help message"
	echo "  --version                    Display the version of Zero-E"
	exit 0
#Check for --version option (for troubleshooting purposes)
elif [ "$version_flag" = true ]; then
	echo $version
	exit 0
#Check for --count-hosts option
elif [ "$count_hosts_flag" == true ]; then
	mactools=("dos2unix")
	linuxtools=("dos2unix")
	checktools #Check if required tools are installed
	echo "Counting total number of hosts..."
	# Read-only path: never mutate the input file. Sanitize to a temp file and count from that.
	tmp_checkfile=$(sanitize_targets_to_temp_ro "$count_hosts_arg") || { echo -e "\e[31m [X] Error: cannot read $count_hosts_arg\e[0m" >&2; exit 1; }
	checkfile="$tmp_checkfile"
	totaltargets
	echo "$total_hosts -- total number of host IP addresses in $count_hosts_arg"
	rm -f "$tmp_checkfile" 2>/dev/null || true
	exit 0
#Check for --count-ports option
elif [ "$count_ports_flag" == true ]; then
	mactools=("dos2unix")
	linuxtools=("dos2unix")
	checktools #Check if required tools are installed
	echo "Counting total number of ports..."
	read -r port_total tcp_total udp_total < <(count_ports_from_file "$count_ports_path")
	echo "$port_total -- total ports (TCP: $tcp_total, UDP: $udp_total) in $count_ports_path"
	exit 0
# Check for --dns-ip option
elif [ "$dns_ip_flag" == true ]; then
	mactools=("dos2unix")
	linuxtools=("dos2unix")
	checktools #Check if required tools are installed

	arg="$dns_ip_arg"
	# Build a metadata/raw pair that includes ONLY hostname tokens; IPs/ranges/CIDRs will be ignored.
	metadata_file=$(mktemp /tmp/dnsip_ips.metadata.XXXXXX)
	raw_file=$(mktemp /tmp/dnsip_ips.raw.XXXXXX)
	anyerrors=false
	# Normalize processing into token list: file, single token, or comma-separated
	if [[ "$arg" == *","* ]]; then
		IFS=',' read -ra token_array <<< "$arg"
	else
		token_array=("$arg")
	fi
	for token in "${token_array[@]}"; do
		trimmed="$(trim_ws "$token")"
		if [ -f "$trimmed" ]; then
			if [ ! -s "$trimmed" ]; then
				echo -e "\e[31m [X] Error: '$trimmed' is empty \e[0m" >&2
				anyerrors=true
				break
			fi
			# From file: append only lines that look like hostnames
			while IFS= read -r line; do
				val="$(trim_ws "$line")"
				[[ -z "$val" ]] && continue
				if looks_like_hostname "$val"; then
					echo "__SRC:FILE:${trimmed}__ $val" >> "$metadata_file"
					echo "$val" >> "$raw_file"
				fi
			done < "$trimmed"
		else
			# Single token: include only if it looks like a hostname
			if looks_like_hostname "$trimmed"; then
				echo "__SRC:INPUT__ $trimmed" >> "$metadata_file"
				echo "$trimmed" >> "$raw_file"
			fi
		fi
	done
	if $anyerrors; then
		exit 1
	fi
	# If no hostnames gathered, emit an error (mirror -x style) and exit non-zero
	if [ ! -s "$raw_file" ]; then
		if [ -f "$arg" ]; then
			echo -e "\e[31m [X] Error: '$arg' contains no valid hostnames (must contain a dot and only A-Z 0-9 - .) \e[0m" >&2
		else
			echo -e "\e[31m [X] Error: no valid hostnames found in provided input \e[0m" >&2
		fi
		rm -f "$metadata_file" "$raw_file" 2>/dev/null || true
		exit 1
	fi
	# Resolve hostnames in-place; ignore validation since we only want resolved IPs
	if ! resolve_dns_in_metadata "$metadata_file" "$raw_file"; then
		exit 1
	fi
	# After resolution, $raw_file should be replaced with the resolved IPs content by resolve_dns_in_metadata
	# But our resolver writes a new raw and moves it into place; read the raw_file now
	# Output unique IPv4s to stdout
	resolved_count=$(grep -E '^[0-9]+(\.[0-9]+){3}$' "$raw_file" | sort -u | tee /tmp/dns_ip_resolved.$$ | wc -l | tr -d ' ')
	if [ "$resolved_count" -eq 0 ]; then
		if [ -f "$arg" ]; then
			echo -e "\e[31m [X] Error: '$arg' hostnames did not resolve to any IPv4 addresses \e[0m" >&2
		else
			echo -e "\e[31m [X] Error: provided hostname(s) did not resolve to any IPv4 addresses \e[0m" >&2
		fi
		rm -f /tmp/dns_ip_resolved.$$ 2>/dev/null || true
		exit 1
	fi
	cat /tmp/dns_ip_resolved.$$; rm -f /tmp/dns_ip_resolved.$$ 2>/dev/null || true
	DNS_MAP_DISABLE=false
	exit 0
#Check for --geniplist option
elif [ "$geniplistopt" == true ]; then
	mactools=("dos2unix")
	linuxtools=("dos2unix")
	checktools #Check if required tools are installed
	checkfile="$geniplist_file"
	# Create a temporary file to buffer geniplist's output
    temp_output=$(mktemp)
	geniplist > "$temp_output" &
	GEN_PID=$!
	status_msg="Generating list of single IP addresses..."
	use_stderr=true
	statusgeniplist "$GEN_PID"
	wait "$GEN_PID"
	# output the buffered IP addresses to stdout
    cat "$temp_output"
    rm "$temp_output"
	exit 0
elif [ "$listwinhosts_flag" = true ]; then
	genwindowshostlist "$1" "$2"
	exit 0
#Check for --parseports option
elif [ "$parseports_flag" = true ]; then
	parsegnmap "$1" "$2" "$3"
	exit 0
elif [ "$listiphostnames_flag" = true ]; then
    listiptohostname "$1" "$2"
    exit 0
elif [ "$session_list_flag" = true ]; then
	list_sessions
	exit 0
fi

#Check sudo
if [[ "$EUID" -ne 0 ]]; then # && [[ "$arg" != "--help" || "$arg" != "--version" || "$arg" != "--count-hosts" || "$arg" != "--count-ports" || "$arg" != "--geniplist" || "$arg" != "--parseports" ]]; then
   	echo -e "\e[31m [X] Error: $(basename $0) requires sudo \e[0m" >&2
   	exit 1
fi

#Check if post-sudo required tools are installed
if [ "$ntfy_flag" = true ]; then
	mactools=("curl" "nmap" "masscan" "pfctl" "dos2unix" "realpath")
	linuxtools=("curl" "nmap" "masscan" "iptables" "dos2unix" "realpath")
	checktools
else
	mactools=("nmap" "masscan" "pfctl" "dos2unix" "realpath")
	linuxtools=("nmap" "masscan" "iptables" "dos2unix" "realpath")
	checktools
fi

#primary options
e_opt=false
i_opt=false
o_opt=""
t_opt=""
x_opt=""
TARGETS_OPT=false
EXCLUDES_OPT=false
HOSTCOUNT_DONE=false
TARGETS_ALREADY_RAN=false
EXCLUDES_ALREADY_RAN=false
U_opt=false
u_opt=false
s_opt=false
S_opt="disabled"
#Loop to parse options using getopts
while getopts ':eio:t:x:UusS:' opt "${remaining_args[@]}" 2>/dev/null; do
	case "${opt}" in
    	e) 
    		e_opt=true 
    		;;
    	i) 
    		i_opt=true 
    		;;
    	o) 
			if [[ "$OPTARG" == -* ]]; then
                echo -e "\e[31m [X] Error: -o requires a directory name or path \e[0m" >&2
                exit 1
            elif [ -f "$OPTARG" ]; then
				echo -e "\e[31m [X] Error: File exists with the same name \e[0m" >&2
				exit 1
			elif [[ "$OPTARG" == *" "* ]]; then
				echo -e "\e[31m [X] Error: To proactively avoid errors, whitespace is not allowed in directory names \e[0m" >&2
				exit 1
			elif [[ "$OPTARG" == "/dev/null" ]]; then
				echo -e "\e[31m [X] Error: /dev/null cannot be used as an output directory \e[0m" >&2
        		exit 1
			else
				o_opt="$OPTARG"
			fi
			;;
    	t)
			targets_userInput="$OPTARG"
		    ip_list="$OPTARG"
		    # If OPTARG is a single file with no IP pattern, just use it
				if [ -f "$OPTARG" ] && [ -s "$OPTARG" ] \
					&& ! [[ "$OPTARG" =~ [0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ ]] \
					&& [[ "$OPTARG" != *","* ]]; then
					# Early sanity: ensure file has at least one candidate token (IP/range/CIDR/hostname)
					if ! file_has_any_valid_entry "$OPTARG"; then
						echo -e "\e[31m [X] Error: -t file '$OPTARG' contains no valid IPs or hostnames \e[0m" >&2
						exit 1
					fi
					 t_opt="$OPTARG"
					 # Resolve any hostnames in the file (non-destructive) and defer validation to targets()
					 resolve_dns_in_file "$t_opt"
					 # Use resolved temp file if provided; validation will occur later in targets()
					 t_opt="${RESOLVED_DNS_FILE:-$t_opt}"
					 if [[ "$TARGETS_ALREADY_RAN" != true ]]; then
					 	TARGETS_ALREADY_RAN=true
					 	targets
					 	if [[ "$HOSTCOUNT_DONE" != true ]]; then
					 		printf "     Counting total number of hosts..."
					 		totaltargets
					 		printf "\r\033[K     Counting total number of hosts... %s\n" "$total_hosts"
					 		HOSTCOUNT_DONE=true
					 	fi
					 	TARGETS_OPT=true
					 fi
					 # We'll still run full targets() later for canonical single-IP expansion if not already
		    # Else if it‚Äôs comma-separated or looks like IP
		    elif { ! [ -f "$OPTARG" ] && [[ "$OPTARG" =~ [0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ ]]; } \
		         || [[ "$OPTARG" == *","* ]]; then
		        # Split on commas
		        IFS=',' read -ra ip_array <<< "$ip_list"
		        # Create two files: metadata and raw
		        metadata_file=$(mktemp /tmp/targets_single_ips.metadata.XXXXXX)
		        raw_file=$(mktemp /tmp/targets_single_ips.raw.XXXXXX)
		        anyerrors=false
		        for token in "${ip_array[@]}"; do
			        trimmed_token="$(trim_ws "$token")"
		            if [ -f "$trimmed_token" ]; then
		                # It's a file
		                if [ ! -s "$trimmed_token" ]; then
		                    echo -e "\e[31m [X] Error: '$trimmed_token' is empty \e[0m" >&2
		                    anyerrors=true
		                    break
		                fi
		                # Add each line to metadata (with prefix) and raw (no prefix)
		                while IFS= read -r fileline; do
		                    echo "__SRC:FILE:${trimmed_token}__ $fileline" >> "$metadata_file"
		                    echo "$fileline" >> "$raw_file"
		                done < "$trimmed_token"
		            else
		                # It's an IP or range => prefix for metadata
		                echo "__SRC:INPUT__ $trimmed_token" >> "$metadata_file"
		                echo "$trimmed_token" >> "$raw_file"
		            fi
		        done
		        if $anyerrors; then
		            exit 1
		        fi
				# Resolve any DNS names before validation; abort if any cannot be resolved
				if ! resolve_dns_in_metadata "$metadata_file" "$raw_file"; then
					exit 1
				fi
				# Validate using metadata (prefixes preserve INPUT/FILE context; avoids leaking temp paths)
				checkfile="$metadata_file"
				checkinvalidips
				# If valid, set t_opt to the raw file (no metadata)
				if [[ "$allvalid" -eq 1 ]]; then
					t_opt="$raw_file"
				else
					exit 1
				fi
				if [[ "$TARGETS_ALREADY_RAN" != true ]]; then
					TARGETS_ALREADY_RAN=true
					targets
					if [[ "$HOSTCOUNT_DONE" != true ]]; then
						printf "     Counting total number of hosts..."
						totaltargets
						printf "\r\033[K     Counting total number of hosts... %s\n" "$total_hosts"
						HOSTCOUNT_DONE=true
					fi
					TARGETS_OPT=true
				fi
		    else
		        # Otherwise, assume single file, hostname, or error
		        if [[ "$OPTARG" == -* ]] || [[ -z "$OPTARG" ]]; then
		            echo -e "\e[31m [X] Error: -t requires an existing file, IP address, DNS name, or any combination in a comma-separated list \e[0m" >&2
		            exit 1
		        elif [[ "$OPTARG" == *" "* ]]; then
		            echo -e "\e[31m [X] Error: Whitespace is not allowed in target entries \e[0m" >&2
		            exit 1
				elif [ -f "$OPTARG" ]; then
		            if [ ! -s "$OPTARG" ]; then
		                echo -e "\e[31m [X] Error: $OPTARG is empty \e[0m" >&2
		                exit 1
		            fi
					 t_opt="$OPTARG"
					 # Resolve any hostnames in the file (non-destructive); validation deferred to targets()
					 resolve_dns_in_file "$t_opt"
					 # Use resolved temp file if provided
					 t_opt="${RESOLVED_DNS_FILE:-$t_opt}"
					 if [[ "$TARGETS_ALREADY_RAN" != true ]]; then
					 	TARGETS_ALREADY_RAN=true
					 	targets
					 	if [[ "$HOSTCOUNT_DONE" != true ]]; then
					 		printf "     Counting total number of hosts..."
					 		totaltargets
					 		printf "\r\033[K     Counting total number of hosts... %s\n" "$total_hosts"
					 		HOSTCOUNT_DONE=true
					 	fi
					 	TARGETS_OPT=true
					 fi
		        # Treat as potential hostname (single label or FQDN) if it has no commas and isn't an IP/CIDR/range
		        elif [[ ! "$OPTARG" =~ [0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ ]] && [[ "$OPTARG" != *","* ]]; then
		            # Accept it directly; downstream targets() will resolve any hostnames
					t_opt="$(mktemp /tmp/z0e_single_host.XXXXXX)"
		            echo "$OPTARG" > "$t_opt"
		            checkfile="$t_opt"
		            # Do not call checkinvalidips here because it expects IP syntax; resolution occurs later
		            :
					 TARGETS_OPT=true
		        else
		            echo -e "\e[31m [X] Error: -t requires an existing file, IP address, or any combination in a comma-separated list \e[0m" >&2
		            exit 1
		        fi
		    fi
		    ;;
		x)
			exc_log="$OPTARG"
			# Handle possible missing argument forwarded to next option (getopts behavior)
			if [[ "${OPTARG:0:1}" == '-' ]]; then
			    OPTIND=$((OPTIND - 1))
			    mkdir -p /var/lib/zeroe
			    touch /var/lib/zeroe/nullexcludes.z0e
			    x_opt="/var/lib/zeroe/nullexcludes.z0e"
			else
			    # Minimal sanitation; defer all validation/DNS to excludes()
			    if [[ -z "$OPTARG" ]]; then
			        echo -e "\e[31m [X] Error: -x requires an argument \e[0m" >&2; exit 1
			    fi
			    if [[ "$OPTARG" == *" "* ]]; then
			        echo -e "\e[31m [X] Error: Whitespace not allowed in -x argument (use commas, no spaces) \e[0m" >&2; exit 1
			    fi
			    if [[ "$OPTARG" == -* ]]; then
			        echo -e "\e[31m [X] Error: File/argument starting with '-' not allowed for -x (ambiguity) \e[0m" >&2; exit 1
			    fi
			    x_opt="$OPTARG"
				# Run excludes now; set flags AFTER successful processing (previous order caused immediate return)
		    	if [[ "$EXCLUDES_ALREADY_RAN" != true ]]; then
		    		excludes
		    		EXCLUDES_ALREADY_RAN=true
		    		EXCLUDES_OPT=true
		    	fi
			fi
		    ;;
		U) 
    		U_opt=true 
    		;;
		u) 
    		u_opt=true 
    		;;
		s)
			s_opt=true
			;;
		S) 
    		if [[ "${OPTARG:0:1}" == '-' ]]; then # Allows -S to be run with or without an argument
    		    OPTIND=$((OPTIND - 1))
    		    S_opt=""
    		else
    		    S_opt="$OPTARG"
    		fi
    		;;
		:) #For when -S or -x is passed without an argument
            if [[ ${OPTARG} == "S" ]]; then
                S_opt=""
			elif [[ ${OPTARG} == "x" ]]; then
				mkdir -p /var/lib/zeroe
				touch /var/lib/zeroe/nullexcludes.z0e
				x_opt="/var/lib/zeroe/nullexcludes.z0e"
			fi
			;;
    	\?)
    		echo -e "\e[31m [X] Error: invalid option "\`-$OPTARG\`" \e[0m" >&2
    		exit 1
    		;;
	esac
done
#Check if the last option was -o or -t and if the arg is missing.
last_arg="${@: -1}"
if [[ "$last_arg" == "-o" ]] && [[ -z "$o_opt" ]]; then
	echo -e "\e[31m [X] Error: -o requires a directory name or path \e[0m" >&2
	exit 1
elif [[ "$last_arg" == "-t" ]] && [[ -z "$t_opt" ]]; then
	echo -e "\e[31m [X] Error: -t requires an existing file, IP address, or any combination in a comma-separated list \e[0m" >&2
	exit 1
fi
#Check if both -e and -i options are used
if [ "$e_opt" = true ] && [ "$i_opt" = true ]; then
    echo -e "\e[31m [X] Error: You seem confused, script kiddie... -e and -i options cannot be used together \e[0m" >&2
    exit 1
fi
#Check if both -U and -u options are used
if [ "$U_opt" = true ] && [ "$u_opt" = true ]; then
    echo -e "\e[31m [X] Error: You seem confused, script kiddie... -U and -u options used together doesn't make sense \e[0m" >&2
    exit 1
fi
#Check if both -s and -S options are used
if [ "$s_opt" = true ] && [ "$S_opt" != "disabled" ]; then
    echo -e "\e[31m [X] Error: You seem confused, script kiddie... -s disables stage resuming and selection \e[0m" >&2
    exit 1
fi
#Check if both -t and -x are the same file
if [ "$t_opt" = "$x_opt" ] && [ -n "$t_opt" ] && [ -n "$x_opt" ]; then
    echo -e "\e[31m [X] Error: You must be perplexed, script kiddie... targets and excludes cannot be the same file \e[0m" >&2
    exit 1
fi
#Validate ntfy argument
ntfy
# Quick DNS preflight before prompts to save time if DNS is broken
dns_preflight_check

#Set the stage to start at
sessioninit
stageinit
# Determine file paths based on session
if [[ "$session_flag" = true && -n "$session" ]]; then
    stage_file="/var/lib/zeroe/sessions/$session/stage.z0e"
    vars_file="/var/lib/zeroe/sessions/$session/vars.z0e"
    initdir_file="/var/lib/zeroe/sessions/$session/initdir.z0e"
else
    stage_file="/var/lib/zeroe/stage.z0e"
    vars_file="/var/lib/zeroe/vars.z0e"
    initdir_file="/var/lib/zeroe/initdir.z0e"
fi
# Final checks and functions
if [ -f "$stage_file" ] && [ -f "$vars_file" ] && [[ "$resume" = "y" ]]; then #If successfully resuming saved stage...
	if [[ "$(cat "$initdir_file")" = "$(pwd)" ]]; then #check if the current and previous working dir are equal, then...
		: #silently continue to...
	else
		cd "$(cat "$initdir_file")" || { echo -e "\e[31m [X] Error: Cannot change to previous working directory -- exiting Zero-E \e[0m" >&2; exit; } #change dirs to the previous working dir (or exit if cannot) and...
	fi
	#parse options to resume scans
	while IFS='=' read -r key rest; do # The value is everything after the first '=', preserving internal quotes and spaces
    	value="${rest#\"}"      # Remove leading quote
    	value="${value%\"}"     # Remove trailing quote
    	eval "$key=\"$value\""  # Use eval to correctly handle complex values, ensuring to escape as needed
	done < "$vars_file"
else #Starting new scan or from specific stage
	if [ ! -f "$vars_file" ] && [[ "$resume" = "y" ]]; then #If choosing resuming without saved options
		echo -e "\e[31m [X] Error: No saved options exist -- configure new scan \e[0m" >&2
		S_opt='disabled'
		resume=''
		while true; do
			stageinit
			if [[ "$resume" = "y" ]]; then
				echo -e "\e[31m [X] Error: New scan configuration required -- resuming without saved options will cause errors \e[0m" >&2
				S_opt='disabled'
				resume=''
			else
				break
			fi
		done
	fi
	#Set external or internal
	settype
	# Early phase1 output before prompts (no backup yet)
	output
	#Enable or disable UDP scans
	enableudp
	# If UDP is enabled and we're not running services-udp only, ensure nmap-service-probes early
	if [[ "$U_opt" = true || "$udp" = "y" ]]; then
		if ! { [[ "$only_flag" == true ]] && { [[ "$stage" == "services-udp" ]] || [[ "$S_opt" == "services-udp" ]]; }; }; then
			if ! ensure_nmap_service_probes; then
				echo -e "\e[31m [X] nmap-service-probes is required for UDP discovery. Aborting.\e[0m" 1>&2
				exit 1
			else
				PROBES_CHECKED=true
			fi
		fi
	fi
	# If running discovery-lists with --only, skip prompting for targets/excludes
	if ! { [[ "$only_flag" == true ]] && { [[ "$stage" == "discovery-lists" ]] || [[ "$S_opt" == "discovery-lists" ]]; }; }; then
		# Set the target IPs file unless already supplied via -t
		if [[ "$TARGETS_ALREADY_RAN" != true ]]; then
			targets
		fi
		# Host count only once
		if [[ "$HOSTCOUNT_DONE" != true ]]; then
			printf "     Counting total number of hosts..."
			totaltargets
			printf "\r\033[K     Counting total number of hosts... %s\n" "$total_hosts"
			HOSTCOUNT_DONE=true
		fi
		# Set the excluded IPs file unless already provided via -x
		if [[ "$EXCLUDES_OPT" != true && "$EXCLUDES_ALREADY_RAN" != true ]]; then
			excludes
		fi
		# Check if targets and excludes are the same and repeat loop while they are
		if cmp -s "$ips" "$nostrikes"; then
			echo -e "\e[31m [X] Error: You seem confused, script kiddie... all of the targets are excluded \e[0m" >&2
			ips=""
			t_opt=""
			nostrikes=""
			x_opt=""
			while true; do
				if [[ "$TARGETS_ALREADY_RAN" != true ]]; then
					targets
				fi
				printf "     Counting total number of hosts..."
				totaltargets
				printf "\r\033[K     Counting total number of hosts... %s\n" "$total_hosts"
				if [[ "$EXCLUDES_OPT" != true && "$EXCLUDES_ALREADY_RAN" != true ]]; then
					excludes
				fi
				if cmp -s "$ips" "$nostrikes"; then
					echo -e "\e[31m [X] Error: You must be perplexed, script kiddie... all of the targets are still excluded \e[0m" >&2
					ips=""
					t_opt=""
					nostrikes=""
					x_opt=""
				else
					break
				fi
			done
		fi
	else
		# when running discovery-lists with --only
		echo -e "\e[36m [i] Using prior discovery results to generate lists\e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
	fi
fi
# Commit phase for output (backup/cleanup) now that options resolved
OUTPUT_COMMIT_MODE=true; output; unset OUTPUT_COMMIT_MODE

stagefilescheck
#if --only is not applicable
if [[ "$only_flag" == true ]] && [[ "$u_opt" == true ]] && [[ "$U_opt" == false ]] && [[ "$S_opt" == "disabled" ]]; then
  only_flag=false
fi
#If ngineer mode
if [[ "$ngineer_mode" == true && "$resume" != "y" ]]; then
	z0engineer
fi
#Save options to file for resuming stage
if [[ "$resume" != "y" ]]; then
	echo "e_opt=\"$e_opt\" i_opt=\"$i_opt\" filepath=\"$filepath\" ips=\"$ips\" nostrikes=\"$nostrikes\" U_opt=\"$U_opt\" u_opt=\"$u_opt\" total_hosts=\"$total_hosts\" typevar=\"$typevar\" only_flag=\"$only_flag\" stage_cont=\"$stage_cont\" targets_userInput=\"$targets_userInput\"" | tee "$vars_file" > /dev/null
	echo "$stage" > "$stage_file"
	logconfig "$vars_file" > $filepath/logs/$typevar-config.log
	#Save ngineer options
	if [[ "$ngineer_mode" == true ]]; then
	echo "ngineer_mode=\"$ngineer_mode\" ngineer_ext_alives_default=\"$ngineer_ext_alives_default\" ngineer_ports_default=\"$ngineer_ports_default\" ngineer_udpa_default=\"$ngineer_udpa_default\" ngineer_tcps_default=\"$ngineer_tcps_default\" ngineer_udps_default=\"$ngineer_udps_default\" z0eng_ext_alives_opts=\"$z0eng_ext_alives_opts\" z0eng_masscan_tcp_opts=\"$z0eng_masscan_tcp_opts\" z0eng_masscan_tcp_opts=\"$z0eng_masscan_tcp_opts\" z0eng_udpa_opts=\"$z0eng_udpa_opts\" z0eng_tcps_opts=\"$z0eng_tcps_opts\" z0eng_udps_opts=\"$z0eng_udps_opts\" z0eng_int_alives_nmap_opts=\"$z0eng_int_alives_nmap_opts\" z0eng_int_alives_masscan_opts=\"$z0eng_int_alives_masscan_opts\" ngineer_int_alives_default=\"$ngineer_int_alives_default\"" >> "$vars_file"
	fi
fi

#cd to the output dir for better masscan resuming
cd $filepath
#Sets trap for when script stops before finishing
trap whenkilled INT TERM

#Start scans
echo -e "\e[35m \n [=] Zero-E started \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
z0e_started=true
#==================================
#=============EXTERNAL=============
#==================================
if [ "$e_opt" = true ] || [ "$type" = "E" ] || [ "$type" = "e" ] || [ "$type" = "external" ] || [ "$type" = "External" ] || [ "$type" = "Ext" ] || [ "$type" = "ext" ]; then

	#Stage -- start
	if { [[ "$stage" == "discovery-hosts" ]] || [[ "$stage" == "script-start" ]]; } && ! { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]]; }; then
		echo "discovery-hosts" > "$stage_file"
		stage="discovery-hosts"
        # Per-stage status log for discovery-hosts
			STATUS_LOG="$filepath/logs/processed/$typevar-status-discovery-hosts.log"; : > "$STATUS_LOG"

		if [[ "$stage" == "discovery-hosts" ]] && [[ "$resume" = "y" ]]; then
			echo -e "\e[34m [-] Resuming alive host discovery scans -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			echo -e "\e[36m [i] Using options from resumed scan \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		else
			echo -e "\e[34m [-] Starting discovery scans -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		fi

		###Nmap alive host discovery
		echo -e "\e[34m [-] Discovering live hosts with Nmap... \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		# Build the discovery-hosts nmap command; allow ngineer override
		if [[ "$ngineer_mode" == true && "$resume" != "y" && "$ngineer_ext_alives_default" != true && -n "$z0eng_ext_alives_opts" ]]; then
			ntdscan="nmap $z0eng_ext_alives_opts --excludefile $nostrikes -iL $ips -oA $filepath/logs/$typevar-nmapAlives-results"
			echo -e "\e[33m [!] Using z0e ngineer options for Nmap discovery-hosts scan \e[0m"
		else
			ntdscan="nmap -n -sn --min-rate 400 --max-retries 1 --min-parallelism 32 --max-hostgroup 1024 -PE -PP -PS21,22,23,25,53,80,110,111,135,139,143,389,443,445,465,587,990,993,995,1025,1433,1521,1723,2049,2375,2376,3128,3306,3389,3690,4333,4500,5000,5432,5601,5672,5900,5985,5986,6001,6379,8000,8080,8081,8088,8181,8443,8888,9000,9200 -PA22,25,53,80,110,135,139,143,389,443,445,465,587,993,995,1433,1521,3306,3389,5900,5985,5986,8080,8443 --reason --stats-every 5m --excludefile $nostrikes -iL $ips -oA $filepath/logs/$typevar-nmapAlives-results"
		fi
		echo "ntdscan=\"$ntdscan\"" >> "$vars_file"
		# Always delegate to runner to honor preferred resume order (.progress, then .nmap, else fresh)
		run_batched_nmap_sn "$ntdscan" "2>>\"$filepath/logs/$typevar-errors.log\""  

		status_msg="[+] Discovering live hosts with Nmap... Done"
		if [[ "${z0e_nmap_sn_periodic_printed:-false}" = true ]]; then
			echo -e "\e[32m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		else
			# Ensure newline to prevent next output from appearing on same line
			printf "\033[A\r\e[K\e[32m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		fi
		ntfy "$status_msg"
		# Clear stage-level resume flag after this stage's resume handling is complete
		if [[ "$resume" = "y" ]]; then resume=''; fi
		#Generate alives file
		cat "$filepath/logs/$typevar-nmapAlives-results.gnmap" | grep 'Up' | awk '{print $2}' | sort -u | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n > $filepath/$typevar-aliveHosts.txt
		if [[ "$stage" == "discovery-hosts" ]] && [[ "$only_flag" == true ]]; then	
			if grep -q "\S" "$filepath/$typevar-aliveHosts.txt"; then
				echo "" | tee -a "$filepath/logs/$typevar-timestamps.log"
				status_msg="[+] Alive hosts discovered -- $(date)"
				echo -e "\e[32m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				ntfy "$status_msg"
			else
				status_msg="[!] No alive hosts detected -- if unexpected, check targets or inquire about scan defenses or other interference"
				echo -e "\e[33m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				ntfy "$status_msg"
				echo -e "\e[33m [!] Exiting Zero-E... \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				z0ecleanup
				exit 1
			fi
		fi
		#Stage update
		if [[ "$only_flag" != true && "$stage_cont" == true ]]; then
			echo "discovery-ports" > "$stage_file"
			stage="discovery-ports"
		fi
	fi

	#Stage -- start
	if [[ "$stage" == "discovery-ports" ]] && ! { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]]; }; then
		# Prefer alive hosts discovered by Nmap; behavior:
		# - If aliveHosts exists and is non-empty: use it
		# - If aliveHosts exists but is empty: exit (discovery ran and found none)
		# - If aliveHosts is missing: fallback to original targets
		alive_list="$filepath/$typevar-aliveHosts.txt"
		include_list="$ips"
		if [ -f "$alive_list" ]; then
			if [ -s "$alive_list" ]; then
				include_list="$alive_list"
				if ! { [[ "$resume" = "y" ]]; }; then
					echo -e "\e[36m\n [i] Using alive hosts results for port discovery targets\e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				fi
			else
				status_msg="[!] No alive hosts detected -- if unexpected, check targets or inquire about scan defenses or other interference"
				echo -e "\e[33m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				ntfy "$status_msg"
				echo -e "\e[33m [!] Exiting Zero-E... \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				z0ecleanup
				exit 1
			fi
		else
			# aliveHosts missing (discovery likely skipped); fallback to original targets
			if ! { [[ "$resume" = "y" ]]; }; then
				echo -e "\e[33m [!] Alive hosts list not found -- using original targets for port discovery\e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			fi
		fi
		emscan="sudo masscan --open-only -p 0-65535 --rate=5000 --excludefile $nostrikes --include-file $include_list -oG $filepath/logs/processed/$typevar-discoscan-masscan-tcp.txt"
		# Apply --rate override if provided
		if [[ -n "$masscan_rate_override" ]]; then
			# Replace existing --rate value in emscan
			emscan=$(echo "$emscan" | sed -E "s/--rate=[0-9]+/--rate=${masscan_rate_override}/")
		fi
		echo "emscan=\"$emscan\"" >> "$vars_file"
		if [[ "$stage" == "discovery-ports" ]] && [[ -f "$(pwd)/paused.conf" ]] && [[ "$resume" = "y" ]]; then
			resume=''
			echo -e "\e[34m [-] Resuming discovery scans -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			echo -e "\e[36m [i] Using options from resumed scan \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			# If rate override provided, inject into paused.conf before resuming
			if [[ -n "$masscan_rate_override" && -f paused.conf ]]; then
				if grep -qE '^rate[[:space:]]*=' paused.conf; then
					sed -i -E "s/^rate[[:space:]]*=.*/rate = ${masscan_rate_override}/" paused.conf
				else
					echo "rate = ${masscan_rate_override}" >> paused.conf
				fi
			fi
			masscan --resume paused.conf >> "$filepath/logs/$typevar-masscan-openPorts-tcp.log" 2>&1 &
		else
			if [[ "$ngineer_mode" == true ]]; then
				if [[ "$ngineer_ports_default" == true ]]; then 
					eval "$emscan" >> "$filepath/logs/$typevar-masscan-openPorts-tcp.log" 2>&1 &
				else
					echo -e "\e[33m [!] Using z0e ngineer options for masscan discovery scan \e[0m"
					# Ensure rate override is applied and any existing --rate in custom opts is removed first
					overridden_opts="$z0eng_masscan_tcp_opts"
					if [[ -n "$masscan_rate_override" ]]; then
						overridden_opts=$(echo "$overridden_opts" | sed -E 's/--rate[= ]?[0-9]+//g')
						overridden_opts+=" --rate=${masscan_rate_override}"
					fi
					eval "masscan $overridden_opts --open-only --excludefile $nostrikes --include-file $include_list -oG $filepath/logs/processed/$typevar-discoscan-masscan-tcp.txt" >> "$filepath/logs/$typevar-masscan-openPorts-tcp.log" 2>&1 &
				fi
			else
				eval "$emscan" >> "$filepath/logs/$typevar-masscan-openPorts-tcp.log" 2>&1 &
			fi
		fi
		pid=$!
		# Ensure TCP masscan log exists before grepping and delay briefly for ETA
	touch "$filepath/logs/$typevar-masscan-openPorts-tcp.log"
		sleep 4
		# Do not inject blank lines into timestamp log
		# Try a few times to fetch ETA like the UDP path
		masscaneta=""
		for _ in 1 2 3; do
			masscaneta=$(grep -so '[0-9]\+:[0-9]\+:[0-9]\+ remaining' "$filepath/logs/$typevar-masscan-openPorts-tcp.log" 2>/dev/null | tail -1)
			[ -n "$masscaneta" ] && break
			sleep 1
		done
		[ -z "$masscaneta" ] && masscaneta=""
		echo -ne "\e[34m [-] Discovering open TCP ports with masscan... $masscaneta \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		echo ""
		#Status indicator
	periodicfile="$filepath/logs/$typevar-masscan-openPorts-tcp.log"
		contstatus="Scanning TCP ports"
		statusmasscan
		#Error check and alert
		checked_cmd="$emscan"
		wait $pid
		exitstatus=$?
		errorcheck

		status_msg="[+] Discovering open TCP ports with masscan... Done"
		if [[ "${z0e_masscan_periodic_printed:-false}" = true ]]; then
			echo -e "\e[32m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		else
			printf "\033[A\r\e[K\e[32m $status_msg \e[0m\n" | tee -a "$filepath/logs/$typevar-timestamps.log"
		fi
		ntfy "$status_msg"
		#Filter out hosts with more than 100 ports open
		susinput="$filepath/logs/processed/$typevar-discoscan-masscan-tcp.txt"
		susips="$filepath/$typevar-100port-hosts-tcp.txt"
		susoutput="$filepath/logs/processed/$typevar-discoscan-masscan-tcp-nosusips.txt"
		filtersusips 2>>"$filepath/logs/$typevar-errors.log"

		#Carve out Nmap TCP IP addresses and put them into a file
		if [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ]; then
			awk 'NR==FNR{ips[$0];next} {for (ip in ips) if ($0 !~ ip) print}' $filepath/$typevar-100port-hosts-tcp.txt "$filepath/logs/$typevar-nmapAlives-results.gnmap" > $filepath/logs/$typevar-nmapAlives-results-nosusips.txt #Filter out hosts with more than 100 open tcp ports from the nmap ping scan results
			cat $filepath/logs/$typevar-nmapAlives-results-nosusips.txt | grep 'Up' | awk '{print $2}' >> $filepath/logs/processed/$typevar-discoresults.txt
		else
			cat "$filepath/logs/$typevar-nmapAlives-results.gnmap" | grep 'Up' | awk '{print $2}' >> $filepath/logs/processed/$typevar-discoresults.txt
		fi

		#Carve out masscan TCP IP addresses and put them into a file
		{ cat $filepath/logs/processed/$typevar-discoscan-masscan-tcp-nosusips.txt | grep 'Host' | awk '{print $4}' ; } >> $filepath/logs/processed/$typevar-discoresults.txt # this excludes 100port-hosts. {;} groups the piped commands so all output is redirected
		
		#Generate list of alive hosts
		cat $filepath/logs/processed/$typevar-discoresults.txt | sort -u | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n >> $filepath/$typevar-aliveHosts.txt
		cp $filepath/$typevar-aliveHosts.txt $filepath/$typevar-alives-tmp.txt
		cat $filepath/$typevar-alives-tmp.txt | sort -u | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n > $filepath/$typevar-aliveHosts.txt
		rm $filepath/$typevar-alives-tmp.txt

		#Stage -- update
		if [ "$udp" = "y" ] || [ "$udp" = "yes" ] || [ "$U_opt" = true ]; then
			echo "discovery-udp" > "$stage_file"
			stage="discovery-udp"
	        # Per-stage status log for discovery-udp
			STATUS_LOG="$filepath/logs/processed/$typevar-status-discovery-udp.log"; : > "$STATUS_LOG"
		elif [[ "$stage_cont" == true ]] || { [[ "$stage" == "discovery-ports" ]] && [[ "$only_flag" == true ]]; }; then
			echo "discovery-lists" > "$stage_file"
			stage="discovery-lists"
		fi

	fi

	#Stage -- start
	if { [[ "$stage" == "discovery-udp" ]] && [[ "$udp" = "y" || "$udp" = "yes" || "$U_opt" = true ]]; } || { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]] && [[ "$stage" != "discovery-lists" && "$stage" != "services-udp" ]]; }; then
		# UDP open port discovery with masscan
		# Ensure nmap-service-probes exists to enable masscan payloads (required)
		if [[ "$PROBES_CHECKED" != true ]]; then
			if ! ensure_nmap_service_probes; then
				echo -e "\e[31m [X] nmap-service-probes is required for UDP discovery. Aborting.\e[0m" 1>&2
				exit 1
			fi
		fi
		nmap_payloads_opt="--nmap-payloads /usr/share/nmap/nmap-service-probes"
		udp_ports_list="U:7,U:53,U:69,U:5353,U:26198,U:53,U:5353,U:26198,U:67,U:69,U:80,U:111,U:111,U:2049,U:4045,U:32768-65535,U:123,U:123,U:135,U:1025-1199,U:137,U:137,U:137,U:161,U:260,U:3401,U:161,U:260,U:3401,U:177,U:389,U:427,U:443,U:853,U:3391,U:4433,U:4740,U:5349,U:5684,U:5868,U:6514,U:6636,U:8232,U:10161,U:10162,U:12346,U:12446,U:12546,U:12646,U:12746,U:12846,U:12946,U:13046,U:500,U:500,U:4500,U:520,U:623,U:623,U:626,U:1194,U:1194,U:1604,U:1645,U:1812,U:1701,U:1900,U:2049,U:2123,U:2152,U:3386,U:2302,U:3283,U:3478,U:6481,U:5351,U:5353,U:5353,U:5632,U:5683,U:7777,U:10001,U:10080,U:17185,U:17185,U:27910-27914,U:26000-26004,U:27960-27964,U:30720-30724,U:44400,U:64738,U:3784,U:4665,U:4666,U:4672,U:6429,U:8767,U:9987,U:9987,U:11211,U:27015-27030,U:27444,U:31337,U:34555,U:48899"
		mudpa="sudo masscan --open-only -p $udp_ports_list --rate=2000 $nmap_payloads_opt --excludefile $nostrikes --include-file $ips -oG $filepath/logs/processed/$typevar-discoscan-masscan-udp.txt"
		# Apply --rate override if provided
		if [[ -n "$masscan_rate_override" ]]; then
			mudpa=$(echo "$mudpa" | sed -E "s/--rate=[0-9]+/--rate=${masscan_rate_override}/")
		fi
		echo "mudpa=\"$mudpa\"" >> "$vars_file"
		# Engineer mode override
		if [[ "$resume" = "y" && -f "$(pwd)/paused.conf" ]]; then
			resume=''
			echo -e "\e[34m [-] Resuming UDP discovery scans -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			echo -e "\e[36m [i] Using options from resumed scan \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			# If rate override provided, inject into paused.conf before resuming
			if [[ -n "$masscan_rate_override" && -f paused.conf ]]; then
				if grep -qE '^rate[[:space:]]*=' paused.conf; then
					sed -i -E "s/^rate[[:space:]]*=.*/rate = ${masscan_rate_override}/" paused.conf
				else
					echo "rate = ${masscan_rate_override}" >> paused.conf
				fi
			fi
			masscan --resume paused.conf >> "$filepath/logs/$typevar-masscan-alivesPortsDiscovery-udp.log" 2>&1 &
		else
			if [[ "$ngineer_mode" == true && "$ngineer_udpa_default" != true && -n "$z0eng_udpa_opts" ]]; then
				 echo -e "\e[33m [!] Using z0e ngineer options for masscan UDP discovery scan \e[0m"
				# Ensure rate override is applied and any existing --rate in custom opts is removed first
				overridden_udpa_opts="$z0eng_udpa_opts"
				if [[ -n "$masscan_rate_override" ]]; then
					overridden_udpa_opts=$(echo "$overridden_udpa_opts" | sed -E 's/--rate[= ]?[0-9]+//g')
					overridden_udpa_opts+=" --rate=${masscan_rate_override}"
				fi
				eval "masscan $overridden_udpa_opts --open-only $nmap_payloads_opt --excludefile $nostrikes --include-file $ips -oG $filepath/logs/processed/$typevar-discoscan-masscan-udp.txt" >> "$filepath/logs/$typevar-masscan-alivesPortsDiscovery-udp.log" 2>&1 &
			else
				eval "$mudpa" >> "$filepath/logs/$typevar-masscan-alivesPortsDiscovery-udp.log" 2>&1 &
			fi
		fi
		pid=$!
		# Ensure UDP masscan log exists before grepping and delay briefly for ETA
		touch "$filepath/logs/$typevar-masscan-alivesPortsDiscovery-udp.log"
		# Small delay to allow ETA to populate, mirroring TCP behavior
		sleep 4
		# Do not inject blank lines into timestamp log
		masscaneta=""
		for _ in 1 2 3; do
			masscaneta=$(grep -so '[0-9]\+:[0-9]\+:[0-9]\+ remaining' "$filepath/logs/$typevar-masscan-alivesPortsDiscovery-udp.log" 2>/dev/null | tail -1)
			[ -n "$masscaneta" ] && break
			sleep 1
		done
		[ -z "$masscaneta" ] && masscaneta="" #if no ETA found, set to empty string, but can be modified to "ETA unavailable", etc.
		echo -ne "\e[34m [-] Discovering live hosts and open UDP ports with masscan... $masscaneta \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		echo ""
		# Status indicator
		periodicfile="$filepath/logs/$typevar-masscan-alivesPortsDiscovery-udp.log"
		contstatus="Scanning UDP ports"
		statusmasscan
		# Error check and alert
		checked_cmd="$mudpa"
		wait $pid
		exitstatus=$?
		errorcheck

		status_msg="[+] Discovering live hosts and open UDP ports with masscan... Done"
		if [[ "${z0e_masscan_periodic_printed:-false}" = true ]]; then
			echo -e "\e[32m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		else
			printf "\033[A\r\e[K\e[32m $status_msg \e[0m\n" | tee -a "$filepath/logs/$typevar-timestamps.log"
		fi
		ntfy "$status_msg"
		#Carve out UDP IP addresses from masscan and put them into a file
		if [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ]; then
			awk '
				NR==FNR { ips[$0]; next }
				{
					ip="";
					for (i=1; i<=NF; i++) {
						if ($i=="Host:" && (i+1)<=NF) { ip=$(i+1); break }
					}
					if (!(ip in ips)) print
				}
			' $filepath/$typevar-100port-hosts-tcp.txt "$filepath/logs/processed/$typevar-discoscan-masscan-udp.txt" > $filepath/logs/processed/$typevar-discoscan-masscan-udp-nosusips.txt
			awk '/open/ { for (i=1;i<=NF;i++) if ($i=="Host:" && (i+1)<=NF) { print $(i+1); break } }' $filepath/logs/processed/$typevar-discoscan-masscan-udp-nosusips.txt >> $filepath/logs/processed/$typevar-discoresults.txt
		else
			awk '/open/ { for (i=1;i<=NF;i++) if ($i=="Host:" && (i+1)<=NF) { print $(i+1); break } }' "$filepath/logs/processed/$typevar-discoscan-masscan-udp.txt" >> $filepath/logs/processed/$typevar-discoresults.txt
		fi
		#Stage -- update
		echo "discovery-lists" > "$stage_file"
		stage="discovery-lists"
	fi

	#Stage -- start
	if [[ "$stage" == "discovery-lists" ]]; then
		if [[ "$only_flag" = true && "$stage_cont" != true ]]; then
			echo -e "\e[36m [i] Using prior discovery results to generate lists\e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		fi
		#Make final list of ordered, unique alive hosts excluding sus ips
		cat $filepath/logs/processed/$typevar-discoresults.txt | sort -u | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n >> $filepath/$typevar-aliveHosts.txt
		cp $filepath/$typevar-aliveHosts.txt $filepath/$typevar-alives-tmp.txt
		cat $filepath/$typevar-alives-tmp.txt | sort -u | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n > $filepath/$typevar-aliveHosts.txt
		rm $filepath/$typevar-alives-tmp.txt

		#Generate list of all open ports (always include TCP from prior discovery results if available)
		# TCP ports
			# Ensure temp file exists even if no TCP results are present
			: > "$filepath/rangetemp.txt"
			if [ -f "$filepath/logs/processed/$typevar-discoscan-masscan-tcp-nosusips.txt" ]; then
				awk '/open/ {
				# Find the position where "Ports:" part starts
				if (index($0, "Ports:") > 0) {
					# Get everything after "Ports:"
					ports_section = substr($0, index($0, "Ports:") + 7)
					# Split by comma+space to get individual port entries
					split(ports_section, port_entries, ", ")
					# Process each port entry
					for (i in port_entries) {
						# Extract just the port number from each entry
						split(port_entries[i], parts, "/")
						if (parts[2] == "open") {
							print parts[1]
						}
					}
				}
			}' $filepath/logs/processed/$typevar-discoscan-masscan-tcp-nosusips.txt | sort -u >> $filepath/rangetemp.txt
			fi
			#continue with ports list
			rangeout="$filepath/logs/processed/$typevar-portsfornmap-tcp.txt"
			singleportstorange
			cat $filepath/logs/processed/$typevar-portsfornmap-tcp.txt > $filepath/$typevar-openPorts.txt
			sed -i 's/$/\/TCP/' "$filepath/$typevar-openPorts.txt"
		
		if [ "$udp" = "y" ] || [ "$udp" = "yes" ] || [ "$U_opt" = true ]; then
			# UDP ports (append to existing TCP ports if any)
			if [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ]; then
				awk '
				/open/ {
					line=$0;
					p=index(line, "Ports:");
					if (p>0) {
						ports_section=substr(line, p+7);
						n=split(ports_section, a, ", ");
						for (i=1; i<=n; i++) {
							split(a[i], parts, "/");
							if (parts[2]=="open" && tolower(parts[3])=="udp") print parts[1];
						}
					}
				}
				' $filepath/logs/processed/$typevar-discoscan-masscan-udp-nosusips.txt | sort -u >> $filepath/rangetempu.txt
			else
				awk '
				/open/ {
					line=$0;
					p=index(line, "Ports:");
					if (p>0) {
						ports_section=substr(line, p+7);
						n=split(ports_section, a, ", ");
						for (i=1; i<=n; i++) {
							split(a[i], parts, "/");
							if (parts[2]=="open" && tolower(parts[3])=="udp") print parts[1];
						}
					}
				}
				' $filepath/logs/processed/$typevar-discoscan-masscan-udp.txt | sort -u >> $filepath/rangetempu.txt
			fi
			sort -u $filepath/rangetempu.txt >> $filepath/rangetemp.txt
			rm $filepath/rangetempu.txt
			rangeout="$filepath/logs/processed/$typevar-portsfornmap-udp.txt"
			singleportstorange
			#sed -i '/^[ \t]*$/d' "$rangeout" #Removes blank lines and lines that only contain spaces
			cat $filepath/logs/processed/$typevar-portsfornmap-udp.txt >> $filepath/$typevar-openPorts.txt
			sed -i '/\/TCP$/! s/$/\/UDP/' "$filepath/$typevar-openPorts.txt"
		fi
		nessusports 2>/dev/null

		#Status update
		alivesandportscheck
		if [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ] && [ -s "$filepath/$typevar-100port-hosts-udp.txt" ]; then
			echo -e "\e[33m [!] Excluding potential deception or firewall-protected hosts showing more than 100 open TCP/UDP ports -- recommend inquiring about hosts in ext-100port-hosts-tcp.txt and ext-100port-hosts-udp.txt \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		elif [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ]; then
			echo -e "\e[33m [!] Excluding potential deception or firewall-protected hosts showing more than 100 open TCP ports -- recommend inquiring about hosts in ext-100port-hosts-tcp.txt \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		elif [ -s "$filepath/$typevar-100port-hosts-udp.txt" ]; then
			echo -e "\e[33m [!] Excluding potential deception or firewall-protected hosts showing more than 100 open UDP ports -- recommend inquiring about hosts in ext-100port-hosts-udp.txt \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		fi
		echo -e "\e[36m [i] Generated files for Nessus vulnerability scans -- Hosts: $typevar-aliveHosts.txt | Ports: $typevar-portsForNessus.txt \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
	
		#Stage -- update
		if [[ "$only_flag" != true && "$stage_cont" == true ]]; then
			echo "services-tcp" > "$stage_file"
			stage="services-tcp"
		elif { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]] && [[ "$stage_cont" == true ]]; }; then
			echo "services-udp" > "$stage_file"
			stage="services-udp"
		fi
	
	fi
	
	#Stage -- start
	if [[ "$stage" == "services-tcp" ]]; then
		##Nmap TCP service scans
		#ntportsall="$(cat $filepath/logs/processed/$typevar-portsfornmap-tcp.txt | paste -sd "," -)"
		#ntports3=$($(head -n 3 $filepath/logs/processed/$typevar-portsfornmap-tcp.txt | paste -sd "," -),[...])
		entscan="nmap -sC -sV -Pn -O -p $(cat $filepath/logs/processed/$typevar-portsfornmap-tcp.txt | paste -sd "," -) --open --reason --excludefile $nostrikes -iL $filepath/$typevar-aliveHosts.txt -oA $filepath/$typevar-tcp-servicescan-results"; STATUS_LOG="$filepath/logs/processed/$typevar-status-services-tcp.log"; : > "$STATUS_LOG"
		echo "entscan=\"$entscan\"" >> "$vars_file"
		if grep -q "\S" "$filepath/logs/processed/$typevar-portsfornmap-tcp.txt"; then
			# Grouped TCP service scans (default-on). If resuming, attempt grouped-resume when state exists
			z0e_grouped_done=false
			if [[ "${z0e_grouped_tcps_enabled:-true}" = true ]]; then
				if [[ "$resume" = "y" ]]; then
					if z0e_grouped_state_exists; then
						if run_grouped_tcp_services_scan; then
							status_msg="[+] Nmap TCP service scans complete, results saved as $typevar-tcp-servicescan-results -- $(date)"
							echo -e "\e[32m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
							ntfy "$status_msg"
							z0e_grouped_done=true
						fi
					fi
				else
					# Fresh run: maintain per-stage status log and do grouped
				STATUS_LOG="$filepath/logs/processed/$typevar-status-services-tcp.log"; : > "$STATUS_LOG"
					if run_grouped_tcp_services_scan; then
						status_msg="[+] Nmap TCP service scans complete, results saved as $typevar-tcp-servicescan-results -- $(date)"
						echo -e "\e[32m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
						ntfy "$status_msg"
						z0e_grouped_done=true
					fi
				fi
			fi
			if [[ "$z0e_grouped_done" != true ]]; then
				if [[ "$resume" = "y" ]]; then
					resume=''
					echo -e "\e[34m [-] Resuming TCP service scans \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
					echo -e "\e[36m [i] Using options from resumed scan \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
					execute_nmap_with_realtime_stats "nmap --resume $filepath/$typevar-tcp-servicescan-results.nmap" "1>/dev/null 2>>$filepath/logs/$typevar-errors.log"
				else
					if [[ "$ngineer_mode" == true ]]; then
						if [[ "$ngineer_tcps_default" == true ]]; then	
							execute_nmap_with_realtime_stats "$entscan -v" "1>/dev/null 2>>$filepath/logs/$typevar-errors.log"
						else
							echo -e "\e[33m [!] Using z0e ngineer options for Nmap TCP service scan \e[0m"
							execute_nmap_with_realtime_stats "nmap $z0eng_tcps_opts -sV -Pn -p $(cat $filepath/logs/processed/$typevar-portsfornmap-tcp.txt | paste -sd \",\" -) -oA $filepath/$typevar-tcp-servicescan-results --excludefile $nostrikes -iL $filepath/$typevar-aliveHosts.txt" "1>/dev/null 2>>$filepath/logs/$typevar-errors.log"
						fi
					else
						execute_nmap_with_realtime_stats "$entscan -v" "1>/dev/null 2>>$filepath/logs/$typevar-errors.log"
					fi
				fi
				pid=$!
				echo -e "\e[34m [-] Scanning services on open TCP ports of alive hosts with Nmap -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				#Status indicator
				periodicfile="$filepath/$typevar-tcp-servicescan-results.nmap"
				contstatus="Scanning TCP ports"
				statusnmap
				#Error check and alert
				checked_cmd="$entscan"
				wait $pid
				exitstatus=$?
				printf "\r%-${#indicator}s\r" "" #Clears status indicator line
				if [ "$exitstatus" -eq 0 ]; then
					status_msg="[+] Nmap TCP service scans complete, results saved as $typevar-tcp-servicescan-results -- $(date)"
					echo -e "\e[32m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
					ntfy "$status_msg"
				else
					errorcheck
					if [ "$ntfy_flag" = true ]; then
						ntfy "[!] Nmap TCP service scan failed -- Check errors.log"
					fi
				fi
			fi
			genwindowshostlist_inscript
			listiptohostname_inscript
			parsegnmap_inscript=true
			parsegnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 139,445,137,138 "$filepath/analysis/$typevar-smbHosts.txt"
			parsegnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 80,443,8080,8443,8000,8008,8888 "$filepath/analysis/$typevar-httpHosts.txt"
			parsegnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 22,23,3389,5985,5986,5900,5800,1494,5631,5632 "$filepath/analysis/$typevar-remoteAccessHosts.txt"
			parsegnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 1723,1194 "$filepath/analysis/$typevar-vpnHosts.txt"
			parsegnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 20,21,22,69,111,873,990,2049,3260 "$filepath/analysis/$typevar-fileshareHosts.txt"
			parsegnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 3306,5432,1433,1521 "$filepath/analysis/$typevar-databaseHosts.txt"
			parsegnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 25,465,587,143,993,110,995 "$filepath/analysis/$typevar-emailHosts.txt"
			parsegnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 389,636 "$filepath/analysis/$typevar-ldapHosts.txt"
		else
			status_msg="[!] No open TCP ports detected -- TCP service scans skipped"
			echo -e "\e[33m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			ntfy "$status_msg"
		fi
	
		#Stage -- update
		if { [ "$udp" = "y" ] || [ "$udp" = "yes" ] || [ "$U_opt" = true ]; } && [[ "$stage_cont" == true ]]; then
			echo "services-udp" > "$stage_file"
			stage="services-udp"
		fi
	
	fi

	#Stage -- start
	if [[ "$stage" == "services-udp" ]] && [[ "$udp" = "y" || "$udp" = "yes" || "$U_opt" = true ]]; then
		#Nmap UDP service scans
		nsudp="nmap -v -sU -Pn -sV --open --min-rate 1000 --max-rate 3000 --reason -p $(cat $filepath/logs/processed/$typevar-portsfornmap-udp.txt | paste -sd "," -) -oA $filepath/$typevar-udp-servicescan-results --excludefile $nostrikes -iL $filepath/$typevar-aliveHosts.txt"; STATUS_LOG="$filepath/logs/processed/$typevar-status-services-udp.log"; : > "$STATUS_LOG" 
		if grep -q "\S" "$filepath/logs/processed/$typevar-portsfornmap-udp.txt"; then
			if [[ "$resume" = "y" ]]; then
				resume=''
				echo -e "\e[34m [-] Resuming UDP service scans \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				echo -e "\e[36m [i] Using options from resumed scan \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				execute_nmap_with_realtime_stats "nmap --resume $filepath/$typevar-udp-servicescan-results.nmap" "1>/dev/null 2>>$filepath/logs/$typevar-errors.log"
			else
				if [[ "$ngineer_mode" == true ]]; then
					if [[ "$ngineer_udps_default" == true ]]; then	
						execute_nmap_with_realtime_stats "$nsudp" "1>/dev/null 2>>$filepath/logs/$typevar-errors.log"
					else
						echo -e "\e[33m [!] Using z0e ngineer options for Nmap UDP service scan \e[0m"
						execute_nmap_with_realtime_stats "nmap $z0eng_udps_opts -sU -sV -Pn --reason -p $(cat $filepath/logs/processed/$typevar-portsfornmap-udp.txt | paste -sd \",\" -) -oA $filepath/$typevar-udp-servicescan-results --excludefile $nostrikes -iL $filepath/$typevar-aliveHosts.txt" "1>/dev/null 2>>$filepath/logs/$typevar-errors.log"
					fi
				else
					execute_nmap_with_realtime_stats "$nsudp -v" "1>/dev/null 2>>$filepath/logs/$typevar-errors.log"
				fi
			fi
			pid=$!
			echo -e "\e[34m [-] Scanning services on open UDP ports of alive hosts with Nmap -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			#Status indicator
			periodicfile="$filepath/$typevar-udp-servicescan-results.nmap"
			contstatus="Scanning UDP ports"
			statusnmap
			#Error check and alert
			checked_cmd="nmap -v -sU -Pn -sV --open --min-rate 1000 --max-rate 3000 --reason -p $(cat $filepath/logs/processed/$typevar-portsfornmap-udp.txt | paste -sd "," -) -oA $filepath/$typevar-udp-servicescan-results --excludefile $nostrikes -iL $filepath/$typevar-aliveHosts.txt"
			wait $pid
			exitstatus=$?
			printf "\r%-${#indicator}s\r" "" #Clears status indicator line
			if [ "$exitstatus" -eq 0 ]; then
				status_msg="[+] Nmap UDP service scans complete, results saved as $typevar-udp-servicescan-results -- $(date)"
				echo -e "\e[32m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				ntfy "$status_msg"
			else
				errorcheck
				if [ "$ntfy_flag" = true ]; then
					ntfy "[!] Nmap UDP service scan failed -- Check errors.log"
				fi
			fi
			genwindowshostlist_inscript
			listiptohostname_inscript
		else
			status_msg="[!] No open UDP ports detected -- UDP service scans skipped"
			echo -e "\e[33m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			ntfy "$status_msg"
		fi
	fi

	#fi
	status_msg="[=] Zero-E completed -- happy hacking!"
	echo -e "\e[35m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
	ntfy "$status_msg"
	z0ecleanup
fi
#================================
#===========INTERNAL=============
#================================
if [ "$i_opt" = true ] || [ "$type" = "I" ] || [ "$type" = "i" ] || [ "$type" = "internal" ] || [ "$type" = "Internal" ] || [ "$type" = "Int" ] || [ "$type" = "int" ]; then

	#Stage -- start
	if { [[ "$stage" == "discovery-hosts" ]] || [[ "$stage" == "script-start" ]]; } && ! { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]]; }; then
		echo "discovery-hosts" > "$stage_file"
		stage="discovery-hosts"

		if [[ "$stage" == "discovery-hosts" ]] && [[ "$resume" = "y" ]]; then
			resume="y"
			echo -e "\e[34m [-] Resuming alive host discovery scans -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			echo -e "\e[36m [i] Using options from resumed scan \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		else
			echo -e "\e[34m [-] Starting discovery scans -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		fi
		# Decide tool for internal alive-host discovery: Nmap for <25k, masscan for >=25k
		if (($total_hosts >= 1 && $total_hosts <= 24999)); then
			# Nmap alive host discovery (tiered)
			echo -e "\e[34m [-] Discovering live hosts with Nmap... \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			STATUS_LOG="$filepath/logs/processed/$typevar-status-discovery-hosts.log"; : > "$STATUS_LOG"
			if [[ "$ngineer_mode" == true && "$resume" != "y" && "$ngineer_int_alives_default" != true && -n "${z0eng_int_alives_nmap_opts:-}" ]]; then
				echo -e "\e[33m [!] Using z0e ngineer options for Nmap host discovery scan \e[0m"
				alivesnscan="nmap -sn ${z0eng_int_alives_nmap_opts} --reason --stats-every 5m --excludefile \"$nostrikes\" -iL \"$ips\" -oA \"$filepath/logs/$typevar-nmapAlives-results\""
			else
				alivesnscan="nmap -n -sn --max-retries 1 --min-parallelism 32 --reason -PR -PE -PP --excludefile \"$nostrikes\" -iL \"$ips\" -oA \"$filepath/logs/$typevar-nmapAlives-results\""
				# Per-tier tuning
				if (($total_hosts >= 1 && $total_hosts <= 4999)); then
					alivesnscan+=" --stats-every 5m --min-rate 400 --max-hostgroup 1024 -PS80,443,22,3389,8080,8443,25,587,993,995,3306,5432,445,135,139,143,110,53,1433,1521,2049,3128,5000,5601,5672,5900,5985,5986,6379,8000,8081,8888,9000,9200 -PA80,443,22,3389,445,135,25,587,993,995,3306,5432"
				elif (($total_hosts >= 5000 && $total_hosts <= 9999)); then
					alivesnscan+=" --min-rate 800 --max-hostgroup 2048 -PS80,443,22,3389,8080,8443,25,587,993,995,3306,5432,445,135,139,143,110,53,1433,1521,2049,3128,5000,5900,5985,5986 -PA80,443,22,3389,445,25,587,993,995"
				elif (($total_hosts >= 10000 && $total_hosts <= 24999)); then
					alivesnscan+=" --min-rate 1200 --max-hostgroup 2048 -PS80,443,22,3389,8080,8443,445,135,53,1433,1521,3306,5432,5900,5985,5986 -PA80,443,22,3389"
				fi
			fi
			# Save for resume context
			echo "alivesnscan=\"$alivesnscan\"" >> "$vars_file"
			# Always delegate to runner to honor preferred resume order (.progress, then .nmap, else fresh)
			run_batched_nmap_sn "$alivesnscan" "2>>\"$filepath/logs/$typevar-errors.log\""  

			status_msg="[+] Discovering live hosts with Nmap... Done"
			# Clear stage-level resume flag after this stage's resume handling is complete
			if [[ "$resume" = "y" ]]; then resume=''; fi
			# If periodic Nmap -sn updates were printed, avoid overwriting them
			if [[ "${z0e_nmap_sn_periodic_printed:-false}" = true ]]; then
				echo -e "\e[32m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			else
				printf "\033[A\r\e[K\e[32m $status_msg \e[0m\n" | tee -a "$filepath/logs/$typevar-timestamps.log"
			fi
			ntfy "$status_msg"
			# Append to discoresults and generate aliveHosts
			cat "$filepath/logs/$typevar-nmapAlives-results.gnmap" | grep 'Up' | awk '{print $2}' >> "$filepath/logs/processed/$typevar-discoresults.txt"
			cat "$filepath/logs/$typevar-nmapAlives-results.gnmap" | grep 'Up' | awk '{print $2}' | sort -u | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n > "$filepath/$typevar-aliveHosts.txt"
			# Only mode messaging and checks
			if [[ "$stage" == "discovery-hosts" ]] && [[ "$only_flag" == true ]]; then
				if grep -q "\S" "$filepath/$typevar-aliveHosts.txt"; then
					echo "" | tee -a "$filepath/logs/$typevar-timestamps.log"
					status_msg="[+] Alive hosts discovered -- $(date)"
					echo -e "\e[32m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
					ntfy "$status_msg"
				else
					status_msg="[!] No alive hosts detected -- if unexpected, check targets or inquire about scan defenses or other interference"
					echo -e "\e[33m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
					ntfy "$status_msg"
					echo -e "\e[33m [!] Exiting Zero-E... \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
					z0ecleanup
					exit 1
				fi
			else
				if ! grep -q "\S" "$filepath/logs/processed/$typevar-discoresults.txt" 2>/dev/null; then
					echo -e "\e[33m [!] No alive hosts detected -- if unexpected, check targets or inquire about scan defenses or other interference \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
					echo -e "\e[33m [!] Exiting Zero-E... \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
					z0ecleanup
					exit 1
				fi
			fi
		else
			# masscan alive host discovery (original logic) for >=25k
			#Prevent system from sending RST packets by setting the firewall to block packets returning to the masscan origin port
			setfirewallrule

			if [[ "$ngineer_mode" == true && "$resume" != "y" && "$ngineer_int_alives_default" != true && -n "${z0eng_int_alives_masscan_opts:-}" ]]; then
				echo -e "\e[33m [!] Using z0e ngineer options for masscan host discovery scan \e[0m"
				alivesmscan="sudo masscan --src-port=55555 --excludefile $nostrikes --include-file $ips -oG $filepath/logs/processed/$typevar-masscanalives-results.txt ${z0eng_int_alives_masscan_opts}"
			else
				alivesmscan="sudo masscan --rate=8000 --src-port=55555 --ping --excludefile $nostrikes --include-file $ips -oG $filepath/logs/processed/$typevar-masscanalives-results.txt"
			fi
			# Apply --rate override if provided
			if [[ -n "$masscan_rate_override" ]]; then
				alivesmscan=$(echo "$alivesmscan" | sed -E "s/--rate=[0-9]+/--rate=${masscan_rate_override}/")
				alivesmscan+=" --rate=${masscan_rate_override}"
			fi
			if [[ "$stage" == "discovery-hosts" ]] && [[ -f "$(pwd)/paused.conf" ]] && [[ "$resume" = "y" ]]; then
				resume=''
				# If rate override provided, inject into paused.conf before resuming
				if [[ -n "$masscan_rate_override" && -f paused.conf ]]; then
					if grep -qE '^rate[[:space:]]*=' paused.conf; then
						sed -i -E "s/^rate[[:space:]]*=.*/rate = ${masscan_rate_override}/" paused.conf
					else
						echo "rate = ${masscan_rate_override}" >> paused.conf
					fi
				fi
				{ masscan --resume paused.conf >> "$filepath/logs/$typevar-masscan-alivesResults-tcp.log" 2>&1 & } && sleep 2
			elif [[ "$stage" == "discovery-hosts" ]] || [[ "$stage" == "discovery-hosts" && ! -f "$(pwd)/paused.conf" && "$resume" = "y" ]]; then
				if [[ "$stage" == "discovery-hosts" && ! -f "$(pwd)/paused.conf" && "$resume" = "y" ]]; then
					echo -e "\e[33m [!] masscan paused.conf file not found -- restarting alive host discovery scans \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				fi
				#fpscan='while IFS= read -r i; do fping -a -q -g "$i" >> "$#filepath/$typevar-fping-results.txt"; done < "$filepath/logs/$typevar-fpingcidrs.txt"'
				if (($total_hosts >= 25000 && $total_hosts <= 49999)); then
					checked_cmd="$alivesmscan --top-ports 1500 && sleep 1"
					eval "$alivesmscan --top-ports 1500 && sleep 1" >> "$filepath/logs/$typevar-masscan-alivesResults-tcp.log" 2>&1 &
				elif (($total_hosts >= 50000 && $total_hosts <= 99999)); then
					checked_cmd="$alivesmscan --top-ports 1000 && sleep 1"
					eval "$alivesmscan --top-ports 1000 && sleep 1" >> "$filepath/logs/$typevar-masscan-alivesResults-tcp.log" 2>&1 &
				elif (($total_hosts >= 100000 && $total_hosts <= 149999)); then
					checked_cmd="$alivesmscan --top-ports 500 && sleep 1"
					eval "$alivesmscan --top-ports 500 && sleep 1" >> "$filepath/logs/$typevar-masscan-alivesResults-tcp.log" 2>&1 &
				elif (($total_hosts >= 150000 && $total_hosts <= 199999)); then
					checked_cmd="$alivesmscan --top-ports 250 && sleep 1"
					eval "$alivesmscan --top-ports 250 && sleep 1" >> "$filepath/logs/$typevar-masscan-alivesResults-tcp.log" 2>&1 &
				elif (($total_hosts >= 200000 && $total_hosts <= 249999)); then
					checked_cmd="$alivesmscan --top-ports 150 && sleep 1"
					eval "$alivesmscan --top-ports 150 && sleep 1" >> "$filepath/logs/$typevar-masscan-alivesResults-tcp.log" 2>&1 &
				elif (($total_hosts >= 250000 && $total_hosts <= 499999)); then
					checked_cmd="$alivesmscan --top-ports 50 && sleep 1"
					eval "$alivesmscan --top-ports 50 && sleep 1" >> "$filepath/logs/$typevar-masscan-alivesResults-tcp.log" 2>&1 &
				elif (($total_hosts >= 500000)); then
					checked_cmd="$alivesmscan --top-ports 20 && sleep 1"
					eval "$alivesmscan --top-ports 20 && sleep 1" >> "$filepath/logs/$typevar-masscan-alivesResults-tcp.log" 2>&1 &
				fi
				pid=$!
				sleep 4
				echo -ne "\e[34m [-] Discovering live hosts with masscan... $(grep -o '[0-9]\+:[0-9]\+:[0-9]\+ remaining' \"$filepath/logs/$typevar-masscan-alivesResults-tcp.log\" | tail -1) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				echo ""
				#Status indicator
				periodicfile="$filepath/logs/$typevar-masscan-alivesResults-tcp.log"
				contstatus="Scanning hosts"
				statusmasscan
				#Error check and alert
				wait $pid
				exitstatus=$?
				errorcheck
			fi 

			status_msg="[+] Discovering live hosts with masscan... Done"
			if [[ "${z0e_masscan_periodic_printed:-false}" = true ]]; then
				echo -e "\e[32m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			else
				printf "\033[A\r\e[K\e[32m $status_msg \e[0m\n" | tee -a "$filepath/logs/$typevar-timestamps.log"
			fi
			ntfy "$status_msg"
			#Filter out hosts with more than 100 ports open
			susinput="$filepath/logs/processed/$typevar-masscanalives-results.txt"
			susips="$filepath/$typevar-100port-hosts-tcp.txt"
			susoutput="$filepath/logs/processed/$typevar-discoscan-masscan-tcp-nosusips.txt"
			filtersusips
			#Carve out TCP IP addresses and put them into a file
			cat $filepath/logs/processed/$typevar-discoscan-masscan-tcp-nosusips.txt | grep 'Host' | awk '{print $4}' >> "$filepath/logs/processed/$typevar-discoresults.txt" #this excludes 100port-hosts
			#Generate alives file
			cat "$filepath/logs/processed/$typevar-discoresults.txt" | sort -u | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n > "$filepath/$typevar-aliveHosts.txt"
			if [[ "$stage" == "discovery-hosts" ]] && [[ "$only_flag" == true ]]; then
				if grep -q "\S" "$filepath/$typevar-aliveHosts.txt"; then
					echo -e "\e[32m [+] Alive hosts discovered -- "$(date)" \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				else
					echo -e "\e[33m [!] No alive hosts detected -- if unexpected, check targets or inquire about scan defenses or other interference \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
					#Remove firewall rule
					removefirewallrule
					echo -e "\e[33m [!] Exiting Zero-E... \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
					z0ecleanup
					exit 1
				fi
			else
				if ! grep -q "\S" "$filepath/logs/processed/$typevar-discoresults.txt" 2>/dev/null; then
					echo -e "\e[33m [!] No alive hosts detected -- if unexpected, check targets or inquire about scan defenses or other interference \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
					#Remove firewall rule
					removefirewallrule
					echo -e "\e[33m [!] Exiting Zero-E... \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
					z0ecleanup
					exit 1
				fi
			fi
		fi

		#Stage -- update
		if [[ "$only_flag" != true && "$stage_cont" == true ]]; then
			echo "discovery-ports" > "$stage_file"
			stage="discovery-ports"
		fi

	fi
	
	#Stage -- start
	if [[ "$stage" == "discovery-ports" ]] && ! { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]]; }; then

		# Inform about the source of the alive hosts list used for masscan input (skip on resume)
		if ! { [[ "$resume" = "y" ]]; }; then
			if [ -s "$filepath/$typevar-aliveHosts.txt" ]; then
				# Determine likely producer based on total_hosts threshold used earlier
				if (( $total_hosts <= 24999 )); then
					echo -e "\e[36m [i] Using alive hosts results for port discovery targets\e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				else
					echo -e "\e[36m [i] Using alive hosts results for port discovery targets\e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				fi
			else
				echo -e "\e[33m [!] Alive hosts results not found or empty -- using original targets for port discovery\e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			fi
		fi

		if [ "$firewallset" != true ]; then
			setfirewallrule
		fi
		# Prefer alive hosts discovered earlier; fallback to original targets
		alive_list="$filepath/$typevar-aliveHosts.txt"
		include_list="$ips"
		if [ -s "$alive_list" ]; then
			include_list="$alive_list"
		fi
		imscan="sudo masscan --open-only -p 0-65535 --rate=8000 --src-port=55555 --excludefile $nostrikes --include-file $include_list -oG $filepath/logs/processed/$typevar-discoscan-masscan-tcp.txt"
		# Apply --rate override if provided
		if [[ -n "$masscan_rate_override" ]]; then
			imscan=$(echo "$imscan" | sed -E "s/--rate=[0-9]+/--rate=${masscan_rate_override}/")
		fi
		echo "imscan=\"$imscan\"" >> "$vars_file"
		if [[ "$stage" == "discovery-ports" ]] && [[ -f "$(pwd)/paused.conf" ]] && [[ "$resume" = "y" ]]; then
			resume=''
			echo -e "\e[34m [-] Resuming masscan open port discovery scans -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			echo -e "\e[36m [i] Using options from resumed scan \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			if [[ "$firewallset" != true ]]; then
				setfirewallrule
			fi
			# If rate override provided, inject into paused.conf before resuming
			if [[ -n "$masscan_rate_override" && -f paused.conf ]]; then
				if grep -qE '^rate[[:space:]]*=' paused.conf; then
					sed -i -E "s/^rate[[:space:]]*=.*/rate = ${masscan_rate_override}/" paused.conf
				else
					echo "rate = ${masscan_rate_override}" >> paused.conf
				fi
			fi
			masscan --resume paused.conf >> "$filepath/logs/$typevar-masscan-openPorts-tcp.log" 2>&1 &
		else
			if [[ "$ngineer_mode" == true ]]; then
				if [[ "$ngineer_ports_default" == true ]]; then	
					if [[ "$firewallset" != true ]]; then
						setfirewallrule
					fi
					eval "$imscan" >> "$filepath/logs/$typevar-masscan-openPorts-tcp.log" 2>&1 &
				else
					echo -e "\e[33m [!] Using z0e ngineer options for masscan open ports scan \e[0m"
					if [[ "$firewallset" != true ]]; then
						setfirewallrule
					fi
					# Ensure rate override is applied and any existing --rate in custom opts is removed first
					overridden_ports_opts="$z0eng_masscan_tcp_opts"
					if [[ -n "$masscan_rate_override" ]]; then
						overridden_ports_opts=$(echo "$overridden_ports_opts" | sed -E 's/--rate[= ]?[0-9]+//g')
						overridden_ports_opts+=" --rate=${masscan_rate_override}"
					fi
					eval "masscan $overridden_ports_opts --open-only --excludefile $nostrikes --include-file $include_list -oG $filepath/logs/processed/$typevar-discoscan-masscan-tcp.txt" >> "$filepath/logs/$typevar-masscan-openPorts-tcp.log" 2>&1 &
				fi
			else
				if [[ "$firewallset" != true ]]; then
					setfirewallrule
				fi
				eval "$imscan" >> "$filepath/logs/$typevar-masscan-openPorts-tcp.log" 2>&1 &
			fi
		fi
		pid=$!
		sleep 4
		echo -ne "\e[34m [-] Discovering open TCP ports with masscan... $(grep -o '[0-9]\+:[0-9]\+:[0-9]\+ remaining' "$filepath/logs/$typevar-masscan-openPorts-tcp.log" | tail -1) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		echo ""
		#Status indicators
		periodicfile="$filepath/logs/$typevar-masscan-openPorts-tcp.log"
		contstatus="Scanning TCP ports"
		statusmasscan
		#Error check and alert
		checked_cmd="$imscan"
		wait $pid
		exitstatus=$?
		errorcheck

		status_msg="[+] Discovering open TCP ports with masscan... Done"
		# If periodic masscan updates were printed, avoid overwriting them
		if [[ "${z0e_masscan_periodic_printed:-false}" = true ]]; then
			echo -e "\e[32m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		else
			printf "\033[A\r\e[K\e[32m $status_msg \e[0m\n" | tee -a "$filepath/logs/$typevar-timestamps.log"
		fi
		ntfy "$status_msg"
		#Filter out hosts with more than 100 ports open
		susinput="$filepath/logs/processed/$typevar-discoscan-masscan-tcp.txt"
		susips="$filepath/$typevar-100port-hosts-tcp.txt"
		susoutput="$filepath/logs/processed/$typevar-discoscan-masscan-tcp-nosusips.txt"
		filtersusips
		#Carve out TCP IP addresses and put them into a file
		cat $filepath/logs/processed/$typevar-discoscan-masscan-tcp-nosusips.txt | grep 'Host' | awk '{print $4}' >> $filepath/logs/processed/$typevar-discoresults.txt #this excludes 100port-hosts
	
		#Generate list of alive hosts
		cat $filepath/logs/processed/$typevar-discoresults.txt | sort -u | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n >> $filepath/$typevar-aliveHosts.txt
		cp $filepath/$typevar-aliveHosts.txt $filepath/$typevar-alives-tmp.txt
		cat $filepath/$typevar-alives-tmp.txt | sort -u | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n > $filepath/$typevar-aliveHosts.txt
		rm $filepath/$typevar-alives-tmp.txt

		#Stage -- update
		if [ "$udp" = "y" ] || [ "$udp" = "yes" ] || [ "$U_opt" = true ]; then 
			echo "discovery-udp" > "$stage_file"
			stage="discovery-udp"
			STATUS_LOG="$filepath/logs/processed/$typevar-status-discovery-udp.log"; : > "$STATUS_LOG"
		elif [[ "$stage_cont" == true ]] || { [[ "$stage" == "discovery-ports" ]] && [[ "$only_flag" == true ]]; }; then
			echo "discovery-lists" > "$stage_file"
			stage="discovery-lists"
		fi

	fi

	#Stage -- start
	if { [[ "$stage" == "discovery-udp" ]] && [[ "$udp" = "y" || "$udp" = "yes" || "$U_opt" = true ]]; } || { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]] && [[ "$stage" != "discovery-lists" && "$stage" != "services-udp" ]]; }; then
		# UDP open port discovery with masscan
		# Ensure nmap-service-probes exists to enable masscan payloads (required)
		if [[ "$PROBES_CHECKED" != true ]]; then
			if ! ensure_nmap_service_probes; then
				echo -e "\e[31m [X] nmap-service-probes is required for UDP discovery. Aborting.\e[0m" 1>&2
				exit 1
			fi
		fi
		nmap_payloads_opt="--nmap-payloads /usr/share/nmap/nmap-service-probes"
		udp_ports_list="U:7,U:53,U:69,U:5353,U:26198,U:53,U:5353,U:26198,U:67,U:69,U:80,U:111,U:111,U:2049,U:4045,U:32768-65535,U:123,U:123,U:135,U:1025-1199,U:137,U:137,U:137,U:161,U:260,U:3401,U:161,U:260,U:3401,U:177,U:389,U:427,U:443,U:853,U:3391,U:4433,U:4740,U:5349,U:5684,U:5868,U:6514,U:6636,U:8232,U:10161,U:10162,U:12346,U:12446,U:12546,U:12646,U:12746,U:12846,U:12946,U:13046,U:500,U:500,U:4500,U:520,U:623,U:623,U:626,U:1194,U:1194,U:1604,U:1645,U:1812,U:1701,U:1900,U:2049,U:2123,U:2152,U:3386,U:2302,U:3283,U:3478,U:6481,U:5351,U:5353,U:5353,U:5632,U:5683,U:7777,U:10001,U:10080,U:17185,U:17185,U:27910-27914,U:26000-26004,U:27960-27964,U:30720-30724,U:44400,U:64738,U:3784,U:4665,U:4666,U:4672,U:6429,U:8767,U:9987,U:9987,U:11211,U:27015-27030,U:27444,U:31337,U:34555,U:48899"
		mudpa="sudo masscan --open-only -p $udp_ports_list --rate=3000 $nmap_payloads_opt --excludefile $nostrikes --include-file $ips -oG $filepath/logs/processed/$typevar-discoscan-masscan-udp.txt"
		echo "mudpa=\"$mudpa\"" >> "$vars_file"
		# Engineer mode override
		if [[ "$resume" = "y" && -f "$(pwd)/paused.conf" ]]; then
			resume=''
			echo -e "\e[34m [-] Resuming UDP discovery scans -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			echo -e "\e[36m [i] Using options from resumed scan \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			masscan --resume paused.conf >> "$filepath/logs/processed/$typevar-masscan-udp.log" 2>&1 &
		else
			if [[ "$ngineer_mode" == true && "$ngineer_udpa_default" != true && -n "$z0eng_udpa_opts" ]]; then
				echo -e "\e[33m [!] Using z0e ngineer options for masscan UDP discovery scan \e[0m"
				eval "masscan $z0eng_udpa_opts --open-only $nmap_payloads_opt --excludefile $nostrikes --include-file $ips -oG $filepath/logs/processed/$typevar-discoscan-masscan-udp.txt" >> "$filepath/logs/$typevar-masscan-alivesPortsDiscovery-udp.log" 2>&1 &
			else
				eval "$mudpa" >> "$filepath/logs/$typevar-masscan-alivesPortsDiscovery-udp.log" 2>&1 &
			fi
		fi
		pid=$!
		# Ensure log exists and delay briefly so ETA is available
		touch "$filepath/logs/$typevar-masscan-alivesPortsDiscovery-udp.log"
		sleep 4
		masscaneta=""
		for _ in 1 2 3; do
			masscaneta=$(grep -so '[0-9]\+:[0-9]\+:[0-9]\+ remaining' "$filepath/logs/$typevar-masscan-alivesPortsDiscovery-udp.log" 2>/dev/null | tail -1)
			[ -n "$masscaneta" ] && break
			sleep 1
		done
		[ -z "$masscaneta" ] && masscaneta="" #if no ETA found, set to empty string, but can be modified to "ETA unavailable", etc.
		echo -ne "\e[34m [-] Discovering live hosts and open UDP ports with masscan... $masscaneta \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		echo ""
		# Status indicator
		periodicfile="$filepath/logs/$typevar-masscan-alivesPortsDiscovery-udp.log"
		contstatus="Scanning UDP ports"
		statusmasscan
		# Error check and alert
		checked_cmd="$mudpa"
		wait $pid
		exitstatus=$?
		errorcheck

		status_msg="[+] Discovering live hosts and open UDP ports with masscan... Done"
		if [[ "${z0e_masscan_periodic_printed:-false}" = true ]]; then
			echo -e "\e[32m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		else
			printf "\033[A\r\e[K\e[32m $status_msg \e[0m\n" | tee -a "$filepath/logs/$typevar-timestamps.log"
		fi
		ntfy "$status_msg"
		#Carve out UDP IP addresses and put them into a file
		if [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ]; then
			awk '
				NR==FNR { ips[$0]; next }
				{
					ip="";
					for (i=1; i<=NF; i++) {
						if ($i=="Host:" && (i+1)<=NF) { ip=$(i+1); break }
					}
					if (!(ip in ips)) print
				}
			' $filepath/$typevar-100port-hosts-tcp.txt $filepath/logs/processed/$typevar-discoscan-masscan-udp.txt > $filepath/logs/processed/$typevar-discoscan-masscan-udp-nosusips.txt #Filter out hosts with more than 100 open tcp ports
			awk '/open/ { for (i=1;i<=NF;i++) if ($i=="Host:" && (i+1)<=NF) { print $(i+1); break } }' $filepath/logs/processed/$typevar-discoscan-masscan-udp-nosusips.txt >> $filepath/logs/processed/$typevar-discoresults.txt
		else
			awk '/open/ { for (i=1;i<=NF;i++) if ($i=="Host:" && (i+1)<=NF) { print $(i+1); break } }' "$filepath/logs/processed/$typevar-discoscan-masscan-udp.txt" >> $filepath/logs/processed/$typevar-discoresults.txt
		fi

		#Stage -- update
		echo "discovery-lists" > "$stage_file"
		stage="discovery-lists"
	fi

	#Stage discovery-lists -- start
	if [[ "$stage" == "discovery-lists" ]]; then
		#Remove firewall rule
		if [[ "$only_flag" = true && "$stage_cont" != true ]]; then
			echo -e "\e[36m [i] Using prior discovery results to generate lists\e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		else
			if ! [[ "$udp" == "y" && "$only_flag" == true ]]; then
				removefirewallrule
			fi
		fi
		#Make final list of ordered, unique alive hosts excluding sus ips
		cat $filepath/logs/processed/$typevar-discoresults.txt | sort -u | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n >> $filepath/$typevar-aliveHosts.txt
		cp $filepath/$typevar-aliveHosts.txt $filepath/$typevar-alives-tmp.txt
		cat $filepath/$typevar-alives-tmp.txt | sort -u | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n > $filepath/$typevar-aliveHosts.txt
		rm $filepath/$typevar-alives-tmp.txt

		#Generate list of all open ports (always include TCP from prior discovery results if available)
		# TCP ports
			# Ensure temp file exists even if no TCP results are present
			: > "$filepath/rangetemp.txt"
			# IMPROVED PORT EXTRACTION: Parse all ports from each line instead of just the first one
			if [ -f "$filepath/logs/processed/$typevar-discoscan-masscan-tcp-nosusips.txt" ]; then
			awk '/open/ {
				# Find the position where "Ports:" part starts
				if (index($0, "Ports:") > 0) {
					# Get everything after "Ports:"
					ports_section = substr($0, index($0, "Ports:") + 7)
					# Split by comma+space to get individual port entries
					split(ports_section, port_entries, ", ")
					# Process each port entry
					for (i in port_entries) {
						# Extract just the port number from each entry
						split(port_entries[i], parts, "/")
						if (parts[2] == "open") {
							print parts[1]
						}
					}
				}
			}' $filepath/logs/processed/$typevar-discoscan-masscan-tcp-nosusips.txt | sort -u >> $filepath/rangetemp.txt
			fi
			rangeout="$filepath/logs/processed/$typevar-portsfornmap-tcp.txt"
			singleportstorange
			cat $filepath/logs/processed/$typevar-portsfornmap-tcp.txt > $filepath/$typevar-openPorts.txt
			sed -i 's/$/\/TCP/' "$filepath/$typevar-openPorts.txt"
		
		if [ "$udp" = "y" ] || [ "$udp" = "yes" ] || [ "$U_opt" = true ]; then
			# UDP ports (append to existing TCP ports if any)
			if [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ]; then
				awk '
				/open/ {
					line=$0;
					p=index(line, "Ports:");
					if (p>0) {
						ports_section=substr(line, p+7);
						n=split(ports_section, a, ", ");
						for (i=1; i<=n; i++) {
							split(a[i], parts, "/");
							if (parts[2]=="open" && tolower(parts[3])=="udp") print parts[1];
						}
					}
				}
				' $filepath/logs/processed/$typevar-discoscan-masscan-udp-nosusips.txt | sort -u >> $filepath/rangetempu.txt
			else
				awk '
				/open/ {
					line=$0;
					p=index(line, "Ports:");
					if (p>0) {
						ports_section=substr(line, p+7);
						n=split(ports_section, a, ", ");
						for (i=1; i<=n; i++) {
							split(a[i], parts, "/");
							if (parts[2]=="open" && tolower(parts[3])=="udp") print parts[1];
						}
					}
				}
				' $filepath/logs/processed/$typevar-discoscan-masscan-udp.txt | sort -u >> $filepath/rangetempu.txt
			fi
			# Merge UDP candidate ports into the main temp range file before converting to ranges
			sort -u $filepath/rangetempu.txt >> $filepath/rangetemp.txt
			rm $filepath/rangetempu.txt
			rangeout="$filepath/logs/processed/$typevar-portsfornmap-udp.txt"
			singleportstorange
			#sed -i '/^[ \t]*$/d' "$rangeout" #Removes blank lines and lines that only contain spaces
			cat $filepath/logs/processed/$typevar-portsfornmap-udp.txt >> $filepath/$typevar-openPorts.txt
			sed -i '/\/TCP$/! s/$/\/UDP/' "$filepath/$typevar-openPorts.txt"
		fi
		nessusports 2>/dev/null
		# Verify that the open ports file is not empty
		#if [[ ! -s "$filepath/$typevar-openPorts.txt" ]]; then
		#    echo -e "\e[33m [!] No open ports detected on discovered hosts -- exiting Zero-E... \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		#    z0ecleanup
		#	exit 1
		#fi

		#Status update
		alivesandportscheck
		if [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ] && [ -s "$filepath/$typevar-100port-hosts-udp.txt" ]; then
			echo -e "\e[33m [!] Excluding potential deception or firewall-protected hosts showing more than 100 open TCP/UDP ports -- recommend inquiring about hosts in $typevar-100port-hosts-tcp.txt and $typevar-100port-hosts-udp.txt \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		elif [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ]; then
			echo -e "\e[33m [!] Excluding potential deception or firewall-protected hosts showing more than 100 open TCP ports -- recommend inquiring about hosts in $typevar-100port-hosts-tcp.txt \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		elif [ -s "$filepath/$typevar-100port-hosts-udp.txt" ]; then
			echo -e "\e[33m [!] Excluding potential deception or firewall-protected hosts showing more than 100 open UDP ports -- recommend inquiring about hosts in $typevar-100port-hosts-udp.txt \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		fi
		echo -e "\e[36m [i] Generated files for Nessus vulnerability scans -- Hosts: $typevar-aliveHosts.txt | Ports: $typevar-portsForNessus.txt \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
	
		#Stage -- update
		if [[ "$only_flag" != true && "$stage_cont" == true ]]; then
			echo "services-tcp" > "$stage_file"
			stage="services-tcp"
		elif { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]] && [[ "$stage_cont" == true ]]; }; then
			echo "services-udp" > "$stage_file"
			stage="services-udp"
		fi
	
	fi

	#Stage -- start
	if [[ "$stage" == "services-tcp" ]]; then
		# Per-stage status log for services-tcp
		STATUS_LOG="$filepath/logs/processed/$typevar-status-services-tcp.log"; : > "$STATUS_LOG"
		#Nmap TCP service scans
		intscan="nmap -sC -sV -Pn -O -p $(cat $filepath/logs/processed/$typevar-portsfornmap-tcp.txt | paste -sd "," -) --open --reason -oA $filepath/$typevar-tcp-servicescan-results --excludefile $nostrikes -iL $filepath/$typevar-aliveHosts.txt"
		echo "intscan=\"$intscan\"" >> "$vars_file"
		if grep -q "\S" "$filepath/logs/processed/$typevar-portsfornmap-tcp.txt"; then
			# Grouped TCP service scans (default-on). If resuming, attempt grouped-resume when state exists
			z0e_grouped_done=false
			if [[ "${z0e_grouped_tcps_enabled:-true}" = true ]]; then
				if [[ "$resume" = "y" ]]; then
					if z0e_grouped_state_exists; then
						if run_grouped_tcp_services_scan; then
							status_msg="[+] Nmap TCP service scans complete, results saved as $typevar-tcp-servicescan-results -- $(date)"
							echo -e "\e[32m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
							ntfy "$status_msg"
							z0e_grouped_done=true
						else
							echo -e "\e[33m [!] Grouped TCP scans unavailable or failed; falling back to single-run \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
						fi
					fi
				else
					if run_grouped_tcp_services_scan; then
						status_msg="[+] Nmap TCP service scans complete, results saved as $typevar-tcp-servicescan-results -- $(date)"
						echo -e "\e[32m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
						ntfy "$status_msg"
						z0e_grouped_done=true
					else
						echo -e "\e[33m [!] Grouped TCP scans unavailable or failed; falling back to single-run \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
					fi
				fi
			fi
			if [[ "$z0e_grouped_done" != true ]]; then
				if [[ "$resume" = "y" ]]; then
					resume=''
					echo -e "\e[34m [-] Resuming TCP service scans \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
					echo -e "\e[36m [i] Using options from resumed scan \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
					execute_nmap_with_realtime_stats "nmap --resume $filepath/$typevar-tcp-servicescan-results.nmap" "1>/dev/null 2>>$filepath/logs/$typevar-errors.log"
				else
					if [[ "$ngineer_mode" == true ]]; then
						if [[ "$ngineer_tcps_default" == true ]]; then	
							execute_nmap_with_realtime_stats "$intscan -v" "1>/dev/null 2>>$filepath/logs/$typevar-errors.log"
						else
							echo -e "\e[33m [!] Using z0e ngineer options for Nmap TCP service scan \e[0m"
							execute_nmap_with_realtime_stats "nmap $z0eng_tcps_opts -sV -Pn -p $(cat $filepath/logs/processed/$typevar-portsfornmap-tcp.txt | paste -sd \",\" -) -oA $filepath/$typevar-tcp-servicescan-results --excludefile $nostrikes -iL $filepath/$typevar-aliveHosts.txt" "1>/dev/null 2>>$filepath/logs/$typevar-errors.log"
						fi
					else
						execute_nmap_with_realtime_stats "$intscan -v" "1>/dev/null 2>>$filepath/logs/$typevar-errors.log"
					fi
				fi
				pid=$!
				echo -e "\e[34m [-] Scanning services on open TCP ports of alive hosts with Nmap -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				#Status indicator
				# Read live status from the per-stage status log
				periodicfile="${STATUS_LOG:-$filepath/logs/$typevar-status.log}"
				contstatus="Scanning TCP ports"
				statusnmap
				#Error check and alert
				checked_cmd="$intscan"
				wait $pid
				exitstatus=$?
				printf "\r%-${#indicator}s\r" "" #Clears status indicator line
				if [ "$exitstatus" -eq 0 ]; then
					status_msg="[+] Nmap TCP service scans complete, results saved as $typevar-tcp-servicescan-results -- $(date)"
					echo -e "\e[32m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
					ntfy "$status_msg"
				else
					errorcheck
					if [ "$ntfy_flag" = true ]; then
						ntfy "[!] Nmap TCP service scan failed -- Check errors.log"
					fi
				fi
			fi
			genwindowshostlist_inscript
			listiptohostname_inscript
			parsegnmap_inscript=true
			parsegnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 139,445,137,138 "$filepath/analysis/$typevar-smbHosts.txt"
			parsegnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 80,443,8080,8443,8000,8008,8888 "$filepath/analysis/$typevar-httpHosts.txt"
			parsegnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 22,23,3389,5985,5986,5900,5800,1494,5631,5632 "$filepath/analysis/$typevar-remoteAccessHosts.txt"
			parsegnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 1723,1194 "$filepath/analysis/$typevar-vpnHosts.txt"
			parsegnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 20,21,22,69,111,873,990,2049,3260 "$filepath/analysis/$typevar-fileshareHosts.txt"
			parsegnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 3306,5432,1433,1521 "$filepath/analysis/$typevar-databaseHosts.txt"
			parsegnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 25,465,587,143,993,110,995 "$filepath/analysis/$typevar-emailHosts.txt"
			parsegnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 389,636 "$filepath/analysis/$typevar-ldapHosts.txt"
		else
			status_msg="[!] No open TCP ports detected -- TCP service scans skipped"
			echo -e "\e[33m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			ntfy "$status_msg"
		fi
	
		#Stage -- update
		if { [ "$udp" = "y" ] || [ "$udp" = "yes" ] || [ "$U_opt" = true ]; } && [[ "$stage_cont" == true ]]; then
			echo "services-udp" > "$stage_file"
			stage="services-udp"
		fi
	
	fi

	#Stage -- start
	if [[ "$stage" == "services-udp" ]] && [[ "$udp" = "y" || "$udp" = "yes" || "$U_opt" = true ]]; then
		# Per-stage status log for services-udp
		STATUS_LOG="$filepath/logs/processed/$typevar-status-services-udp.log"; : > "$STATUS_LOG"
		#Nmap UDP service scans
		nsudp="nmap -v -sU -Pn -sV --open --min-rate 1000 --max-rate 3000 --reason -p $(cat $filepath/logs/processed/$typevar-portsfornmap-udp.txt | paste -sd "," -) -oA $filepath/$typevar-udp-servicescan-results --excludefile $nostrikes -iL $filepath/$typevar-aliveHosts.txt"
		if grep -q "\S" "$filepath/logs/processed/$typevar-portsfornmap-udp.txt"; then
			if [[ "$resume" = "y" ]]; then
				resume=''
				echo -e "\e[34m [-] Resuming UDP service scans \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				echo -e "\e[36m [i] Using options from resumed scan \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				execute_nmap_with_realtime_stats "nmap --resume $filepath/$typevar-udp-servicescan-results.nmap" "1>/dev/null 2>>$filepath/logs/$typevar-errors.log"
			else
				if [[ "$ngineer_mode" == true ]]; then
					if [[ "$ngineer_udps_default" == true ]]; then	
						execute_nmap_with_realtime_stats "$nsudp" "1>/dev/null 2>>$filepath/logs/$typevar-errors.log"
					else
						echo -e "\e[33m [!] Using z0e ngineer options for Nmap UDP service scan \e[0m"
						execute_nmap_with_realtime_stats "nmap $z0eng_udps_opts -sU -sV -Pn --reason -p $(cat $filepath/logs/processed/$typevar-portsfornmap-udp.txt | paste -sd \",\" -) -oA $filepath/$typevar-udp-servicescan-results --excludefile $nostrikes -iL $filepath/$typevar-aliveHosts.txt" "1>/dev/null 2>>$filepath/logs/$typevar-errors.log"
					fi
				else
					execute_nmap_with_realtime_stats "$nsudp -v" "1>/dev/null 2>>$filepath/logs/$typevar-errors.log"
				fi
			fi
			pid=$!
			echo -e "\e[34m [-] Scanning services on open UDP ports of alive hosts with Nmap -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			#Status indicator
			# Read live status from the per-stage status log
			periodicfile="${STATUS_LOG:-$filepath/logs/$typevar-status.log}"
			contstatus="Scanning UDP ports"
			statusnmap
			#Error check and alert
			checked_cmd="nmap -v -sU -Pn -sV --open --min-rate 1000 --max-rate 3000 --reason -p $(cat $filepath/logs/processed/$typevar-portsfornmap-udp.txt | paste -sd "," -) -oA $filepath/$typevar-udp-servicescan-results --excludefile $nostrikes -iL $filepath/$typevar-aliveHosts.txt"
			wait $pid
			exitstatus=$?
			printf "\r%-${#indicator}s\r" "" #Clears status indicator line
			if [ "$exitstatus" -eq 0 ]; then
				status_msg="[+] Nmap UDP service scans complete, results saved as $typevar-udp-servicescan-results -- $(date)"
				echo -e "\e[32m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				ntfy "$status_msg"
			else
				errorcheck
				if [ "$ntfy_flag" = true ]; then
					ntfy "[!] Nmap UDP service scan failed -- Check errors.log"
				fi
			fi

			genwindowshostlist_inscript
			listiptohostname_inscript
		else
			status_msg="[!] No open UDP ports detected -- UDP service scans skipped"
			echo -e "\e[33m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			ntfy "$status_msg"
		fi
	fi

	#fi
	if [[ "$firewallset" = true ]]; then
		removefirewallrule
	fi
	status_msg="[=] Zero-E completed -- happy hacking!"
	echo -e "\e[35m $status_msg \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
	ntfy "$status_msg"
	z0ecleanup
fi
