#!/usr/bin/env bash
version="Zero-E (ZrE) v1.2 by @Inscyght"
###Functions
function updatecheck { #Check version and update the script
	{	
		URL="https://raw.githubusercontent.com/inscyght/zero-e/main/zero-e"
    	#Function to get the latest version string from the script on GitHub
    	get_latest_version() {
    	    curl -s $URL | grep -m 1 '^version=' | awk -F'"' '{print $2}'
    	}
    	#Function to update the script
    	update_script() {
    	    curl -o zero-e $URL
    	    chmod +x zero-e
    	}
    	latest_version=$(get_latest_version)
    	if [ "$version" != "$latest_version" ]; then
    	    echo "A new version of Zero-E is available: $latest_version"
    	    read -p "Do you want to update to the latest version? <y/n>: " response
    	    if [ "$response" == "y" ]; then
    	        echo ""
				echo "Updating..."
    	        update_script
				echo ""
    	        echo "Zero-E updated to version $latest_version -- please re-run ZrE"
    	        exit 0
    	    else
    	        echo "Continuing with the local version"
				echo ""
    	    fi
    	fi

		# Check if script is named 'zero-e.sh' and rename
		script_name=$(basename "$0")
		if [ "$script_name" = "zero-e.sh" ]; then
		    echo "ZrE's script file renamed to zero-e in v1.1"
		    mv "$0" "$(dirname "$0")/zero-e"
		    echo "Local ZrE file renamed to 'zero-e'; please re-run"
		    exit 0
		fi
	} >&2
}

function settype { #Set external or internal
	if [ "$e_opt" = true ] || [ "$i_opt" = true ]; then
		if [ "$e_opt" = true ]; then
			typevar="ext"
			i_opt=false
		elif [ "$i_opt" = true ]; then
			typevar="int"
			e_opt=false
		fi
	else
		echo "[?] Are you performing an <e>xternal or <i>nternal scan?"
		while true; do
			read -e -p " [>] " type
			if [ "$type" = "E" ] || [ "$type" = "e" ] || [ "$type" = "external" ] || [ "$type" = "External" ] || [ "$type" = "Ext" ] || [ "$type" = "ext" ]; then
				typevar="ext"
				e_opt=true
				break
			elif [ "$type" = "I" ] || [ "$type" = "i" ] || [ "$type" = "internal" ] || [ "$type" = "Internal" ] || [ "$type" = "Int" ] || [ "$type" = "int" ]; then
				typevar="int"
				i_opt=true
				break
			else
				echo -e "\e[31m [X] Error: You must enter 'e' for external or 'i' for internal \e[0m" >&2
			fi
		done
	fi
}

function output { #sets the output dir
	if [ -z "$o_opt" ] && [ "$defaults" = true ]; then
		filepath="./zre-output"
	elif [ -n "$o_opt" ]; then
		filepath="$o_opt"
	else
		echo "[?] Enter the output directory path:"
		while true; do
			read -e -p " [>] " filepath
			if [ -f "$filepath" ]; then
				echo -e "\e[31m [X] Error: File exists with the same name \e[0m" >&2
			elif [ -z "$filepath" ]; then
				echo -e "\e[31m [X] Error: You must enter a directory name or path \e[0m" >&2
			elif [[ "$filepath" == "-"* ]]; then
				echo -e "\e[31m [X] Error: Directory names starting with '-' may cause issues with commands \e[0m" >&2
			elif [[ "$filepath" == *" "* ]]; then
				echo -e "\e[31m [X] Error: To proactively avoid errors, whitespace is not allowed in file names \e[0m" >&2
			elif [ -n "$filepath" ]; then
				break
			fi
		done
	fi
	if [ "$filepath" = "." ]; then
		filepath=$(pwd)
	elif [ "$filepath" = "~" ]; then
		filepath="/home/$SUDO_USER"
	elif [[ "$filepath" = '~/'* ]]; then
		filepath=${filepath/#\~/"/home/$SUDO_USER"}
		if [ ! -d "$filepath" ];then
			mkdir -p "$filepath"
		fi
	else
		if [ ! -d "$filepath" ];then
			mkdir -p "$filepath"
		fi
	fi

	###Create backup of output dir if scans have already ran
    local shouldBackup=false
    # Check for specific files in the $filepath and $filepath/reporting directories
    if [ "$typevar" = "ext" ] && [ "$(find $filepath -maxdepth 1 -type f \( -name 'ext-*' \) 2>/dev/null)" ]; then
        shouldBackup=true
    elif [ "$typevar" = "int" ] && [ "$(find $filepath -maxdepth 1 -type f \( -name 'int-*' \) 2>/dev/null)" ]; then
        shouldBackup=true
    fi
    # Proceed with backup if necessary
    if [ "$shouldBackup" = true ]; then
        # The directory contains specific files indicating significant script activity,
        # find the next available ZrEscan#.bak name for backup
        local baseDir=$(dirname "$filepath")
        local name=$(basename "$filepath")
        local prefix="${name}-ZrE"
        local suffix=".bak"
        local idx=1
        while true; do
            if [ ! -d "$baseDir/$prefix$idx$suffix" ]; then
                break
            fi
            ((idx++))
        done
        local newDir="$baseDir/$prefix$idx$suffix"
        echo "     ZrE results files detected in output directory -- backing up '$filepath' to '$newDir'"
        cp -r "$filepath" "$newDir"
    fi

	#Remove old files if they exist in the output dir and choosing fresh start
	if { [ "$stage" = "script-start" ] && [ "$resume" != "y" ]; } || \
	   { [ -f "$filepath/logs/misc-files/targets-file.zre" ] && [ "$(realpath "$t_opt")" != "$(cat "$filepath/logs/misc-files/targets-file.zre")" ]; }; then
	    find "$filepath" -type f -name "${typevar}-*" -exec rm -f {} +
	fi

	mkdir -p $filepath/logs/
	mkdir -p $filepath/logs/misc-files/
	#mkdir -p $filepath/reporting/
	mkdir -p $filepath/analysis/

	o_opt="$(realpath $filepath)"
	filepath="$(realpath $filepath)"
}

function targets {	#Sets the targets file
	if [[ -z "$t_opt" && "$defaults" = true ]]; then
		ips="targets.txt"
		if [[ ! -f "$ips" ]]; then
			echo -e "\e[31m [X] Error: The default targets file (./targets.txt) does not exist \e[0m" >&2
			exit 1
		elif [ ! -s "$ips" ]; then #Check if the file is empty
        	echo -e "\e[31m [X] Error: $ips is empty \e[0m" >&2
			exit 1
		fi
		checkfile="$ips"
		checkinvalidips #Check targets file for invalid entries
	elif [ -n "$t_opt" ]; then
		if [[ "$t_opt" == "-"* ]]; then
			echo -e "\e[31m [X] Error: File names starting with '-' may cause issues with commands \e[0m" >&2
			exit 1
		elif [[ "$t_opt" == *" "* ]]; then
			echo -e "\e[31m [X] Error: To proactively avoid errors, whitespace is not allowed in file names \e[0m" >&2
			exit 1
		elif [ ! -s "$t_opt" ]; then #Check if the file is empty
        	echo -e "\e[31m [X] Error: $t_opt is empty \e[0m" >&2
			exit 1
		fi
		ips="$t_opt"
		checkfile="$ips"
		checkinvalidips #Check targets file for invalid entries
	else
		echo "[?] Enter the target IP addresses file -- each single IP, range, or CIDR must be on a new line: "
		while true; do
			read -e -p " [>] " ips
			if [[ -z "$ips" ]] || [[ ! -f "$ips" ]]; then
				echo -e "\e[31m [X] Error: You must pass an existing file containing the IP addresses (e.g. targets.txt) \e[0m" >&2
			elif [ ! -s "$ips" ]; then #Check if the file is empty
        		echo -e "\e[31m [X] Error: $ips is empty \e[0m" >&2
			else
				if [[ "$ips" == "-"* ]]; then
					echo -e "\e[31m [X] Error: File names starting with '-' may cause issues with commands \e[0m" >&2
				elif [[ "$ips" == *" "* ]]; then
					echo -e "\e[31m [X] Error: To proactively avoid errors, whitespace is not allowed in file names \e[0m" >&2
				else
					checkfile="$ips"
					checkinvalidips #Check targets file for invalid entries
					if [[ $allvalid = 1 ]]; then
						t_opt="$ips"
						break
					fi
				fi
			fi
		done
	fi

	t_opt="$(realpath $ips)"
	ips="$(realpath $ips)"
	ips_log=$ips
	echo "$ips_log" > $filepath/logs/misc-files/targets-file.zre
	echo -ne "     Generating temporary list of single IP addresses for targets..."
	geniplist "$ips" > /tmp/zeroe/targets-single-ips.zre
	echo -e "\r     Generating temporary list of single IP addresses for targets... Done"
	ips="/tmp/zeroe/targets-single-ips.zre"
	t_opt="/tmp/zeroe/targets-single-ips.zre"
}

function excludes { #Sets the excludes file
	if [ -z "$x_opt" ] && [ "$defaults" = true ]; then
		mkdir -p /tmp/zeroe
		touch /tmp/zeroe/nullexcludes.zre
		nostrikes="/tmp/zeroe/nullexcludes.zre"
	elif [ -n "$x_opt" ]; then
		if [[ "$x_opt" == "-"* ]]; then
			echo -e "\e[31m [X] Error: File names starting with '-' may cause issues with commands \e[0m" >&2
			exit 1
		elif [[ "$x_opt" == *" "* ]]; then
			echo -e "\e[31m [X] Error: To proactively avoid errors, whitespace is not allowed in file names \e[0m" >&2
			exit 1
		elif [ ! -s "$x_opt" ] && [ "$x_opt_provided" = "y" ]; then #Check if the file is empty
        	echo -e "\\e[31m [X] Error: $x_opt is empty \\e[0m" >&2
			exit 1
		fi
		nostrikes="$x_opt"
		checkfile="$nostrikes"
		checkinvalidips #Check excludes file for invalid entries
	else
		echo "[?] Enter the excluded IP addresses file -- if none, press <enter>: "
		while true; do
			read -e -p " [>] " nostrikes
			if [[ -z "$nostrikes" ]]; then
				mkdir -p /tmp/zeroe
				touch /tmp/zeroe/nullexcludes.zre
				nostrikes="/tmp/zeroe/nullexcludes.zre"
				break
			elif [[ ! -f "$nostrikes" ]]; then
				echo -e "\e[31m [X] Error: You must pass an existing file containing the list of IP addresses to exclude (e.g. exclude.txt) \e[0m" >&2
			elif [ ! -s "$nostrikes" ]; then #Check if the file is empty
        		echo -e "\\e[31m [X] Error: $nostrikes is empty \\e[0m" >&2
			else
				if [[ "$nostrikes" == "-"* ]]; then
					echo -e "\e[31m [X] Error: File names starting with '-' may cause issues with commands \e[0m" >&2
				elif [[ "$nostrikes" == *" "* ]]; then
					echo -e "\e[31m [X] Error: To proactively avoid errors, whitespace is not allowed in file names \e[0m" >&2
				else
					checkfile="$nostrikes"
					checkinvalidips #Check targets file for invalid entries
					if [[ $allvalid = 1 ]]; then
						x_opt="$nostrikes"
						break
					fi
				fi
			fi
		done
	fi

	if [[ $nostrikes != "/tmp/zeroe/nullexcludes.zre" ]]; then
		x_opt="$(realpath $nostrikes)"
		nostrikes="$(realpath $nostrikes)"
		echo -ne "     Generating temporary list of single IP addresses for excludes..."
		geniplist "$nostrikes" > /tmp/zeroe/excludes-single-ips.zre
		echo -e "\r     Generating temporary list of single IP addresses for excludes... Done"
		nostrikes="/tmp/zeroe/excludes-single-ips.zre"
		x_opt="/tmp/zeroe/excludes-single-ips.zre"
	fi
}

function enableudp { #Enables UDP scans
	if [[ "$u_opt" = false && "$U_opt" = false && "$defaults" = true ]]; then
		udp="y"
		U_opt=true
	elif [ "$U_opt" = true ]; then
		udp="y"
	elif [ "$u_opt" = true ]; then
		udp="n"
	else
		echo "[?] Enable UDP scans? <y/n>"
		while true; do
			read -e -p " [>] " udp
				if [ "$udp" = "y" ] || [ "$udp" = "yes" ] || [ "$udp" = "n" ] || [ "$udp" = "no" ]; then
					break
				else
					echo -e "\e[31m [X] Error: You must enter 'y', 'yes', 'n', or 'no' \e[0m" >&2
				fi
		done
		if [ "$udp" = "y" ] || [ "$udp" = "yes" ]; then
			U_opt=true
			u_opt=false
		elif [ "$udp" = "n" ] || [ "$udp" = "no" ]; then
			U_opt=false
			u_opt=true
		fi
	fi

	if [[ "$u_opt" = true || "$udp" = "n" ]] && [[ "$S_opt" = *"udp" || "$stage" = *"udp" ]]; then #If UDP scans are disabled, but UDP stage is selected
		echo -e "\e[31m [X] Error: A UDP stage cannot be selected if UDP scans are disabled \e[0m" >&2
		exit 1
	fi

	if [[ "$only_flag" == true ]] && ([[ "$U_opt" == true ]] || [[ "$udp" == "y" ]]) && [[ "$S_opt" != *"udp"* && "$stage" != *"udp"* ]] && [[ "$stage" != "script-start" && "$stage" != "discovery-lists" ]]; then #If only UDP scans are enabled, but TCP stage is selected
		echo -e "\e[31m [X] Error: A TCP stage cannot be selected if only UDP scans are enabled \e[0m" >&2
		exit 1
	fi
}	

function filtersusips { #filters out IPs that may be deception hosts
    #Use awk to count the occurrences of each IP and print those with <= 100 entries to the output file
    #[ -e "$susips" ] && rm "$susips" #2>>"$filepath/logs/$typevar-errors.log"
    #[ -e "$susoutput" ] && rm "$susoutput" #2>>"$filepath/logs/$typevar-errors.log"
    awk '
    {
        ip[$4]++;
    }
    END {
        for (i in ip) {
            if (ip[i] > 100) {
                print i >> "'"$susips"'";
                sus_ips[i] = 1;
            }
        }
    }' "$susinput" 2>>"$filepath/logs/$typevar-errors.log"
    #Check if sus_ips.txt exists before trying to read it
    if [ -f "$susips" ]; then
        #Then filter out the sus IPs from the input file
        awk 'FNR==NR {sus_ips[$0]=1; next} !($4 in sus_ips)' "$susips" "$susinput" >> "$susoutput" 2>>"$filepath/logs/$typevar-errors.log"
    else
        cat "$susinput" >> "$susoutput" 2>>"$filepath/logs/$typevar-errors.log"
    fi
}

function singleportstorange { #Converts individual sequential port numbers into a range
	awk '
	BEGIN{start=end=""}
	{
	    if(start == ""){
	        start=end=$1;
	    }
	    else if($1 == end+1){
	        end=$1;
	    }
	    else{
	        if(start == end)
	            print start;
	        else
	            print start"-"end;
	        start=end=$1;
	    }
	}
	END{
	    if(start == end)
	        print start;
	    else
	        print start"-"end;
	}' <(sort -n "$filepath/rangetemp.txt") >> $rangeout
	rm "$filepath/rangetemp.txt"
	#sed -i '/^[ \t]*$/d' "$checkfile" #cant remember why i had $checkfiles here. its only ever set to $ips and $nostrikes
	sed -i '/^[ \t]*$/d' "$rangeout" #Removes blank lines and lines that only contain spaces
	sort -u -o "$rangeout" "$rangeout"
}

function checkinvalidips { #Checks targets file for invalid entries
	dos2unix -q "$checkfile" #Converts target files created on Windows to unix format to remove hidden characters
	sed -i '/^[ \t]*$/d' "$checkfile" #Removes blank lines and lines that only contain spaces
	sed -i 's/^[[:space:]]*//; s/[[:space:]]*$//' "$checkfile" #Removes whitespace from the beginning and end of each line

	#Regex pattern to match single IPv4 addresses
	ip_single='^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$'
	#Regex pattern to match full IPv4 address ranges
	ip_range_full='^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])-(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$'
	#Regex pattern to match IPv4 CIDR notations
	ip_cidr='^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\/([0-9]|[1-2][0-9]|3[0-2])$'
	#Regex pattern to match IPv4 address ranges that cannot be parsed by masscan
	ip_range_anyoct='^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)-(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)-(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)-(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])-(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'

	#Read file line by line, checking for invalid entries
	anyinvalid=0
	while IFS= read -r line || [[ -n "$line" ]]; do #Condition after the || ensures last line of file is checked even if it's not a newline
		if [[ $line =~ $ip_single ]]  || [[ $line =~ $ip_cidr ]] || [[ $line =~ $ip_range_full ]]; then
			:
		elif [[ $line =~ $ip_range_anyoct ]]; then
			#echo -e "\e[31m [X] Error: $ips contains an entry that masscan cannot parse -- $line \e[0m"
			echo -e "\e[31m [X] Error: $checkfile contains an improperly formatted range -- $line \e[0m" >&2
			echo -e "\e[31m            IP address ranges must be in the format x.x.x.x-y.y.y.y \e[0m" >&2
			anyinvalid=1
		elif [ ! -s "$checkfile" ];then 
			echo -e "\e[31m [X] Error: $checkfile is empty \e[0m" >&2
		else
			echo -e "\e[31m [X] Error: $checkfile contains an invalid entry -- $line \e[0m" >&2
			anyinvalid=1
		fi
	done <"$checkfile"

	if [ $anyinvalid -ne 0 ]; then
		allvalid=0
		if [[ -z "$t_opt" && "$defaults" = true ]] || [ -n "$t_opt" ]  || [ -n "$x_opt" ] || [[ "$countopt" == "y" ]] || [[ "$geniplistopt" == "y" ]]; then
			exit 1
		fi
	else
  		allvalid=1
	fi
}

function stageinit { #The checkpoint system
	mkdir -p /tmp/zeroe

	function checkinvalidstage { #Defines the function to check for invalid stage
		if [[ "$stage" = "script-start" || "$stage" = "discovery-ports" || "$stage" = "discovery-alives" || "$stage" = "discovery-udp" || "$stage" = "discovery-lists" || "$stage" = "services-tcp" || "$stage" = "services-udp" ]]; then
			return 0
		else	
			echo -e "\e[31m [X] Error: Invalid stage '$stage' -- check help or README for valid stages \e[0m" >&2
			return 1
		fi
	}

	if [[ "$s_opt" = false && "$S_opt" = "disabled" && "$defaults" = true ]]; then #If only using --defaults option
		#echo "script-start" > /tmp/zeroe/stage.zre
		stage="script-start"
		echo "$(pwd)" > /tmp/zeroe/initdir.zre
		stage_cont=true
		only_flag=false
	elif [[ "$s_opt" = true ]]; then #If stage disabled
		#echo "script-start" > /tmp/zeroe/stage.zre
		stage="script-start"
		echo "$(pwd)" > /tmp/zeroe/initdir.zre
		stage_cont=true
		#only_flag=false
	elif [[ ! -f "/tmp/zeroe/stage.zre" && "$S_opt" = "disabled" ]] || [[ -f "/tmp/zeroe/stage.zre" && "$(cat /tmp/zeroe/stage.zre)" = "script-start" ]]; then #If the stage file does not exist and stage option is disabled OR stage file exists and saved stage is script-start
		echo "[?] Start a new scan <y>, or start from a specific stage? -- see README or --help for stage options"
		while true; do
			read -e -p " [>] " stage
			if [[ "$stage" = "y" ]]; then
				#echo "script-start" > /tmp/zeroe/stage.zre
				stage="script-start"
				echo "$(pwd)" > /tmp/zeroe/initdir.zre
				stage_cont=true
				#only_flag=false
				break
			else
				#echo "$stage" > /tmp/zeroe/stage.zre
				echo "$(pwd)" > /tmp/zeroe/initdir.zre
				if checkinvalidstage; then
					if [[ "$only_flag" = false ]]; then
						stage_cont=true
					fi
					break
				fi
			fi
		done
	elif [ -f "/tmp/zeroe/stage.zre" ] && [[ -z "$S_opt" ]]; then #Load stage if it exists and resume stage option is enabled
	  	stage=$(cat /tmp/zeroe/stage.zre)
		resume="y"
	elif [[ ! -f "/tmp/zeroe/stage.zre" ]] && [[ -z "$S_opt" ]]; then #If the stage file does not exist and resume stage option is enabled
		echo -e "\e[31m [X] Error: No saved stage exists \e[0m" >&2
		echo "[?] Start a new scan <y>, or start from a specific stage? -- see README or --help for stage options"
		while true; do
			read -e -p " [>] " stage
				if [[ "$stage" = "y" ]]; then
					#echo "script-start" > /tmp/zeroe/stage.zre
					stage="script-start"
					echo "$(pwd)" > /tmp/zeroe/initdir.zre
					stage_cont=true
					#only_flag=false
					break
				else
					#echo "$stage" > /tmp/zeroe/stage.zre
					echo "$(pwd)" > /tmp/zeroe/initdir.zre
					if checkinvalidstage; then
						if [[ "$only_flag" != true ]]; then
							stage_cont=true
						fi
						break
					fi
				fi
		done
	elif [ -f "/tmp/zeroe/stage.zre" ] && [[ "$S_opt" = "disabled" ]] && [[ "$(cat /tmp/zeroe/stage.zre)" != "script-start" ]] && [[ -f "/tmp/zeroe/stage.zre" ]]; then #If the stage file exists and the stage option is disabled and saved stage is not script-start
		echo "[?] Resume from '$(cat /tmp/zeroe/stage.zre)' <y/n>, or start from a specific stage? -- see README or --help for stage options"
		while true; do
			read -e -p " [>] " stage
			if [[ "$stage" != "script-start" && "$stage" != "discovery-ports" && "$stage" != "discovery-alives" && "$stage" != "discovery-udp" && "$stage" != "discovery-lists" && "$stage" != "services-tcp" && "$stage" != "services-udp" && "$stage" != "y" && "$stage" != "n" ]]; then #  && "$stage" != "methodology"
				echo -e "\e[31m [X] Error: Invalid stage '$stage' -- check help or README for valid stages \e[0m" >&2
			elif [[ "$stage" = "n" ]]; then
				stage="script-start"
				#echo "script-start" > /tmp/zeroe/stage.zre
				echo "$(pwd)" > /tmp/zeroe/initdir.zre
				stage_cont=true
				break
			elif [[ "$stage" = "y" ]]; then
				resume="y"
				stage=$(cat /tmp/zeroe/stage.zre)
				#echo "$stage" > /tmp/zeroe/stage.zre
				break
			else #Specifying a stage
				#echo "$stage" > /tmp/zeroe/stage.zre
				if checkinvalidstage; then
					echo "$(pwd)" > /tmp/zeroe/initdir.zre
					if [[ "$only_flag" == true && "$stage" == "discovery-udp" ]]; then
						stage_cont=false
					elif [[ "$only_flag" != true ]]; then
						stage_cont=true
					fi
					break
				fi
			fi
		done
	elif [ -n "$S_opt" ]; then #Start at the specified stage
		if [[ "$S_opt" = "script-start" || "$S_opt" = "discovery-ports" || "$S_opt" = "discovery-alives" || "$S_opt" = "discovery-udp" || "$S_opt" = "discovery-lists" || "$S_opt" = "services-tcp" || "$S_opt" = "services-udp" ]]; then #  || "$S_opt" = "methodology"
			stage="$S_opt"
			#echo "$stage" > /tmp/zeroe/stage.zre
			echo "$(pwd)" > /tmp/zeroe/initdir.zre
			if [[ "$only_flag" == true && "$S_opt" == "discovery-udp" ]]; then
				stage_cont=false
			elif [[ "$only_flag" != true ]]; then
				stage_cont=true
			fi
		else
			echo -e "\e[31m [X] Error: Invalid stage '$S_opt' -- check help or README for valid stages \e[0m" >&2
			exit 1
		fi
	fi
}

function stagefilescheck { #Checks if required files are present for the specified stage
    local missing_files=()

    function checkstagefiles {
        for file in "$@"; do
            if [ ! -f "$file" ]; then
                missing_files+=("$file")
            fi
        done
    }
	#Defines required files for each stage
	if [[ "$e_opt" = true || "$type" = "E" || "$type" = "e" || "$type" = "external" || "$type" = "External" || "$type" = "Ext" || "$type" = "ext" ]]; then
    	case "$stage" in
    		"discovery-alives")
    			checkstagefiles "$nostrikes" "$ips"
    			;;
    		"discovery-ports")
    			checkstagefiles "$nostrikes" "$ips"
    			;;
    		"discovery-udp")
    			checkstagefiles "$nostrikes" "$ips"
    			;;
    		"discovery-lists")
    			# Check for $filepath/$typevar-alives.txt
    			checkstagefiles "$filepath/logs/misc-files/$typevar-discoresults.txt"
    			if ! { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]]; }; then
    			    # Check for $filepath/$typevar-openPorts.txt and $filepath/logs/misc-files/$typevar-portsfornmap-tcp.txt
    			    checkstagefiles  "$filepath/logs/misc-files/$typevar-discoscan-masscan-tcp-nosusips.txt"
    			fi
    			if [[ "$udp" = "y" || "$udp" = "yes" || "$U_opt" = true ]]; then
    			    if [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ]; then
    			        # Check for $filepath/logs/misc-files/$typevar-discoscan-nmap-udp-nosusips.txt and $filepath/logs/misc-files/$typevar-portsfornmap-udp.txt
    			        checkstagefiles "$filepath/logs/misc-files/$typevar-discoscan-nmap-udp-nosusips.txt"
    			    else
    			        # Check for $filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap and $filepath/logs/misc-files/$typevar-portsfornmap-udp.txt
    			        checkstagefiles "$filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap"
    			    fi
    			fi
    			;;
    		"services-tcp")
    			checkstagefiles "$nostrikes" "$filepath/$typevar-alives.txt" "$filepath/logs/misc-files/$typevar-portsfornmap-tcp.txt"
    			;;
    		"services-udp")
    			checkstagefiles "$nostrikes" "$filepath/$typevar-alives.txt" "$filepath/logs/misc-files/$typevar-portsfornmap-udp.txt"
    			;;
    		#"methodology")
    		#	checkstagefiles "$ips" "$filepath/logs/misc-files/$typevar-discoscan-masscan-tcp.txt" "$filepath/$typevar-tcp-servicescan-results.nmap" "$filepath/$typevar-alives.txt"
    		#	;;
    	esac
  	elif [[ "$i_opt" = true || "$type" = "I" || "$type" = "i" || "$type" = "internal" || "$type" = "Internal" || "$type" = "Int" || "$type" = "int" ]]; then
    	case "$stage" in
    		"discovery-alives")
    			checkstagefiles "$nostrikes" "$ips"
    			;;
    		"discovery-ports")
    			checkstagefiles "$nostrikes" "$filepath/$typevar-alives.txt"
    			;;
    		"discovery-udp")
    			if [ -f "$filepath/logs/misc-files/$typevar-discoresults.txt" ]; then
    				checkstagefiles "$nostrikes" "$filepath/logs/misc-files/$typevar-discoresults.txt"
    			else
    				checkstagefiles "$nostrikes" "$ips"
    			fi
    			;;
    		"discovery-lists")
    			# Check for $filepath/$typevar-alives.txt
    			checkstagefiles "$filepath/logs/misc-files/$typevar-discoresults.txt"
    			if ! { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]]; }; then
    			    # Check for $filepath/$typevar-openPorts.txt and $filepath/logs/misc-files/$typevar-portsfornmap-tcp.txt
    			    checkstagefiles  "$filepath/logs/misc-files/$typevar-discoscan-masscan-tcp-nosusips.txt"
    			fi
    			if [[ "$udp" = "y" || "$udp" = "yes" || "$U_opt" = true ]]; then
    			    if [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ]; then
    			        # Check for $filepath/logs/misc-files/$typevar-discoscan-nmap-udp-nosusips.txt and $filepath/logs/misc-files/$typevar-portsfornmap-udp.txt
    			        checkstagefiles "$filepath/logs/misc-files/$typevar-discoscan-nmap-udp-nosusips.txt"
    			    else
    			        # Check for $filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap and $filepath/logs/misc-files/$typevar-portsfornmap-udp.txt
    			        checkstagefiles "$filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap"
    			    fi
    			fi
    			;;
    		"services-tcp")
    			checkstagefiles "$nostrikes" "$filepath/$typevar-alives.txt" "$filepath/logs/misc-files/$typevar-portsfornmap-tcp.txt"
    			;;
    		"services-udp")
    			checkstagefiles "$nostrikes" "$filepath/$typevar-alives.txt" "$filepath/logs/misc-files/$typevar-portsfornmap-udp.txt"
    			;;
    		#"methodology")
    		#	checkstagefiles "$ips" "$filepath/logs/misc-files/$typevar-discoresults.txt" "$filepath/logs/misc-files/$typevar-discoscan-masscan-tcp.txt" "$filepath/$typevar-tcp-servicescan-results.nmap" "$filepath/$typevar-alives.txt"
    		#	;;
    	esac
  	fi
	if [ ${#missing_files[@]} -ne 0 ]; then
        #echo -e "\e[31m [X] Error: The following required files are missing for the '$stage' stage:"
        #for file in "${missing_files[@]}"; do
        #    echo -e "  - $file"
        #done
		if [[ -f /tmp/zeroe/stage.zre ]]; then
        	echo -e "\e[31m [X] Error: Required ZrE files for $stage stage do not exist" >&2
			#echo -e " 		     Required files: ${missing_files[@]}" >&2
			echo -e "            Resume ZrE from the saved $(cat /tmp/zeroe/stage.zre) stage, run preceding stage, or restart ZrE \e[0m" >&2
        	exit 1
		else
			echo -e "\e[31m [X] Error: Required ZrE files for $stage stage do not exist" >&2
			#echo -e " 		     Required files: ${missing_files[@]}" >&2
			echo -e "            Correct output directory if repeating stage, run preceding stage, or restart ZrE \e[0m" >&2
        	exit 1
		fi
    fi
}

function nessusports { #Formats open ports as Nessus-compatible for easy copy/pasting
	rm $filepath/$typevar-portsForNessus.txt #Prevents duplicate entries
	#Outputs TCP ports in Nessus-compatible format (T:#,)
	awk '{printf "T:%s,", $0}' $filepath/logs/misc-files/$typevar-portsfornmap-tcp.txt | sed 's/,$/\n/' >> $filepath/$typevar-portsForNessus.txt
	if grep -q "\S" "$filepath/logs/misc-files/$typevar-portsfornmap-udp.txt"; then
		#Outputs UDP ports in Nessus-compatible format (U:#,)
		awk '{printf "U:%s,", $0}' $filepath/logs/misc-files/$typevar-portsfornmap-udp.txt | sed 's/,$/\n/' >> $filepath/$typevar-portsForNessus.txt
		#Joins TCP and UDP ports into single line
		sed -i -z 's/\n/,/' $filepath/$typevar-portsForNessus.txt
	fi
}

function genwindowshostlist {
    local inputfile="$1"
    local outputfile="$2"

    # Check if inputfile is provided and exists
    if [[ -z "$inputfile" ]]; then
        echo -e "\e[31m [X] Error: Invalid syntax -- Usage: --listwinhosts <StandardNmapFile> [OutputFile]" >&2
        return 1
	elif [[ ! -f "$inputfile" ]]; then
		echo -e "\e[31m [X] Error: File '$inputfile' does not exist \e[0m" >&2
		return 1
	fi

    # awk command to parse Windows hosts
    if [[ -n "$outputfile" ]]; then
        awk '
        /Nmap scan report for/ {
            line = $0
            ip = "Unknown IP"

            # Check if line contains "("
            if (index(line, "(") > 0) {
                # IP is between "(" and ")"
                start = index(line, "(") + 1
                end = index(line, ")") - 1
                ip = substr(line, start, end - start + 1)
            } else {
                # IP is after "Nmap scan report for "
                prefix = "Nmap scan report for "
                start = index(line, prefix)
                if (start > 0) {
                    ip = substr(line, start + length(prefix))
                }
            }
        }
        /OS:.*[Ww]indows/ {
            print ip
        }
        ' "$inputfile" | sort -u > "$outputfile"
    else
        awk '
        /Nmap scan report for/ {
            line = $0
            ip = "Unknown IP"

            # Check if line contains "("
            if (index(line, "(") > 0) {
                # IP is between "(" and ")"
                start = index(line, "(") + 1
                end = index(line, ")") - 1
                ip = substr(line, start, end - start + 1)
            } else {
                # IP is after "Nmap scan report for "
                prefix = "Nmap scan report for "
                start = index(line, prefix)
                if (start > 0) {
                    ip = substr(line, start + length(prefix))
                }
            }
        }
        /OS:.*[Ww]indows/ {
            print ip
        }
        ' "$inputfile" | sort -u
    fi
}

function genwindowshostlist_inscript { #For genwinhostlist when ran inside the script
    if [[ "$stage" == "services-tcp" ]]; then
        resultsfile="$filepath/$typevar-tcp-servicescan-results.nmap"
        outputfile="$filepath/logs/misc-files/$typevar-windowshoststcp.txt"
        genwindowshostlist "$resultsfile" >> "$outputfile"
    elif [[ "$stage" == "services-udp" ]] && [[ "$udp" == "y" || "$udp" == "yes" || "$U_opt" == true ]]; then
        resultsfile="$filepath/$typevar-udp-servicescan-results.nmap"
        outputfile="$filepath/logs/misc-files/$typevar-windowshostsudp.txt"
        genwindowshostlist "$resultsfile" >> "$outputfile"
    fi

    # Combine and sort the outputs
    cat "$filepath/logs/misc-files/$typevar-windowshoststcp.txt" "$filepath/logs/misc-files/$typevar-windowshostsudp.txt" 2>/dev/null | sort -u > "$filepath/analysis/$typevar-windowsHosts.txt"

	# Remove the output file if it's empty
    if [[ ! -s "$filepath/analysis/$typevar-windowsHosts.txt" ]]; then
        rm "$filepath/analysis/$typevar-windowsHosts.txt"
    fi
}

function parsegrepnmap {
    local gnmapfile="$1"
    local portsofinterest="$2"
    local outputfilename="$3"

    # Error handling
    if [[ -z "$gnmapfile" || -z "$portsofinterest" ]]; then
        echo -e "\e[31m [X] Error: Invalid syntax -- Usage: --parseports <GrepableNmapFile> <Comma,Separated,Ports> [OutputFileName] \e[0m" >&2
        return 1
    elif [[ ! -f "$gnmapfile" ]]; then
        echo -e "\e[31m [X] Error: File '$gnmapfile' does not exist \e[0m" >&2
        return 1
    fi

    if [[ -z "$outputfilename" ]]; then # First Scenario: Output to terminal
        echo 'To parse the output for a specific port or service and output the results in ip:port/service format, save the results to a file and use the following command, changing the value of <PORT/SERVICE> and <resultsFilename>:'
        echo ''
		echo 'awk -F'\'' '\'' -v t="PORT/SERVICE" '\''BEGIN{IGNORECASE=1} $2","$3 ~ "(^|,)" t "(,|$)" {print $1":"t}'\'' resultsFilename'
        echo ''
        # Output the data to the terminal
        grep '^Host:' "$gnmapfile" | \
        sed -n 's/^Host: \([^ ]*\).*Ports: \(.*\)/\1\t\2/p' | \
        awk -F'\t' -v ports="$portsofinterest" '
		BEGIN {
		    IGNORECASE = 1
		    split(ports, portlist, ",")
		    for (i in portlist) portmap[portlist[i]] = 1
		}
		{
		    ip = $1
		    ports_field = $2

		    ports_list = ""
		    services_list = ""

		    n = split(ports_field, port_entries, ", ")
		    for (j = 1; j <= n; j++) {
		        port_entry = port_entries[j]
		        split(port_entry, port_parts, "/")
		        portnum = port_parts[1]
		        state = port_parts[2]
		        service = port_parts[5]
		        if (state == "open" && portmap[portnum]) {
		            if (ports_list == "") {
		                ports_list = portnum
		                services_list = service
		            } else {
		                ports_list = ports_list "," portnum
		                services_list = services_list "," service
		            }
		        }
		    }
		    if (ports_list != "") {
		        print ip "    " ports_list "    " services_list
		    }
		}'
	elif [[ "$parsegrepnmap_inscript" == true ]]; then # Second Scenario: Output to file (instructions and data)
		# Create a temporary file for data output
		temp_data_output=$(mktemp)
		# Parsing the gnmap file and outputting data to the temporary file
		grep '^Host:' "$gnmapfile" | \
		sed -n 's/^Host: \([^ ]*\).*Ports: \(.*\)/\1\t\2/p' | \
		awk -F'\t' -v ports="$portsofinterest" '
		BEGIN {
		    IGNORECASE = 1
		    split(ports, portlist, ",")
		    for (i in portlist) portmap[portlist[i]] = 1
		}
		{
		    ip = $1
		    ports_field = $2

		    ports_list = ""
		    services_list = ""

		    n = split(ports_field, port_entries, ", ")
		    for (j = 1; j <= n; j++) {
		        port_entry = port_entries[j]
		        split(port_entry, port_parts, "/")
		        portnum = port_parts[1]
		        state = port_parts[2]
		        service = port_parts[5]
		        if (state == "open" && portmap[portnum]) {
		            if (ports_list == "") {
		                ports_list = portnum
		                services_list = service
		            } else {
		                ports_list = ports_list "," portnum
		                services_list = services_list "," service
		            }
		        }
		    }
		    if (ports_list != "") {
		        print ip "    " ports_list "    " services_list
		    }
		}' > "$temp_data_output"

		        # Check if the temporary data output file is empty
		        if [[ -s "$temp_data_output" ]]; then
		            # There is data, write instructions and data to the output file
		            {
		                echo 'To parse the contents for a specific port or service and output the results in ip:port/service format, use the following command, changing the value of <PORT/SERVICE>:'
		                echo ''
						echo 'awk -F'\'' '\'' -v t="PORT/SERVICE" '\''BEGIN{IGNORECASE=1} $2","$3 ~ "(^|,)" t "(,|$)" {print $1":"t}'\'' '"$outputfilename"
		                echo ''
		                cat "$temp_data_output"
		            } > "$outputfilename"
		        else
		            # No data, remove the output file if it exists
		            rm -f "$outputfilename"
		        fi
		        # Clean up the temporary file
		        rm -f "$temp_data_output"
	else # Third Scenario: Instructions to terminal, data to file
		echo 'To parse the output file for a specific port or service and output the results in ip:port/service format, use the following command, changing the value of <PORT/SERVICE>:'
		echo ''
		echo 'awk -F'\'' '\'' -v t="PORT/SERVICE" '\''BEGIN{IGNORECASE=1} $2","$3 ~ "(^|,)" t "(,|$)" {print $1":"t}'\'' '"$outputfilename"
		# Parsing the gnmap file and outputting data to the output file
		grep '^Host:' "$gnmapfile" | \
		sed -n 's/^Host: \([^ ]*\).*Ports: \(.*\)/\1\t\2/p' | \
		awk -F'\t' -v ports="$portsofinterest" '
		BEGIN {
		    IGNORECASE = 1
		    split(ports, portlist, ",")
		    for (i in portlist) portmap[portlist[i]] = 1
		}
		{
		    ip = $1
		    ports_field = $2

		    ports_list = ""
		    services_list = ""

		    n = split(ports_field, port_entries, ", ")
		    for (j = 1; j <= n; j++) {
		        port_entry = port_entries[j]
		        split(port_entry, port_parts, "/")
		        portnum = port_parts[1]
		        state = port_parts[2]
		        service = port_parts[5]
		        if (state == "open" && portmap[portnum]) {
		            if (ports_list == "") {
		                ports_list = portnum
		                services_list = service
		            } else {
		                ports_list = ports_list "," portnum
		                services_list = services_list "," service
		            }
		        }
		    }
		    if (ports_list != "") {
		        print ip "    " ports_list "    " services_list
		    }
		}' > "$outputfilename"
	fi
}

function listiptohostname { #Lists IP addresses and their corresponding hostnames
    local inputfile="$1"
    local outputfile="$2"

    # Check if inputfile is provided and exists
    if [[ -z "$inputfile" ]]; then
        echo -e "\e[31m [X] Error: Invalid syntax -- Usage: --listiphostname <StandardNmapFile> [OutputFile]" >&2
        return 1
	elif [[ ! -f "$inputfile" ]]; then
		echo -e "\e[31m [X] Error: File '$inputfile' does not exist \e[0m" >&2
		return 1
	fi

    if [[ -n "$outputfile" ]]; then
        awk '
        /^Nmap scan report for/ {
            line = $0
            hostname = "Unknown"
            ip = ""

            prefix = "Nmap scan report for "
            prefix_length = length(prefix)
            # Extract the rest of the line after the prefix
            rest = substr(line, prefix_length + 1)

            # Check if rest contains "(" indicating a hostname and IP
            paren_pos = index(rest, "(")
            if (paren_pos > 0) {
                hostname = substr(rest, 1, paren_pos - 1)
                # Remove any trailing spaces from hostname
                sub(/[[:space:]]+$/, "", hostname)
                ip_start = paren_pos + 1
                ip_end = index(rest, ")") - 1
                ip = substr(rest, ip_start, ip_end - paren_pos)
            } else {
                # No hostname, only IP is present
                ip = rest
                # Remove any leading/trailing spaces from IP
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", ip)
            }

            if (ip != "") {
                print ip, hostname
            }
        }
        ' "$inputfile" > "$outputfile"
    else
        awk '
        /^Nmap scan report for/ {
            line = $0
            hostname = "Unknown"
            ip = ""

            prefix = "Nmap scan report for "
            prefix_length = length(prefix)
            # Extract the rest of the line after the prefix
            rest = substr(line, prefix_length + 1)

            # Check if rest contains "(" indicating a hostname and IP
            paren_pos = index(rest, "(")
            if (paren_pos > 0) {
                hostname = substr(rest, 1, paren_pos - 1)
                # Remove any trailing spaces from hostname
                sub(/[[:space:]]+$/, "", hostname)
                ip_start = paren_pos + 1
                ip_end = index(rest, ")") - 1
                ip = substr(rest, ip_start, ip_end - paren_pos)
            } else {
                # No hostname, only IP is present
                ip = rest
                # Remove any leading/trailing spaces from IP
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", ip)
            }

            if (ip != "") {
                print ip, hostname
            }
        }
        ' "$inputfile"
    fi
}

function listiptohostname_inscript { #For genwinhostlist when ran inside the script
    if [[ "$stage" == "services-tcp" ]]; then
        resultsfile="$filepath/$typevar-tcp-servicescan-results.nmap"
        outputfile="$filepath/logs/misc-files/$typevar-iphostnamestcp.txt"
        listiptohostname "$resultsfile" >> "$outputfile"
    elif [[ "$stage" == "services-udp" ]] && [[ "$udp" == "y" || "$udp" == "yes" || "$U_opt" == true ]]; then
        resultsfile="$filepath/$typevar-udp-servicescan-results.nmap"
        outputfile="$filepath/logs/misc-files/$typevar-iphostnamesudp.txt"
        listiptohostname "$resultsfile" >> "$outputfile"
    fi

    # Combine and sort the outputs
    cat "$filepath/logs/misc-files/$typevar-iphostnamestcp.txt" "$filepath/logs/misc-files/$typevar-iphostnamesudp.txt" 2>/dev/null | sort -u > "$filepath/analysis/$typevar-ipHostnames.txt"

	# Remove the output file if it's empty
    if [[ ! -s "$filepath/analysis/$typevar-ipHostnames.txt" ]]; then
        rm "$filepath/analysis/$typevar-ipHostnames.txt"
    fi
}

function statusnmap {
	indicator="^-_-^"
		# Start a background process to cat the last line of the file every 15 minutes
		(
		    while kill -0 $pid >/dev/null 2>&1; do
		        sleep 900  # 15 minutes
		        printf "\r\e[K" # Clear continuous status line
		        echo ""
				echo ""
				tail -n 5 "$periodicfile"
				echo ""
		    done
		) &
		status_pid=$! #Capture the PID of the status process

		while kill -0 $pid >/dev/null 2>&1; do
    	    i=$(( (i+1) % ${#indicator} ))
    	    # "\r" returns to the beginning of the line, "\e[K" clears from the cursor to the end.
    	    printf "\r\e[K%s %s" "${indicator:$i:1}" "$contstatus"
    	    sleep 0.2
    	done
		printf "\r\e[K" #Clears status indicator line

		kill $status_pid #Kill the status process when done
}

function statusmasscan {
	indicator="^-_-^"
		# Start a background process to cat the last line of the file every 15 minutes
		(
    	    while kill -0 $pid >/dev/null 2>&1; do
    	        sleep 900  # 15 minutes
    	        printf "\r\e[K"
    	        echo ""
    	        tail -n 5 "$periodicfile"
    	        echo ""
    	    done
    	) &
    	status_pid=$!  # Capture the PID of the background status process

		while kill -0 $pid >/dev/null 2>&1; do
    	    i=$(( (i+1) % ${#indicator} ))
    	    printf "\r\e[K%s %s" "${indicator:$i:1}" "$contstatus"
    	    sleep 0.2
    	done

		printf "\r\e[K" #Clears status indicator line

		kill $status_pid 2>/dev/null #Kill the status process when done
}

function errorcheck { #Checks for errors in command output
	errorlog="/logs/$typevar-errors.log"

	if [ $exitstatus -ne 0 ]; then
		echo "--------" >> "$errorlog"
		echo "COMMAND: $checked_cmd" >> "$errorlog"
		echo "===================================" >> "$errorlog"
		echo '' >> "$errorlog"
		echo -e "\e[31m [X] Error occured -- check logs in $errorlog \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log" >&2
	fi
}

function sedescape { #prevents special characters from being interpreted as sed metacharacters - used in methodology
    			echo "$1" | sed -e 's/[]\/$*.^[]/\\&/g'
}

function whenstopped {
	#Kill the periodic status process if it's running
    if [[ -n $status_pid ]] && kill -0 $status_pid >/dev/null 2>&1; then       
		kill $status_pid
    fi
	#Display exiting status
	if [[ "$firewallset" = true ]]; then
		removefirewallrule
	fi
	echo -e "\e[33m [!] Zero-E stopped -- saving progress... \e[0m" | tee -a $filepath/logs/$typevar-timestamps.log
	sleep 3
	sed -i -e 's/\x1b\[[0-9;]*m//g' -e 's/\x1b\[A//g' -e 's/\x1b\[K//g' "$filepath/logs/$typevar-timestamps.log" #cleans up timestamps log
	sed -i '/nocapture = servername/d' paused.conf 2>/dev/null #Removes line that breaks masscan --resume function
	sed -i 's/adapter-port = [0-9]*-[0-9]*/adapter-port = 40000-41023/' paused.conf 2>/dev/null #Fixes another line that breaks masscan --resume function... cmon masscan, do better
	#Remove the trap to prevent it from repeating
	trap - INT TERM  
	exit 1
}

function zrecleanup {
	sed -i 's/\x1b\[[0-9;]*m//g' $filepath/logs/$typevar-timestamps.log #cleans up timestamps log
	rm -rd /tmp/zeroe 2>/dev/null
	rm paused.conf 2>/dev/null
}

function checktools {
  	oscheck=$(uname)
  	if [ "$oscheck" = "Darwin" ]; then  # For macOS
    	missing=()
    	for tool in "${mactools[@]}"; do
      		if ! command -v "$tool" >/dev/null 2>&1; then
				if [ "$tool" = "realpath" ]; then
					missing+=(coreutils)
				else
					missing+=("$tool")
				fi
	  		fi
    	done
    	if [ ${#missing[@]} -gt 0 ]; then
      		echo -e "\e[31m[X] Error: The following required tools are not installed: ${missing[*]}\e[0m"
      		# Ask if user wants to install
      		read -p "Would you like to install them now using Homebrew? <y/n> " resp
      		if [[ "$resp" =~ ^[Yy]$ ]]; then
        		# Install missing tools
        		for tool in "${missing[@]}"; do
          			echo "Installing $tool..."
          			brew install "$tool"
        		done
        		echo -e "\e[32m[+] All missing required tools have been installed\e[0m\n"
      		else
        		echo -e "\nYou can install them manually with:\n  brew install <tool>\n"
        		exit 1
      		fi
    	fi
  	else  # For Linux
    	missing=()
    	for tool in "${linuxtools[@]}"; do
      		if ! command -v "$tool" >/dev/null 2>&1; then
        		if [ "$tool" = "realpath" ]; then
					missing+=(coreutils)
				else
					missing+=("$tool")
				fi
      		fi
    	done
    	if [ ${#missing[@]} -gt 0 ]; then
      		echo -e "\e[31m[X] Error: The following required tools are not installed: ${missing[*]}\e[0m"
      		# Ask if user wants to install
      		read -p "Would you like to install them now using apt? <y/n> " resp
      		if [[ "$resp" =~ ^[Yy]$ ]]; then
        		# Update apt cache and install missing tools
        		sudo apt update
        		for tool in "${missing[@]}"; do
          			echo "Installing $tool..."
          			sudo apt install -y "$tool"
        		done
        		echo -e "\e[32m[+] All missing required tools have been installed\e[0m\n"
      		else
        		echo -e "\nYou can install them manually with:\n  sudo apt install <tool>\n"
        		exit 1
      		fi
    	fi
  	fi
}

function zrengineer { #Enables users to customize commands
	echo -e "\e[33m [!] ZrE ngineer mode is experimental [!]"
	echo -e " [!] It tries to prevent command options that may cause errors"
	echo -e " [!] But given the large number of possible options, it does not catch everything"
	echo -e " [!] If ZrE errors, it is likely due to input passed in these commands \e[0m"
	#create prompts for all necessary commands depending on if internal or external, saying not to include targets, excludes, output, etc
	if [[ "$e_opt" = true || "$type" = "E" || "$type" = "e" || "$type" = "external" || "$type" = "External" || "$type" = "Ext" || "$type" = "ext" ]]; then
		#while true; do
		#	echo "[?] Provide nmap alives discovery command:"
		#	read -e -p " [>] " zreng_ext_alives
		#	if [[ "$zreng_ext_alives" =~ (-|--excludefile|-iL|>>|>|&|-o\*) ]] || [[ "$zreng_ports_opts" == *"- "* ]] || { [[ "$zreng_ports_opts" =~ (-)$ ]] && [[ ! "$zreng_ports_opts" =~ "-p-" ]]; }; then
		#		echo -e "\e[31m [X] Error: The command cannot contain [-|--excludefile|-iL|>>|>|&] -- this will likely cause errors \e[0m"
		#	elif [[ "$zreng_ext_alives" != *"nmap"* ]]; then
		#		echo -e "\e[31m [X] Error: Nmap must be used for alives discovery or errors will occur \e[0m"
		#	elif [[ -z "$zreng_ext_alives" ]]; then #leave blank to use default
		#		ngineer_default=true
		#		break
		#	else
		#		echo "$zreng_ext_alives"
		#		break
		#	fi
		#done
		echo "[?] Provide custom options for the masscan open port discovery scan command:"
		echo "    Leave blank to use the ZrE default"
		echo "    Hardcoded: <--open-only> <--excludefile (null if not specified)> <--include-file> <-oG>"
		while true; do
			read -e -p " [>] " zreng_ports_opts
			if [[ -z "$zreng_ports_opts" ]]; then #leave blank to use default
				ngineer_ports_default=true
				break
			elif [[ "$zreng_ports_opts" =~ (-sV|--excludefile|--include-file|>>|>|&|-o\*) ]] || [[ "$zreng_ports_opts" == "- " ]] || { [[ "$zreng_ports_opts" =~ (-)$ ]] && [[ ! "$zreng_ports_opts" =~ "-p-" ]]; }; then
				echo -e "\e[31m [X] Error: The command cannot contain [ --excludefile | --include-file | >> | > | & | - | -o* ] -- this will likely cause errors\e[0m" >&2
			elif [[ "$zreng_ports_opts" == *"masscan"* ]]; then
				echo -e "\e[31m [X] Error: Only provide the desired options \e[0m" >&2
			elif [[ "$zreng_ports_opts" == *"nmap"* ]]; then
				echo -e "\e[31m [X] Error: Currently, Nmap cannot be used here \e[0m" >&2
			elif ! [[ "$zreng_ports_opts" =~ (-p[[:space:]]*([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])(-([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))?|--top-ports[[:space:]]+([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))|-p- ]]; then
				echo -e "\e[31m [X] Error: At minimum, you must specify ports with -p or --top-ports with proper syntax \e[0m" >&2
			else
				break
			fi
		done

		echo "[?] Provide custom options for the Nmap UDP discovery scan command:"
		echo "    Leave blank to use the ZrE default"
		echo "    Hardcoded: <-sU> <--open> <--excludefile (null if not specified)> <-iL> <-oG>"
		while true; do
			read -e -p " [>] " zreng_udpa_opts
			if [[ -z "$zreng_udpa_opts" ]]; then #leave blank to use default
				ngineer_udpa_default=true
				break
			elif [[ "$zreng_udpa_opts" =~ (-sV|--excludefile|-iL|>>|>|&|-o\*) ]] || [[ "$zreng_udpa_opts" == *"- "* ]] || { [[ "$zreng_udpa_opts" =~ (-)$ ]] && [[ ! "$zreng_udpa_opts" =~ "-p-" ]]; }; then
				echo -e "\e[31m [X] Error: The command cannot contain [ -sV | --excludefile | -iL | >> | > | & | - | -o* ] -- this will likely cause errors \e[0m" >&2
			elif [[ "$zreng_udpa_opts" == *"nmap"* ]]; then
				echo -e "\e[31m [X] Error: Only provide the desired options \e[0m" >&2
			elif [[ "$zreng_ports_opts" == *"masscan"* ]]; then
				echo -e "\e[31m [X] Error: Currently, masscan cannot be used here \e[0m" >&2
			elif ! [[ "$zreng_udpa_opts" =~ (-p[[:space:]]*([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])(-([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))?|--top-ports[[:space:]]+([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))|-p- ]]; then
				echo -e "\e[31m [X] Error: At minimum, you must specify ports with -p or --top-ports with proper syntax \e[0m" >&2
			else
				break
			fi
		done

		echo "[?] Provide custom options for the Nmap TCP service scan command:"
		echo "    Leave blank to use the ZrE default"
		echo "    Hardcoded: <-sV> <-Pn> <-p> <--excludefile (null if not specified)> <-iL> <-oA>"
		while true; do
			read -e -p " [>] " zreng_tcps_opts
			if [[ -z "$zreng_tcps_opts" ]]; then #leave blank to use default
				ngineer_tcps_default=true
				break
			elif [[ "$zreng_tcps_opts" =~ (--excludefile|-iL|>>|>|&|-o\*) ]] || [[ "$zreng_tcps_opts" == *"- "* ]] || { [[ "$zreng_tcps_opts" =~ (-)$ ]] && [[ ! "$zreng_tcps_opts" =~ "-p-" ]]; }; then
				echo -e "\e[31m [X] Error: The command cannot contain [ --excludefile | -iL | >> | > | & | - | -o* ] -- this will likely cause errors \e[0m" >&2
			elif [[ "$zreng_tcps_opts" == *"nmap"* ]]; then
				echo -e "\e[31m [X] Error: Only provide the desired options \e[0m" >&2
			elif [[ "$zreng_ports_opts" == *"masscan"* ]]; then
				echo -e "\e[31m [X] Error: Currently, masscan cannot be used here \e[0m" >&2
			elif [[ "$zreng_tcps_opts" == *"-p"* ]] || [[ "$zreng_tcps_opts" == *"--top-ports"* ]]; then
				echo -e "\e[31m [X] Error: ZrE will provide only open ports to this scan \e[0m" >&2
			else
				break
			fi
		done

		echo "[?] Provide custom options for the Nmap UDP service scan command:"
		echo "    Leave blank to use the ZrE default"
		echo "    Hardcoded: <-sU> <-sV> <-Pn> <-p> <--excludefile (null if not specified)> <-iL> <-oA>"
		while true; do
			read -e -p " [>] " zreng_udps_opts
			if [[ -z "$zreng_udps_opts" ]]; then #leave blank to use default
				ngineer_udps_default=true
				break
			elif [[ "$zreng_udps_opts" =~ (--excludefile|-iL|>>|>|&|-o\*) ]] || [[ "$zreng_udps_opts" == *"- "* ]] || { [[ "$zreng_udps_opts" =~ (-)$ ]] && [[ ! "$zreng_udps_opts" =~ "-p-" ]]; }; then
				echo -e "\e[31m [X] Error: The command cannot contain [ --excludefile | -iL | >> | > | & | - | -o* ] -- this will likely cause errors \e[0m" >&2
			elif [[ "$zreng_udps_opts" == *"nmap"* ]]; then
				echo -e "\e[31m [X] Error: Only provide the desired options \e[0m" >&2
			elif [[ "$zreng_ports_opts" == *"masscan"* ]]; then
				echo -e "\e[31m [X] Error: Currently, masscan cannot be used here \e[0m" >&2
			elif [[ "$zreng_udps_opts" == *"-p"* ]] || [[ "$zreng_udps_opts" == *"--top-ports"* ]]; then
				echo -e "\e[31m [X] Error: ZrE will provide only open ports to this scan \e[0m" >&2
			else
				break
			fi
		done
	elif [[ "$i_opt" = true || "$type" = "I" || "$type" = "i" || "$type" = "internal" || "$type" = "Internal" || "$type" = "Int" || "$type" = "int" ]]; then
		###Internal###
		echo "[?] Provide custom options for the masscan open port discovery scan command:"
		echo "    Leave blank to use the ZrE default"
		echo "    Hardcoded: <--open-only> <--excludefile (null if not specified)> <--include-file> <-oG>"
		while true; do
			read -e -p " [>] " zreng_ports_opts
			if [[ -z "$zreng_ports_opts" ]]; then #leave blank to use default
				ngineer_ports_default=true
				break
			elif [[ "$zreng_ports_opts" =~ (--src-port|--excludefile|--include-file|>>|>|&|-o\*) ]] || [[ "$zreng_ports_opts" == *"- "* ]] || { [[ "$zreng_ports_opts" =~ (-)$ ]] && [[ ! "$zreng_ports_opts" =~ "-p-" ]]; }; then
				echo -e "\e[31m [X] Error: The command cannot contain [ --src-port | --excludefile | --include-file | >> | > | & | - | -o* ] -- this will likely cause errors \e[0m" >&2
			elif [[ "$zreng_ports_opts" == *"masscan"* ]]; then
				echo -e "\e[31m [X] Error: Only provide the desired options \e[0m" >&2
			elif [[ "$zreng_ports_opts" == *"nmap"* ]]; then
				echo -e "\e[31m [X] Error: Currently, Nmap cannot be used here \e[0m" >&2
			elif ! [[ "$zreng_ports_opts" =~ (-p[[:space:]]*([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])(-([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))?|--top-ports[[:space:]]+([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))|-p- ]]; then
				echo -e "\e[31m [X] Error: At minimum, you must specify ports with -p or --top-ports with proper syntax \e[0m" >&2
			else
				break
			fi
		done

		echo "[?] Provide custom options for the Nmap UDP discovery scan command:"
		echo "    Leave blank to use the ZrE default"
		echo "    Hardcoded: <-sU> <--open> <--excludefile (null if not specified)> <-iL> <-oG>"
		while true; do
			read -e -p " [>] " zreng_udpa_opts
			if [[ -z "$zreng_udpa_opts" ]]; then #leave blank to use default
				ngineer_udpa_default=true
				break
			elif [[ "$zreng_udpa_opts" =~ (--excludefile|-iL|-sV|>>|>|&|-o\*) ]] || [[ "$zreng_udpa_opts" == *"- "* ]] || { [[ "$zreng_udpa_opts" =~ (-)$ ]] && [[ ! "$zreng_udpa_opts" =~ "-p-" ]]; }; then
				echo -e "\e[31m [X] Error: The command cannot contain [ --excludefile | -iL | -sV | >> | > | & | - | -o* ] -- this will likely cause errors \e[0m" >&2
			elif [[ "$zreng_udpa_opts" == *"nmap"* ]]; then
				echo -e "\e[31m [X] Error: Only provide the desired options \e[0m" >&2
			elif [[ "$zreng_ports_opts" == *"masscan"* ]]; then
				echo -e "\e[31m [X] Error: Currently, masscan cannot be used here \e[0m" >&2
			elif ! [[ "$zreng_udpa_opts" =~ (-p[[:space:]]*([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])(-([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))?|--top-ports[[:space:]]+([0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))|-p- ]]; then
				echo -e "\e[31m [X] Error: At minimum, you must specify ports with -p or --top-ports with proper syntax \e[0m" >&2
			else
				break
			fi
		done

		echo "[?] Provide custom options for the Nmap TCP service scan command:"
		echo "    Leave blank to use the ZrE default"
		echo "    Hardcoded: <-sV> <-Pn> <-p> <--excludefile (null if not specified)> <-iL> <-oA>"
		while true; do
			read -e -p " [>] " zreng_tcps_opts
			if [[ -z "$zreng_tcps_opts" ]]; then #leave blank to use default
				ngineer_tcps_default=true
				break
			elif [[ "$zreng_tcps_opts" =~ (--excludefile|-iL|>>|>|&|-o\*) ]] || [[ "$zreng_tcps_opts" == *"- "* ]] || { [[ "$zreng_tcps_opts" =~ (-)$ ]] && [[ ! "$zreng_tcps_opts" =~ "-p-" ]]; }; then
				echo -e "\e[31m [X] Error: The command cannot contain [ --excludefile | -iL | >> | > | & | - | -o* ] -- this will likely cause errors \e[0m" >&2
			elif [[ "$zreng_tcps_opts" == *"nmap"* ]]; then
				echo -e "\e[31m [X] Error: Only provide the desired options \e[0m" >&2
			elif [[ "$zreng_ports_opts" == *"masscan"* ]]; then
				echo -e "\e[31m [X] Error: Currently, masscan cannot be used here \e[0m" >&2
			elif [[ "$zreng_tcps_opts" == *"-p"* ]] || [[ "$zreng_tcps_opts" == *"--top-ports"* ]]; then
				echo -e "\e[31m [X] Error: ZrE will provide only open ports to this scan \e[0m" >&2
			else
				break
			fi
		done

		echo "[?] Provide custom options for the Nmap UDP service scan command:"
		echo "    Leave blank to use the ZrE default"
		echo "    Hardcoded: <-sU> <-sV> <-Pn> <-p> <--excludefile (null if not specified)> <-iL> <-oA>"
		while true; do
			read -e -p " [>] " zreng_udps_opts
			if [[ -z "$zreng_udps_opts" ]]; then #leave blank to use default
				ngineer_udps_default=true
				break
			elif [[ "$zreng_udps_opts" =~ (--excludefile|-iL|>>|>|&|-o\*) ]] || [[ "$zreng_udps_opts" == *"- "* ]] || { [[ "$zreng_udps_opts" =~ (-)$ ]] && [[ ! "$zreng_udps_opts" =~ "-p-" ]]; }; then
				echo -e "\e[31m [X] Error: The command cannot contain [ --excludefile | -iL | >> | > | & | - | -o* ] -- this will likely cause errors \e[0m" >&2
			elif [[ "$zreng_udps_opts" == *"nmap"* ]]; then
				echo -e "\e[31m [X] Error: Only provide the desired options \e[0m" >&2
			elif [[ "$zreng_ports_opts" == *"masscan"* ]]; then
				echo -e "\e[31m [X] Error: Currently, masscan cannot be used here \e[0m" >&2
			elif [[ "$zreng_udps_opts" == *"-p"* ]] || [[ "$zreng_udps_opts" == *"--top-ports"* ]]; then
				echo -e "\e[31m [X] Error: ZrE will provide only open ports to this scan \e[0m" >&2
			else
				break
			fi
		done
	
	fi
}

function totaltargets { # Counts total number of hosts in a targets file

    # Function to convert dotted-decimal IP to integer
    ip_to_int() {
        local ip="$1"
        local o1 o2 o3 o4
        IFS='.' read -r o1 o2 o3 o4 <<< "$ip"
        for octet in "$o1" "$o2" "$o3" "$o4"; do
            if ! [[ "$octet" =~ ^[0-9]+$ ]] || (( octet < 0 || octet > 255 )); then
                echo "0"
                return
            fi
        done
        echo $(( (o1 << 24) + (o2 << 16) + (o3 << 8) + o4 ))
    }

    # Function to calculate number of hosts in a CIDR
    calculate_cidr_hosts() {
        local cidr="$1"
        local ip prefix
        IFS=/ read -r ip prefix <<< "$cidr"

        # Validate CIDR prefix
        if ! [[ "$prefix" =~ ^[0-9]+$ ]] || (( prefix < 0 || prefix > 32 )); then
            echo "0"
            return
        fi

        # Calculate total number of addresses
        local total_addresses=$((1 << (32 - prefix)))

        # Subtract network and broadcast addresses if prefix allows
        if (( prefix < 31 )); then
            total_addresses=$(( total_addresses - 2 ))
        fi

        # Ensure non-negative number of hosts
        if (( total_addresses < 0 )); then
            total_addresses=0
        fi

        echo "$total_addresses"
    }

    # Function to calculate number of hosts in an IP range
    calculate_ip_range_hosts() {
        local ip_range="$1"
        local IFS='-'
        local start end

        read -r start end <<< "$ip_range"

        # Convert IPs to integers
        local start_long=$(ip_to_int "$start")
        local end_long=$(ip_to_int "$end")

        # Validate IPs
        if (( start_long == 0 || end_long == 0 || start_long > end_long )); then
            echo "0"
            return
        fi

        # Calculate number of hosts
        local num_hosts=$(( end_long - start_long + 1 ))
        echo "$num_hosts"
    }

    total_hosts=0  # 'total_hosts' is now a global variable
    local line hosts

    while IFS= read -r line || [[ -n "$line" ]]; do
        # Remove comments and whitespace
        line="${line%%#*}"
        line="${line//[[:space:]]/}"

        # Skip empty lines
        if [[ -z "$line" ]]; then
            continue
        fi

        if [[ $line == *"/"* ]]; then
            # CIDR notation
            hosts=$(calculate_cidr_hosts "$line")
        elif [[ $line == *"-"* ]]; then
            # IP range
            hosts=$(calculate_ip_range_hosts "$line")
        else
            # Single IP
            hosts=1
        fi
        total_hosts=$(( total_hosts + hosts ))
    done < "$checkfile"
}

ip_to_int() { # Function to convert dotted-decimal IP to integer
    local ip="$1"
    local o1 o2 o3 o4
    # Extract octets
    o1="${ip%%.*}"
    ip="${ip#*.}"
    o2="${ip%%.*}"
    ip="${ip#*.}"
    o3="${ip%%.*}"
    o4="${ip#*.}"
    # Convert to integers
    echo $(( (o1 << 24) + (o2 << 16) + (o3 << 8) + o4 ))
}
int_to_ip() { # Function to convert integer IP to dotted-decimal format
    local ip=$1
    local octet1=$(( (ip >> 24) & 255 ))
    local octet2=$(( (ip >> 16) & 255 ))
    local octet3=$(( (ip >> 8) & 255 ))
    local octet4=$(( ip & 255 ))
    echo "$octet1.$octet2.$octet3.$octet4"
}
cidr_to_ip_range() { # Function to convert CIDR to IP range
    local ip cidr netmask
    IFS=/ read -r ip cidr <<< "$1"
    local ip_int=$(ip_to_int "$ip")
    netmask=$(( (0xFFFFFFFF << (32 - cidr)) & 0xFFFFFFFF ))
    local network=$(( ip_int & netmask ))
    local broadcast=$(( network | ((~netmask) & 0xFFFFFFFF) ))
    echo "$(int_to_ip $network)-$(int_to_ip $broadcast)"
}
expand_ips() { # Function to expand IPs
    local inputfile="$1"
    while IFS= read -r ip || [[ -n "$ip" ]]; do
        # Remove comments and whitespace
        ip="${ip%%#*}"
        ip="${ip//[[:space:]]/}"

        # Skip empty lines
        if [[ -z "$ip" ]]; then
            continue
        fi

        if [[ $ip == *"/"* ]]; then
            # Handle CIDR notation
            range=$(cidr_to_ip_range "$ip")
            IFS=- read -r start end <<< "$range"
            start_int=$(ip_to_int "$start")
            end_int=$(ip_to_int "$end")
            # Exclude network and broadcast addresses for subnets larger than /31
            IFS=/ read -r network prefix <<< "$ip"
            if (( prefix < 31 )); then
                start_int=$((start_int + 1))
                end_int=$((end_int - 1))
            fi
            for ((i=start_int; i<=end_int; i++)); do
                int_to_ip "$i"
            done
        elif [[ $ip == *"-"* ]]; then
            # Handle IP range
            IFS=- read -r start end <<< "$ip"
            start_int=$(ip_to_int "$start")
            end_int=$(ip_to_int "$end")
            for ((i=start_int; i<=end_int; i++)); do
                ip_addr=$(int_to_ip "$i")
                echo "$ip_addr"
            done
        else
            # Handle single IP address
            echo "$ip"
        fi
    done < "$inputfile"
}
function geniplist { # Main function to generate IP list
    expand_ips "$checkfile" | sort -n -t . -k 1,1 -k 2,2 -k 3,3 -k 4,4 | uniq
}

function alivesandportscheck { #checks if alives and openPorts lists are populated
	if grep -q "\S" "$filepath/$typevar-alives.txt" && grep -q "\S" "$filepath/$typevar-openPorts.txt"; then
		echo -e "\e[32m [+] Discovery scans completed -- $(date) \e[0m" | tee -a $filepath/logs/$typevar-timestamps.log
	elif ! grep -q "\S" "$filepath/$typevar-alives.txt" && grep -q "\S" "$filepath/$typevar-openPorts.txt"; then
		echo -e "\e[33m [!] No alive hosts detected -- if unexpected, check targets or inquire about scan defenses or other interference \e[0m" | tee -a $filepath/logs/$typevar-timestamps.log
		echo -e "\e[33m [!] Exiting Zero-E... \e[0m" | tee -a $filepath/logs/$typevar-timestamps.log
		zrecleanup
		exit 1
	elif grep -q "\S" "$filepath/$typevar-alives.txt" && ! grep -q "\S" "$filepath/$typevar-openPorts.txt"; then
		echo -e "\e[33m [!] No open ports detected -- if unexpected, check targets or inquire about scan defenses or other interference \e[0m" | tee -a $filepath/logs/$typevar-timestamps.log
		echo -e "\e[33m [!] Exiting Zero-E... \e[0m" | tee -a $filepath/logs/$typevar-timestamps.log
		zrecleanup
		exit 1
	else
		echo -e "\e[33m [!] No alive hosts or open ports detected -- if unexpected, check targets or inquire about scan defenses or other interference \e[0m" | tee -a $filepath/logs/$typevar-timestamps.log
		echo -e "\e[33m [!] Exiting Zero-E... \e[0m" | tee -a $filepath/logs/$typevar-timestamps.log
		zrecleanup
		exit 1
	fi
}

function removefirewallrule { #removes the firewall rule used in int methodology
	firewallset=false
	oscheck=$(uname)
	if [ $oscheck = "Darwin" ]; then #For st00pid Macs
		cp "/etc/pf.conf" "$filepath/logs/pf.conf.bak-postscript"
		sudo sed -i "/block drop in proto tcp from any to any port 55555/d" /etc/pf.conf
		pfctl -f /etc/pf.conf >> $filepath/logs/mac-pfctl.log 2>&1
		if [ "$macpf" = "Disabled" ]; then
			pfctl -d >> $filepath/logs/mac-pfctl.log 2>&1 #disable pfctl
		fi
	else #For Linux	
		sudo iptables -D INPUT -p tcp --dport 55555 -j DROP 2>/dev/null
	fi
	echo -e "\e[33m [!] Firewall rule removed \e[0m" | tee -a $filepath/logs/$typevar-timestamps.log
}

function setfirewallrule { #sets the firewall rule used in int methodology
	firewallset=true
	oscheck=$(uname)
	if [ $oscheck = "Darwin" ]; then #For st00pid Macs
		macpf=$(pfctl -s info | grep -o "Status: .*" | cut -d' ' -f2) #gets pfctl status
		if [ "$macpf" = "Disabled" ]; then
			pfctl -e >> $filepath/logs/mac-pfctl.log 2>&1 #enable pfctl
		fi
		if pfctl -sr 2>> $filepath/logs/mac-pfctl.log | grep -q "block drop in proto tcp from any to any port 55555"; then #check if rule exists
    		echo -e "\e[33m [!] Firewall rule on port 55555 to prevent RST packets already exists -- skipping rule creation \e[0m" | tee -a $filepath/logs/$typevar-timestamps.log
		else
			cp "/etc/pf.conf" "$filepath/logs/pf.conf.bak-prescript"
    		echo "block drop in proto tcp from any to any port 55555" | sudo tee -a /etc/pf.conf >> $filepath/logs/mac-pfctl.log #creates the rule
    		sudo pfctl -f /etc/pf.conf >> $filepath/logs/mac-pfctl.log 2>&1 #loads the pfctl configuration
			echo -e "\e[33m [!] Firewall rule created on port 55555 to prevent RST packet interference \e[0m" | tee -a $filepath/logs/$typevar-timestamps.log
		fi
	else #For Linux
		if sudo iptables -C INPUT -p tcp --dport 55555 -j DROP 2> /dev/null; then
			echo -e "\e[33m [!] Firewall rule on port 55555 to prevent RST packets already exists -- skipping rule creation \e[0m" | tee -a $filepath/logs/$typevar-timestamps.log
		else	
			sudo iptables -A INPUT -p tcp --dport 55555 -j DROP
			echo -e "\e[33m [!] Firewall rule created on port 55555 to prevent RST packet interference \e[0m" | tee -a $filepath/logs/$typevar-timestamps.log
		fi
	fi
}

updatecheck

#--Switches
#pre-sudo options
help_flag=false
version_flag=false
geniplist_file=""
checkfile=""
defaults=false
only_flag=false
ngineer_mode=false
listwinhosts_flag=false
parseports_flag=false
listiphostnames_flag=false

while [[ $# -gt 0 ]]; do
	case "$1" in
		--help)
            help_flag=true
            shift # Remove --help from processing
            ;;
		--version)
            version_flag=true
            shift # Remove --version from processing
            ;;
        --geniplist)
            shift # Remove --geniplist from processing
            if [[ $# -gt 0 && ! $1 =~ ^- && -f $1 ]]; then #If there is at least one more argument, the next arg doesnt start with a -, and the arg refers to an existing file
                geniplistopt="y"
				geniplist_file="$1"
                shift # Remove file argument from processing
            else
                echo -e "\e[31m [X] Error: --geniplist requires an existing file containing a list of IP addresses (e.g. targets.txt) \e[0m" >&2
                exit 1
            fi
            ;;
        --count)
            shift # Remove --count from processing
            if [[ $# -gt 0 && ! $1 =~ ^- && -f $1 ]]; then
                countopt="y"
				checkfile="$1"
                shift # Remove file argument from processing
            else
                echo -e "\e[31m [X] Error: --count requires an existing file containing a list of a IP addresses (e.g. targets.txt) \e[0m" >&2
                exit 1
            fi
            ;;
		--defaults)
			defaults=true
			shift #Removes --defaults from processing
			;;
		--only)
			only_flag=true
			shift
			;;
		--ngineer)
			ngineer_mode=true
			shift
			;;
		--listwinhosts)
            listwinhosts_flag=true
            shift
            break
            ;;
		--parseports)
			parseports_flag=true
			shift #Remove --parseports from processing
			break #Exit the loop to preserve remaining arguments
			;;
		--listiphostnames)
            listiphostnames_flag=true
            shift
            break
            ;;
        *)
			remaining_args+=("$1") #Stores other opts/args for processing in post-sudo functions
			shift
            ;;
	esac
done
if [ "$help_flag" = true ]; then
	echo "$version -- https://github.com/Inscyght/Zero-E"
    echo ''
	echo "While there are options, providing them is not necessary with Zero-E"
	echo "ZrE will prompt you for required configuration settings"
	echo "For advanced usage:"
	echo -e "\nsudo $(basename $0) [-e || -i] [-o <output_directory>] [-t <targets_file>] [-x [excludes_file]] [-U || -u] [-S [stage] || -s] [--defaults] [--ngineer] [--only] [--count <filename>] [--geniplist <filename>] [--listwinhosts <StandardNmapFile> [OutputFile]] [--parseports <GrepableNmapFile> <Comma,Separated,Ports> [OutputFileName]] [--listiphostname <StandardNmapFile> [OutputFile]]"
	echo "  -e: Run external assessment scans -- cannot be used with -i"
    echo "  -i: Run internal assessment scans -- cannot be used with -e"
    echo "  -o: Sets the output directory where generated files will save to"
    echo "  -t: Sets the file containing the target IP addressses -- each single IP, range, or CIDR must be on a new line"
	echo "  -x: Sets the file containing the IP addressses to exclude -- provide no argument to disable and not be prompted"
    echo "  -U: Enables UDP scans -- cannot be used with -u"
	echo "  -u: Disables UDP scans -- cannot be used with -U"
	echo "  -S: With no arguments, resumes from saved stage -- cannot be used with -s"
	echo "      Will skip to the specified stage, if provided -- valid stages are:"
	echo "      	discovery-alives (TCP-only)"
	echo "      	discovery-ports (TCP-only)"
	echo "      	discovery-udp"
	echo "      	discovery-lists"
	echo "      	services-tcp"
	echo "      	services-udp"
	echo "  -s: Disables stage resuming and selection and starts at beginning of script -- cannot be used with -S"
	echo "      Stages are still saved for resuming later as script runs"
	echo "  --defaults: Runs ZrE using default settings -- using options with this will overwrite the default for that option"
	echo "      Default settings are:"
	echo "        Stage (-S/-s) -- starts at initial alives scan"
	echo "        Targets file (-t) -- ./targets.txt"
	echo "        Output directory (-o) -- ./zre-output"
	echo "        Excluded targets (-x) -- none"
	echo "        UDP scans (-U/-u) -- enabled"
	echo "  --ngineer: Enables entry of custom command options"
	echo "  --only: Only run UDP scans if enabled, and/or specified stage if provided -- does not apply to other options"
	echo "  --count: Calculates and displays the total number of target IP addresses -- does not require sudo"
	echo "  --geniplist: Generates a list of single IP addresses from the IP addresses, "
	echo "               ranges, and CIDRs in the passed file  -- does not require sudo"
    echo "  --listwinhosts: Parses a standard Nmap file (.nmap) and lists the "
	echo "                  IP addresses of the Windows hosts -- does not require sudo"
	echo "  --parseports: Parses a grep-able Nmap file (.gnmap) for hosts with the specified ports open "
	echo "                and outputs results in a readable format -- does not require sudo"
	echo "  --listiphostnames: Parses a standard Nmap file (.nmap) and lists "
	echo "                     IP address and hostname pairs -- does not require sudo"
	exit 0
#Check for --version option (for troubleshooting purposes)
elif [ "$version_flag" = true ]; then
	echo $version
	exit 0
#Check for --count option
elif [ -n "$checkfile" ]; then
	mactools=("dos2unix")
	linuxtools=("dos2unix")
	checktools #Check if required tools are installed
	checkfile="$checkfile"
	checkinvalidips
	echo "Counting total number of target hosts..."
	totaltargets
	echo "$total_hosts -- total number of host IP addresses in $checkfile"
	exit 0
#Check for --geniplist option
elif [ -n "$geniplist_file" ]; then
	mactools=("dos2unix")
	linuxtools=("dos2unix")
	checktools #Check if required tools are installed
	checkfile="$geniplist_file"
	checkinvalidips
	echo "Generating list of single IP addresses..." >&2
	geniplist
	exit 0
elif [ "$listwinhosts_flag" = true ]; then
	genwindowshostlist "$1" "$2"
	exit 0
#Check for --parseports option
elif [ "$parseports_flag" = true ]; then
	parsegrepnmap "$1" "$2" "$3"
	exit 0
elif [ "$listiphostnames_flag" = true ]; then
    listiptohostname "$1" "$2"
    exit 0
fi

#Check sudo
if [[ $EUID -ne 0 ]]; then # && [[ "$arg" != "--help" || "$arg" != "--version" || "$arg" != "--count" || "$arg" != "--geniplist" || "$arg" != "--parseports" ]]; then
   	echo -e "\e[31m [X] Error: $(basename $0) requires sudo \e[0m" >&2
   	exit 1
fi

#Check if post-sudo required tools are installed
mactools=("nmap" "masscan" "pfctl" "dos2unix" "realpath")
linuxtools=("nmap" "masscan" "iptables" "dos2unix" "realpath")
checktools

#post-sudo options
e_opt=false
i_opt=false
o_opt=""
t_opt=""
x_opt=""
U_opt=false
u_opt=false
s_opt=false
S_opt="disabled"
#Loop to parse options using getopts
while getopts ':eio:t:x:UusS:' opt "${remaining_args[@]}" 2>/dev/null; do
	case "${opt}" in
    	e) 
    		e_opt=true 
    		;;
    	i) 
    		i_opt=true 
    		;;
    	o) 
			if [[ "$OPTARG" == -* ]]; then
                echo -e "\e[31m [X] Error: -o requires a directory name or path \e[0m" >&2
                exit 1
			elif [ -f "$OPTARG" ]; then
				echo -e "\e[31m [X] Error: File exists with the same name \e[0m" >&2
				exit 1
			elif [[ "$OPTARG" == *" "* ]]; then
				echo -e "\e[31m [X] Error: To proactively avoid errors, whitespace is not allowed in directory names \e[0m" >&2
				exit 1
            else
				o_opt="$OPTARG"
			fi
			;;
    	t) 
			if [[ "$OPTARG" == -* ]] || [[ -z "$OPTARG" ]] || [[ ! -f "$OPTARG" ]]; then
                echo -e "\e[31m [X] Error: -t requires an existing file containing the list of target IP addresses (e.g. targets.txt) \e[0m" >&2
                exit 1
			elif [[ "$OPTARG" == *" "* ]]; then
				echo -e "\e[31m [X] Error: To proactively avoid errors, whitespace is not allowed in file names \e[0m" >&2
				exit 1
			elif [ ! -s "$OPTARG" ]; then #Check if the file is empty
        		echo -e "\e[31m [X] Error: $OPTARG is empty \e[0m" >&2
				exit 1
            else
				t_opt="$OPTARG"
				checkfile="$t_opt"
				checkinvalidips
			fi
    		;;
		x)
			if [[ "${OPTARG:0:1}" == '-' ]]; then #Enables -x to be run with or without an argument
                OPTIND=$((OPTIND - 1))
				mkdir -p /tmp/zeroe
				touch /tmp/zeroe/nullexcludes.zre
				x_opt="/tmp/zeroe/nullexcludes.zre"
			elif [[ "$OPTARG" == -* ]] || [[ ! -f "$OPTARG" ]]; then
				echo -e "\e[31m [X] Error: -x requires an existing file containing the list of IP addresses to exclude (e.g. exclude.txt) \e[0m" >&2
                exit 1
			elif [[ "$OPTARG" == *" "* ]]; then
				echo -e "\e[31m [X] Error: To proactively avoid errors, whitespace is not allowed in file names \e[0m" >&2
				exit 1
			elif [ ! -s "$OPTARG" ]; then #Check if the file is empty
        		echo -e "\\e[31m [X] Error: $OPTARG is empty \\e[0m" >&2
				exit 1
			else
				x_opt="$OPTARG"
				x_opt_provided="y"
				checkfile="$x_opt"
				checkinvalidips
			fi
			;;
		U) 
    		U_opt=true 
    		;;
		u) 
    		u_opt=true 
    		;;
		s)
			s_opt=true
			;;
		S) 
			if [[ "${OPTARG:0:1}" == '-' ]]; then #Enables -S to be run with or without an argument
                OPTIND=$((OPTIND - 1))
				S_opt=""
			else
				S_opt="$OPTARG"
			fi
			;;
		:) #For when -S or -x is passed without an argument
            if [[ ${OPTARG} == "S" ]]; then
                S_opt=""
			elif [[ ${OPTARG} == "x" ]]; then
				mkdir -p /tmp/zeroe
				touch /tmp/zeroe/nullexcludes.zre
				x_opt="/tmp/zeroe/nullexcludes.zre"
			fi
			;;
    	\?)
    		echo -e "\e[31m [X] Error: invalid option "\`-$OPTARG\`" -- valid options are [-e || -i] [-o] [-t] [-U || -u] [-S || -s] [-x] [--help] [--defaults] [--ngineer] [--only] [--count] [--geniplist] [--listwinhosts] [--parseports] [--listiphostnames] \e[0m" >&2
    		exit 1
    		;;
	esac
done
#Check if the last option was -o or -t and if the arg is missing.
last_arg="${@: -1}"
if [[ $last_arg == "-o" ]] && [[ -z "$o_opt" ]]; then
	echo -e "\e[31m [X] Error: -o requires a directory name or path \e[0m" >&2
	exit 1
elif [[ $last_arg == "-t" ]] && [[ -z "$t_opt" ]]; then
	echo -e "\e[31m [X] Error: -t requires an existing file containing the list of target IP addresses (e.g. targets.txt) \e[0m" >&2
	exit 1
fi
#Check if both -e and -i options are used
if [ "$e_opt" = true ] && [ "$i_opt" = true ]; then
    echo -e "\e[31m [X] Error: You seem confused, script kiddie... -e and -i options cannot be used together \e[0m" >&2
    exit 1
fi
#Check if both -U and -u options are used
if [ "$U_opt" = true ] && [ "$u_opt" = true ]; then
    echo -e "\e[31m [X] Error: You seem confused, script kiddie... -U and -u options used together makes no sense \e[0m" >&2
    exit 1
fi
#Check if both -s and -S options are used
if [ "$s_opt" = true ] && [ "$S_opt" != "disabled" ]; then
    echo -e "\e[31m [X] Error: You seem confused, script kiddie... -s disables stage resuming and selection \e[0m" >&2
    exit 1
fi
#Check if both -t and -x are the same file
if [ "$t_opt" = "$x_opt" ] && [ -n "$t_opt" ] && [ -n "$x_opt" ]; then
    echo -e "\e[31m [X] Error: You seem confused, script kiddie... targets and excludes cannot be the same file \e[0m" >&2
    exit 1
fi

#Banner
echo "$version -- https://github.com/Inscyght/Zero-E"
echo "Support this project -- https://github.com/sponsors/Inscyght"
echo "                        https://buymeacoffee.com/inscyght"
echo ''

#Set the stage to start at
stageinit
if [ -f "/tmp/zeroe/stage.zre" ] && [ -f "/tmp/zeroe/vars.zre" ] && [[ "$resume" = "y" ]]; then #If successfully resuming saved stage...
	if [[ "$(cat /tmp/zeroe/initdir.zre)" = "$(pwd)" ]]; then #check if the current and previous working dir are equal, then...
		: #silently continue to...
	else
		cd $(cat /tmp/zeroe/initdir.zre) || exit #change dirs to the previous working dir (or exit if cannot) and...
	fi
	#parse options to resume scans
	while IFS='=' read -r key rest; do # The value is everything after the first '=', preserving internal quotes and spaces
    	value="${rest#\"}"      # Remove leading quote
    	value="${value%\"}"     # Remove trailing quote
    	eval "$key=\"$value\""  # Use eval to correctly handle complex values, ensuring to escape as needed
	done < /tmp/zeroe/vars.zre
else #Starting new scan or from specific stage
	if [ ! -f "/tmp/zeroe/vars.zre" ] && [[ "$resume" = "y" ]]; then #If choosing resuming without saved options
		echo -e "\e[31m [X] Error: No saved options exist -- configure new scan \e[0m" >&2
		S_opt='disabled'
		resume=''
		while true; do
			stageinit
			if [[ "$resume" = "y" ]]; then
				echo -e "\e[31m [X] Error: New scan configuration required -- resuming without saved options will cause errors \e[0m" >&2
				S_opt='disabled'
				resume=''
			else
				break
			fi
		done
	fi
	#Set external or internal
	settype
	#Enable or disable UDP scans
	enableudp
	#Set the generated file output directory
	output
	#Set the target IPs file
	targets
	#Calculate total number of target hosts
	echo -ne "     Counting total number of target hosts..."
	totaltargets
	echo -e "\r     Counting total number of target hosts... $total_hosts"
	#Set the excluded IPs file
	excludes
	#Check if targets and excludes are the same and repeat loop while they are
	if cmp -s "$ips" "$nostrikes"; then
		echo -e "\e[31m [X] Error: You seem confused, script kiddie... all of the targets are excluded -- try again \e[0m" >&2
		ips=""
		t_opt=""
		nostrikes=""
		x_opt=""
		while true; do
			targets
			echo -ne "     Counting total number of target hosts..."
			totaltargets
			echo -e "\r     Counting total number of target hosts... $total_hosts"
			excludes
			if cmp -s "$ips" "$nostrikes"; then
				echo -e "\e[31m [X] Error: You seem very confused, script kiddie... all of the targets are still excluded \e[0m" >&2
				ips=""
				t_opt=""
				nostrikes=""
				x_opt=""
			else
				break
			fi
		done
	fi
fi
stagefilescheck
#if --only is not applicable
if [[ "$only_flag" == true ]] && [[ "$u_opt" == true ]] && [[ "$U_opt" == false ]] && [[ "$S_opt" == "disabled" ]]; then
  only_flag=false
fi
#If ngineer mode
if [[ "$ngineer_mode" == true && "$resume" != "y" ]]; then
	zrengineer
fi
#Save options to file for resuming stage
if [[ "$resume" != "y" ]]; then
	echo "e_opt=\"$e_opt\" i_opt=\"$i_opt\" filepath=\"$filepath\" ips=\"$ips\" nostrikes=\"$nostrikes\" U_opt=\"$U_opt\" u_opt=\"$u_opt\" total_hosts=\"$total_hosts\" typevar=\"$typevar\" only_flag=\"$only_flag\" stage_cont=\"$stage_cont\"" > /tmp/zeroe/vars.zre
	echo "$stage" > /tmp/zeroe/stage.zre
	if [[ "$ngineer_mode" == true ]]; then
		echo "ngineer_mode=\"$ngineer_mode\" ngineer_ports_default=\"$ngineer_ports_default\" ngineer_udpa_default=\"$ngineer_udpa_default\" ngineer_tcps_default=\"$ngineer_tcps_default\" ngineer_udps_default=\"$ngineer_udps_default\" zreng_ports_opts=\"$zreng_ports_opts\" zreng_udpa_opts=\"$zreng_udpa_opts\" zreng_tcps_opts=\"$zreng_tcps_opts\" zreng_udps_opts=\"$zreng_udps_opts\"" >> /tmp/zeroe/vars.zre
	fi
fi

#cd to the output dir for better masscan resuming
cd $filepath
#Sets trap for when script stops before finishing
trap whenstopped INT TERM

echo -e "\e[35m \n [=] Zero-E started -- progress updates for scans displayed every 15 minutes \e[0m" | tee -a $filepath/logs/$typevar-timestamps.log

#=============EXTERNAL=============
if [ "$e_opt" = true ] || [ "$type" = "E" ] || [ "$type" = "e" ] || [ "$type" = "external" ] || [ "$type" = "External" ] || [ "$type" = "Ext" ] || [ "$type" = "ext" ]; then

	#Stage -- start
	if { [[ "$stage" == "discovery-alives" ]] || [[ "$stage" == "script-start" ]]; } && ! { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]]; }; then
		echo "discovery-alives" > /tmp/zeroe/stage.zre
		stage="discovery-alives"

		if [[ "$stage" == "discovery-alives" ]] && [[ "$resume" = "y" ]]; then
			echo -e "\e[36m [-] Resuming alive host discovery scans -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			echo -e "\e[36m     Using options from resumed scan \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		else
			echo -e "\e[36m [-] Starting discovery scans -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		fi

		###Nmap alive host discovery
		echo -ne "\e[36m [-] Discovering alive hosts with Nmap... \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		echo ""
		ntdscan="nmap -n -vv -sn -oG - --excludefile $nostrikes -iL $ips" #Stored as variable for report generation
		echo "ntdscan=\"$ntdscan\"" >> /tmp/zeroe/vars.zre
		if [[ "$resume" = "y" ]]; then
			resume=''
			nmap --resume "$filepath/logs/misc-files/$typevar-discoscan-nmap.gnmap" 1>>"$filepath/logs/misc-files/$typevar-discoscan-nmap.gnmap" 2>>"$filepath/logs/$typevar-errors.log" &
			echo -e "\e[36m     Using options from resumed scan \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		else
			#if [[ "$ngineer_mode" == true ]]; then
			#	if [[ "$ngineer_default" == true ]]; then	
			#		eval "$ntdscan" 1>>"$filepath/logs/misc-files/$typevar-discoscan-nmap.gnmap" 2>>"$filepath/logs/$typevar-errors.log" &  #TCP ping scan
			#	else
			#		eval "$zreng_ext_alives - -oG --excludefile $nostrikes -iL $ips" 1>>"$filepath/logs/misc-files/$typevar-discoscan-nmap.gnmap" 2>>"$filepath/logs/$typevar-errors.log" &
			#	fi
			#else
				eval "$ntdscan" 1>>"$filepath/logs/misc-files/$typevar-discoscan-nmap.gnmap" 2>>"$filepath/logs/$typevar-errors.log" &
			#fi
		fi
		#Status indicator
		pid=$!
		periodicfile="$filepath/logs/misc-files/$typevar-discoscan-nmap.gnmap"
		contstatus="Pinging hosts"
		statusnmap
		#Error check and alert
		checked_cmd="$ntdscan"
		wait $pid
		exitstatus=$?
		errorcheck	

		printf "\033[A\r\e[K\e[32m [+] Discovering alive hosts with Nmap... Done \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		#Generate alives file
		cat "$filepath/logs/misc-files/$typevar-discoscan-nmap.gnmap" | grep 'Up' | awk '{print $2}' | sort -u | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n > $filepath/$typevar-alives.txt
		if [[ "$stage" == "discovery-alives" ]] && [[ "$only_flag" == true ]]; then	
			if grep -q "\S" "$filepath/$typevar-alives.txt"; then
				echo "" | tee -a "$filepath/logs/$typevar-timestamps.log"
				echo -e "\e[32m [+] Alive hosts discovered -- "$(date)" \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			else
				echo -e "\e[33m [!] No alive hosts detected \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			fi
		fi
		#Stage update
		if [[ "$only_flag" != true && "$stage_cont" == true ]]; then
			echo "discovery-ports" > /tmp/zeroe/stage.zre
			stage="discovery-ports"
		fi
	fi

	#Stage -- start
	if [[ "$stage" == "discovery-ports" ]] && ! { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]]; }; then
		#Masscan open port/alive host discovery
		####################################################################
		####### External masscan command if adjustment is necessary ########
		emscan="sudo masscan --open-only -p 1-65535 --rate=5000 --excludefile $nostrikes --include-file $ips -oG $filepath/logs/misc-files/$typevar-discoscan-masscan-tcp.txt"
		echo "emscan=\"$emscan\"" >> /tmp/zeroe/vars.zre
		### Stored as variable to correctly reflect in report if changed ###
		####################################################################
		#^^^If scans are taking too long, remove -p 1-65535 and use --top-ports=32768
		if [[ "$stage" == "discovery-ports" ]] && [[ -f "$(pwd)/paused.conf" ]] && [[ "$resume" = "y" ]]; then
			resume=''
			echo -e "\e[36m [-] Resuming discovery scans -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			echo -e "\e[36m     Using options from resumed scan \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			masscan --resume paused.conf >> "$filepath/logs/misc-files/$typevar-masscan-tcp.log" 2>&1 &
		else
			if [[ "$ngineer_mode" == true ]]; then
				if [[ "$ngineer_ports_default" == true ]]; then	
					eval "$emscan" >> "$filepath/logs/misc-files/$typevar-masscan-tcp.log" 2>&1 &
				else
					echo -e "\e[33m [!] Using ZrE ngineer options for masscan discovery scan \e[0m"
					eval "masscan $zreng_ports_opts --open-only --excludefile $nostrikes --include-file $ips -oG $filepath/logs/misc-files/$typevar-discoscan-masscan-tcp.txt" >> "$filepath/logs/misc-files/$typevar-masscan-tcp.log" 2>&1 &
				fi
			else
				eval "$emscan" >> "$filepath/logs/misc-files/$typevar-masscan-tcp.log" 2>&1 &
			fi
		fi
		pid=$!
		sleep 4
		if [[ "$only_flag" != true ]]; then #Prevents unwanted newline in terminal output
		    if ! tail -n 1 "$filepath/logs/$typevar-timestamps.log" | grep -q 'Zero-E started'; then
		        echo "" | tee -a "$filepath/logs/$typevar-timestamps.log"
		    fi
		fi
		echo -ne "\e[36m [-] Discovering alive hosts and open TCP ports with Masscan... $(grep -o '[0-9]\+:[0-9]\+:[0-9]\+ remaining' "$filepath/logs/misc-files/$typevar-masscan-tcp.log" | tail -1) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		echo ""
		#Status indicator
		periodicfile="$filepath/logs/misc-files/$typevar-masscan-tcp.log"
		contstatus="Scanning TCP ports"
		statusmasscan
		#Error check and alert
		checked_cmd="$emscan"
		wait $pid
		exitstatus=$?
		errorcheck

		printf "\033[A\r\e[K\e[32m [+] Discovering alive hosts and open TCP ports with Masscan... Done\e[0m\n" | tee -a "$filepath/logs/$typevar-timestamps.log"
		#Filter out hosts with more than 100 ports open
		susinput="$filepath/logs/misc-files/$typevar-discoscan-masscan-tcp.txt"
		susips="$filepath/$typevar-100port-hosts-tcp.txt"
		susoutput="$filepath/logs/misc-files/$typevar-discoscan-masscan-tcp-nosusips.txt"
		filtersusips 2>>"$filepath/logs/$typevar-errors.log"

		#Carve out Nmap TCP IP addresses and put them into a file
		if [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ]; then
			awk 'NR==FNR{ips[$0];next} {for (ip in ips) if ($0 !~ ip) print}' $filepath/$typevar-100port-hosts-tcp.txt "$filepath/logs/misc-files/$typevar-discoscan-nmap.gnmap" > $filepath/logs/misc-files/$typevar-discoscan-nmap-nosusips.txt #Filter out hosts with more than 100 open tcp ports from the nmap ping scan results
			cat $filepath/logs/misc-files/$typevar-discoscan-nmap-nosusips.txt | grep 'Up' | awk '{print $2}' >> $filepath/logs/misc-files/$typevar-discoresults.txt
		else
			cat "$filepath/logs/misc-files/$typevar-discoscan-nmap.gnmap" | grep 'Up' | awk '{print $2}' >> $filepath/logs/misc-files/$typevar-discoresults.txt
		fi

		#Carve out Masscan TCP IP addresses and put them into a file
		{ cat $filepath/logs/misc-files/$typevar-discoscan-masscan-tcp-nosusips.txt | grep 'Host' | awk '{print $4}' ; } >> $filepath/logs/misc-files/$typevar-discoresults.txt # this excludes 100port-hosts. {;} groups the piped commands so all output is redirected

		#Generate list of alive hosts
		cat $filepath/logs/misc-files/$typevar-discoresults.txt | sort -u | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n >> $filepath/$typevar-alives.txt
		cp $filepath/$typevar-alives.txt $filepath/$typevar-alives-tmp.txt
		cat $filepath/$typevar-alives-tmp.txt | sort -u | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n > $filepath/$typevar-alives.txt
		rm $filepath/$typevar-alives-tmp.txt

		#Stage -- update
		if [ "$udp" = "y" ] || [ "$udp" = "yes" ] || [ "$U_opt" = true ]; then
			echo "discovery-udp" > /tmp/zeroe/stage.zre
			stage="discovery-udp"
		elif [[ "$stage_cont" == true ]] || { [[ "$stage" == "discovery-ports" ]] && [[ "$only_flag" == true ]]; }; then
			echo "discovery-lists" > /tmp/zeroe/stage.zre
			stage="discovery-lists"
		fi

	fi

	#Stage -- start
	if { [[ "$stage" == "discovery-udp" ]] && [[ "$udp" = "y" || "$udp" = "yes" || "$U_opt" = true ]]; } || { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]] && [[ "$stage" != "discovery-lists" && "$stage" != "services-udp" ]]; }; then
		#UDP open port scan
		#15094 top ports is 99% effective. Reference this chart for --top-port number effectiveness: https://nmap.org/book/performance-port-selection.html
		nudpa="nmap -v -Pn -sU --open --min-rate 1000 --max-rate 3000 --top-ports 15094 --max-retries 3 --host-timeout 30 -oG "$filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap" --excludefile $nostrikes -iL $ips -d"
		if [[ "$resume" = "y" ]]; then
			resume=''
			echo -e "\e[36m [-] Resuming UDP discovery scans -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			echo -e "\e[36m     Using options from resumed scan \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			nmap --resume "$filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap" >> $filepath/logs/misc-files/$typevar-discoscan-nmap-udp.log 2>>"$filepath/logs/$typevar-errors.log" &
		else
			if [[ "$ngineer_mode" == true ]]; then
				if [[ "$ngineer_udpa_default" == true ]]; then	
					eval "$nudpa" >> $filepath/logs/misc-files/$typevar-discoscan-nmap-udp.log 2>>"$filepath/logs/$typevar-errors.log" &
				else
					echo -e "\e[33m [!] Using ZrE ngineer options for Nmap UDP discovery scan \e[0m"
					eval "nmap -sU --open $zreng_udpa_opts -oG "$filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap" --excludefile $nostrikes -iL $ips -d" >> "$filepath/logs/misc-files/$typevar-discoscan-nmap-udp.log" 2>>"$filepath/logs/$typevar-errors.log" &
				fi
			else
				eval "$nudpa" >> $filepath/logs/misc-files/$typevar-discoscan-nmap-udp.log 2>>"$filepath/logs/$typevar-errors.log" &
			fi
		fi
		pid=$!
		echo -ne "\e[36m [-] Discovering alive hosts and open UDP ports with Nmap... \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		echo ""
		#Status indicator
		periodicfile="$filepath/logs/misc-files/$typevar-discoscan-nmap-udp.log"
		contstatus="Scanning UDP ports"
		statusnmap
		#Error check and alert
		checked_cmd="nmap -v -Pn -sU --open --min-rate 1000 --max-rate 3000 --top-ports 15094 --max-retries 3 --host-timeout 30 -oG "$filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap" --excludefile $nostrikes -iL $ips -d"
		wait $pid
		exitstatus=$?
		errorcheck
		
		printf "\033[A\r\e[K\e[32m [+] Discovering alive hosts and open UDP ports with Nmap... Done\e[0m\n" | tee -a "$filepath/logs/$typevar-timestamps.log"
		#Carve out UDP IP addresses and put them into a file
		if [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ]; then
			awk 'NR==FNR{ips[$0];next} {for (ip in ips) if ($0 !~ ip) print}' $filepath/$typevar-100port-hosts-tcp.txt "$filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap" > $filepath/logs/misc-files/$typevar-discoscan-nmap-udp-nosusips.txt #Filter out hosts with more than 100 open tcp ports
			cat $filepath/logs/misc-files/$typevar-discoscan-nmap-udp-nosusips.txt | grep '/open' | cut -d ' ' -f2 >> $filepath/logs/misc-files/$typevar-discoresults.txt
		else
			cat "$filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap" | grep '/open' | cut -d ' ' -f2 >> $filepath/logs/misc-files/$typevar-discoresults.txt
		fi
		
		#Stage -- update
		echo "discovery-lists" > /tmp/zeroe/stage.zre
		stage="discovery-lists"
	fi

	#Stage -- start
	if [[ "$stage" == "discovery-lists" ]]; then
		#Make final list of ordered, unique alive hosts excluding sus ips
		cat $filepath/logs/misc-files/$typevar-discoresults.txt | sort -u | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n >> $filepath/$typevar-alives.txt
		cp $filepath/$typevar-alives.txt $filepath/$typevar-alives-tmp.txt
		cat $filepath/$typevar-alives-tmp.txt | sort -u | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n > $filepath/$typevar-alives.txt
		rm $filepath/$typevar-alives-tmp.txt

		#Generate list of all open ports
		if ! { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]]; }; then
			#echo '===========' > $filepath/$typevar-openPorts.txt
			#echo '    TCP' >> $filepath/$typevar-openPorts.txt
			#echo '===========' >> $filepath/$typevar-openPorts.txt
			cat $filepath/logs/misc-files/$typevar-discoscan-masscan-tcp-nosusips.txt | grep 'open' | cut -d ' ' -f5 | cut -d '/' -f1 | sort -u >> $filepath/rangetemp.txt
			#continue with ports list
			rangeout="$filepath/logs/misc-files/$typevar-portsfornmap-tcp.txt"
			singleportstorange
			sed -i '/^[ \t]*$/d' "$rangeout" #Removes blank lines and lines that only contain spaces
			cat $filepath/logs/misc-files/$typevar-portsfornmap-tcp.txt > $filepath/$typevar-openPorts.txt
			sed -i 's/^/TCP\//' $filepath/$typevar-openPorts.txt
			#echo ' ' >> $filepath/$typevar-openPorts.txt
		fi
		if [ "$udp" = "y" ] || [ "$udp" = "yes" ] || [ "$U_opt" = true ]; then
			if [[ "$only_flag" == true ]]; then
				rm $filepath/$typevar-openPorts.txt 2>/dev/null
			#	echo '===========' > $filepath/$typevar-openPorts.txt
			#else
			#	echo '===========' >> $filepath/$typevar-openPorts.txt
			fi
			#echo '    UDP' >> $filepath/$typevar-openPorts.txt
			#echo '===========' >> $filepath/$typevar-openPorts.txt
			if [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ]; then
				cat $filepath/logs/misc-files/$typevar-discoscan-nmap-udp-nosusips.txt | grep '/open' | cut -d ' ' -f4 | cut -d '/' -f1 | sort -u >> $filepath/rangetempu.txt
			else
				cat "$filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap" | grep '/open' | cut -d ' ' -f4 | cut -d '/' -f1 | sort -u >> $filepath/rangetempu.txt
			fi
			sort -u $filepath/rangetempu.txt >> $filepath/rangetemp.txt
			rm $filepath/rangetempu.txt
			rangeout="$filepath/logs/misc-files/$typevar-portsfornmap-udp.txt"
			singleportstorange
			sed -i '/^[ \t]*$/d' "$rangeout" #Removes blank lines and lines that only contain spaces
			cat $filepath/logs/misc-files/$typevar-portsfornmap-udp.txt >> $filepath/$typevar-openPorts.txt
			sed -i '/^TCP\//! s/^/UDP\//' $filepath/$typevar-openPorts.txt
		fi
		nessusports 2>/dev/null

		#Status update
		alivesandportscheck
		if [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ] && [ -s "$filepath/$typevar-100port-hosts-udp.txt" ]; then
			echo -e "\e[33m [!] Excluding potential deception or firewall-protected hosts showing more than 100 open TCP/UDP ports -- recommend inquiring about hosts in ext-100port-hosts-tcp.txt and ext-100port-hosts-udp.txt \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		elif [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ]; then
			echo -e "\e[33m [!] Excluding potential deception or firewall-protected hosts showing more than 100 open TCP ports -- recommend inquiring about hosts in ext-100port-hosts-tcp.txt \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		elif [ -s "$filepath/$typevar-100port-hosts-udp.txt" ]; then
			echo -e "\e[33m [!] Excluding potential deception or firewall-protected hosts showing more than 100 open UDP ports -- recommend inquiring about hosts in ext-100port-hosts-udp.txt \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		fi
		echo -e "\e[33m [!] Generated files for Nessus vulnerability scans -- Hosts: $typevar-alives.txt | Ports: $typevar-portsForNessus.txt \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
	
		#Stage -- update
		if [[ "$only_flag" != true && "$stage_cont" == true ]]; then
			echo "services-tcp" > /tmp/zeroe/stage.zre
			stage="services-tcp"
		elif { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]] && [[ "$stage_cont" == true ]]; }; then
			echo "services-udp" > /tmp/zeroe/stage.zre
			stage="services-udp"
		fi
	
	fi
	
	#Stage -- start
	if [[ "$stage" == "services-tcp" ]]; then
		##Nmap TCP service scans
		#ntportsall="$(cat $filepath/logs/misc-files/$typevar-portsfornmap-tcp.txt | paste -sd "," -)"
		#ntports3=$($(head -n 3 $filepath/logs/misc-files/$typevar-portsfornmap-tcp.txt | paste -sd "," -),[...])
		ntscan="nmap -sC -sV -Pn -O -p $(cat $filepath/logs/misc-files/$typevar-portsfornmap-tcp.txt | paste -sd "," -) --open --reason --excludefile $nostrikes -iL $filepath/$typevar-alives.txt -oA $filepath/$typevar-tcp-servicescan-results"
		echo "ntscan=\"$ntscan\"" >> /tmp/zeroe/vars.zre
		if grep -q "\S" "$filepath/logs/misc-files/$typevar-portsfornmap-tcp.txt"; then
			if [[ "$resume" = "y" ]]; then
				resume=''
				echo -e "\e[36m [-] Resuming TCP service scans \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				echo -e "\e[36m     Using options from resumed scan \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				nmap --resume $filepath/$typevar-tcp-servicescan-results.gnmap 1>/dev/null 2>>$filepath/logs/$typevar-errors.log &
			else
				if [[ "$ngineer_mode" == true ]]; then
					if [[ "$ngineer_tcps_default" == true ]]; then	
						eval "$ntscan -v" 1>/dev/null 2>>$filepath/logs/$typevar-errors.log &
					else
						echo -e "\e[33m [!] Using ZrE ngineer options for Nmap TCP service scan \e[0m"
						eval "nmap $zreng_tcps_opts -sV -Pn -p $(cat $filepath/logs/misc-files/$typevar-portsfornmap-tcp.txt | paste -sd "," -) --reason -oA $filepath/$typevar-tcp-servicescan-results --excludefile $nostrikes -iL $filepath/$typevar-alives.txt" 1>/dev/null 2>>$filepath/logs/$typevar-errors.log &
					fi
				else
					eval "$ntscan -v" 1>/dev/null 2>>$filepath/logs/$typevar-errors.log &
				fi
			fi
			pid=$!
			echo -e "\e[36m [-] Scanning services on open TCP ports of alive hosts with Nmap -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			#Status indicator
			periodicfile="$filepath/$typevar-tcp-servicescan-results.nmap"
			contstatus="Scanning TCP ports"
			statusnmap
			#Error check and alert
			checked_cmd="$ntscan"
			wait $pid
			exitstatus=$?
			if [ $exitstatus -eq 0 ]; then
				printf "\r%-${#indicator}s\r" "" #Clears status indicator line
				if [ "$udp" = "y" ] || [ "$udp" = "yes" ] || [ "$U_opt" = true  ]; then
					echo -e "\e[32m [+] Nmap TCP service scan complete, results saved as ext-tcp-servicescan-results -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
					#echo -e "\e[33m [!] Start working with TCP scan results. UDP scans may take a while, depending on the amount of hosts and ports. \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				else
					echo -e "\e[32m [+] Nmap TCP service scan complete, results saved as ext-tcp-servicescan-results -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				fi
			else
				printf "\r%-${#indicator}s\r" "" #Clears status indicator line
				errorcheck
			fi

			genwindowshostlist_inscript
			listiptohostname_inscript
			parsegrepnmap_inscript=true
			parsegrepnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 139,445,137,138 "$filepath/analysis/$typevar-smbHosts.txt"
			parsegrepnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 80,443,8080,8443,8000,8008,8888 "$filepath/analysis/$typevar-httpHosts.txt"
			parsegrepnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 22,23,3389,5985,5986,5900,5800,1494,5631,5632 "$filepath/analysis/$typevar-remoteAccessHosts.txt"
			parsegrepnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 1723,1194 "$filepath/analysis/$typevar-vpnHosts.txt"
			parsegrepnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 20,21,22,69,111,873,990,2049,3260 "$filepath/analysis/$typevar-fileshareHosts.txt"
			parsegrepnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 3306,5432,1433,1521 "$filepath/analysis/$typevar-databaseHosts.txt"
			parsegrepnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 25,465,587,143,993,110,995 "$filepath/analysis/$typevar-emailHosts.txt"
			parsegrepnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 389,636 "$filepath/analysis/$typevar-ldapHosts.txt"
		else
			echo -e "\e[33m [!] No open TCP ports detected -- TCP service scans skipped \e[0m" | tee -a $filepath/logs/$typevar-timestamps.log
		fi
	
		#Stage -- update
		if { [ "$udp" = "y" ] || [ "$udp" = "yes" ] || [ "$U_opt" = true ]; } && [[ "$stage_cont" == true ]]; then
			echo "services-udp" > /tmp/zeroe/stage.zre
			stage="services-udp"
		fi
	
	fi

	#Stage -- start
	if [[ "$stage" == "services-udp" ]] && [[ "$udp" = "y" || "$udp" = "yes"  || "$U_opt" = true ]]; then
		#Nmap UDP service scans
		nsudp="nmap -v -sU -Pn -sV --open --min-rate 1000 --max-rate 3000 --reason -p $(cat $filepath/logs/misc-files/$typevar-portsfornmap-udp.txt | paste -sd "," -) -oA $filepath/$typevar-udp-servicescan-results --excludefile $nostrikes -iL $filepath/$typevar-alives.txt" 
		if grep -q "\S" "$filepath/logs/misc-files/$typevar-portsfornmap-udp.txt"; then
			if [[ "$resume" = "y" ]]; then
				resume=''
				echo -e "\e[36m [-] Resuming UDP service scans \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				echo -e "\e[36m     Using options from resumed scan \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				nmap --resume $filepath/$typevar-udp-servicescan-results.gnmap 1>/dev/null 2>>$filepath/logs/$typevar-errors.log &
			else
				if [[ "$ngineer_mode" == true ]]; then
					if [[ "$ngineer_udps_default" == true ]]; then	
						eval "$nsudp" 1>/dev/null 2>>$filepath/logs/$typevar-errors.log &
					else
						echo -e "\e[33m [!] Using ZrE ngineer options for Nmap UDP service scan \e[0m"
						eval "nmap $zreng_udps_opts -sU -sV -Pn --reason -p $(cat $filepath/logs/misc-files/$typevar-portsfornmap-udp.txt | paste -sd "," -) -oA $filepath/$typevar-udp-servicescan-results --excludefile $nostrikes -iL $filepath/$typevar-alives.txt" 1>/dev/null 2>>$filepath/logs/$typevar-errors.log &
					fi
				else
					eval "$nsudp -v" 1>/dev/null 2>>$filepath/logs/$typevar-errors.log &
				fi
			fi
			pid=$!
			echo -e "\e[36m [-] Scanning services on open UDP ports of alive hosts with Nmap -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			#Status indicator
			periodicfile="$filepath/$typevar-udp-servicescan-results.nmap"
			contstatus="Scanning UDP ports"
			statusnmap
			#Error check and alert
			checked_cmd="nmap -v -sU -Pn -sV --open --min-rate 1000 --max-rate 3000 --reason -p $(cat $filepath/logs/misc-files/$typevar-portsfornmap-udp.txt | paste -sd "," -) -oA $filepath/$typevar-udp-servicescan-results --excludefile $nostrikes -iL $filepath/$typevar-alives.txt 1>/dev/null 2>>$filepath/logs/$typevar-errors.log &"
			wait $pid
			exitstatus=$?
			if [ $exitstatus -eq 0 ]; then
				printf "\r%-${#indicator}s\r" "" #Clears status indicator line
				echo -e "\e[32m [+] Nmap UDP service scan complete, results saved as ext-udp-servicescan-results -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			else
				printf "\r%-${#indicator}s\r" "" #Clears status indicator line
				errorcheck
			fi

			genwindowshostlist_inscript
			listiptohostname_inscript
		else
			echo -e "\e[33m [!] No open UDP ports detected -- UDP service scans skipped \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		fi
	fi

	echo -e "\e[35m [=] Zero-E completed -- happy hacking! \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
	zrecleanup
fi
###===========INTERNAL=============
if [ "$i_opt" = true ] || [ "$type" = "I" ] || [ "$type" = "i" ] || [ "$type" = "internal" ] || [ "$type" = "Internal" ] || [ "$type" = "Int" ] || [ "$type" = "int" ]; then

	#Stage -- start
	if { [[ "$stage" == "discovery-alives" ]] || [[ "$stage" == "script-start" ]]; } && ! { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]]; }; then
		echo "discovery-alives" > /tmp/zeroe/stage.zre
		stage="discovery-alives"

		#cidrconvert >> $filepath/logs/$typevar-fpingcidrs.txt
		if [[ "$stage" == "discovery-alives" ]] && [[ "$resume" = "y" ]]; then
			resume="y"
			echo -e "\e[36m [-] Resuming alive host discovery scans -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			echo -e "\e[36m     Using options from resumed scan \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		else
			echo -e "\e[36m [-] Starting discovery scans -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		fi
		#Prevent system from sending RST packets by setting the firewall to block packets returning to the Masscan origin port
		setfirewallrule

		#Masscan alive host discovery
		alivesmscan="sudo masscan --rate=8000 --src-port=55555 --excludefile $nostrikes --include-file $ips -oG $filepath/logs/misc-files/$typevar-masscanalives-results.txt"
		if [[ "$stage" == "discovery-alives" ]] && [[ -f "$(pwd)/paused.conf" ]] && [[ "$resume" = "y" ]]; then
			resume=''
			{ masscan --resume paused.conf >> "$filepath/logs/misc-files/$typevar-masscan-tcp.log" 2>&1 & } && sleep 2
		elif [[ "$stage" == "discovery-alives" ]] || [[ "$stage" == "discovery-alives" && ! -f "$(pwd)/paused.conf" && "$resume" = "y" ]]; then
			if [[ "$stage" == "discovery-alives" && ! -f "$(pwd)/paused.conf" && "$resume" = "y" ]]; then
				echo -e "\e[33m [!] masscan paused.conf file not found -- restarting alive host discovery scans \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			fi
			#fpscan='while IFS= read -r i; do fping -a -q -g "$i" >> "$#filepath/$typevar-fping-results.txt"; done < "$filepath/logs/$typevar-fpingcidrs.txt"'
			if (($total_hosts >= 1 && $total_hosts <= 9999)); then
				checked_cmd="$alivesmscan --top-ports 5000 && sleep 1"
				eval "$alivesmscan --top-ports 5000 && sleep 1" >> "$filepath/logs/misc-files/$typevar-masscan-tcp.log" 2>&1 &
			elif (($total_hosts >= 10000 && $total_hosts <= 24999)); then
				checked_cmd="$alivesmscan --top-ports 2000 && sleep 1"
				eval "$alivesmscan --top-ports 2000 && sleep 1" >> "$filepath/logs/misc-files/$typevar-masscan-tcp.log" 2>&1 &
			elif (($total_hosts >= 25000 && $total_hosts <= 49999)); then
				checked_cmd="$alivesmscan --top-ports 1500 && sleep 1"
				eval "$alivesmscan --top-ports 1500 && sleep 1" >> "$filepath/logs/misc-files/$typevar-masscan-tcp.log" 2>&1 &
			elif (($total_hosts >= 50000 && $total_hosts <= 99999)); then
				checked_cmd="$alivesmscan --top-ports 1000 && sleep 1"
				eval "$alivesmscan --top-ports 1000 && sleep 1" >> "$filepath/logs/misc-files/$typevar-masscan-tcp.log" 2>&1 &
			elif (($total_hosts >= 100000 && $total_hosts <= 149999)); then
				checked_cmd="$alivesmscan --top-ports 500 && sleep 1"
				eval "$alivesmscan --top-ports 500 && sleep 1" >> "$filepath/logs/misc-files/$typevar-masscan-tcp.log" 2>&1 &
			elif (($total_hosts >= 150000 && $total_hosts <= 199999)); then
				checked_cmd="$alivesmscan --top-ports 250 && sleep 1"
				eval "$alivesmscan --top-ports 250 && sleep 1" >> "$filepath/logs/misc-files/$typevar-masscan-tcp.log" 2>&1 &
			elif (($total_hosts >= 200000 && $total_hosts <= 249999)); then
				checked_cmd="$alivesmscan --top-ports 150 && sleep 1"
				eval "$alivesmscan --top-ports 150 && sleep 1" >> "$filepath/logs/misc-files/$typevar-masscan-tcp.log" 2>&1 &
			elif (($total_hosts >= 250000 && $total_hosts <= 499999)); then
				checked_cmd="$alivesmscan --top-ports 50 && sleep 1"
				eval "$alivesmscan --top-ports 50 && sleep 1" >> "$filepath/logs/misc-files/$typevar-masscan-tcp.log" 2>&1 &
			elif (($total_hosts >= 500000)); then
				checked_cmd="$alivesmscan --top-ports 20 && sleep 1"
				eval "$alivesmscan --top-ports 20 && sleep 1" >> "$filepath/logs/misc-files/$typevar-masscan-tcp.log" 2>&1 &
			fi
			pid=$!
			sleep 4
			echo -ne "\e[36m [-] Discovering alive hosts with masscan... $(grep -o '[0-9]\+:[0-9]\+:[0-9]\+ remaining' "$filepath/logs/misc-files/$typevar-masscan-tcp.log" | tail -1) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			echo ""
			#Status indicator
			periodicfile="$filepath/logs/misc-files/$typevar-masscan-tcp.log"
			contstatus="Scanning hosts"
			statusmasscan
			#Error check and alert
			wait $pid
			exitstatus=$?
			errorcheck
		fi 

		printf "\033[A\r\e[K\e[32m [+] Discovering alive hosts with Masscan... Done\e[0m\n" | tee -a "$filepath/logs/$typevar-timestamps.log"
		#Filter out hosts with more than 100 ports open
		susinput="$filepath/logs/misc-files/$typevar-masscanalives-results.txt"
		susips="$filepath/$typevar-100port-hosts-tcp.txt"
		susoutput="$filepath/logs/misc-files/$typevar-discoscan-masscan-tcp-nosusips.txt"
		filtersusips
		#Carve out TCP IP addresses and put them into a file
		cat $filepath/logs/misc-files/$typevar-discoscan-masscan-tcp-nosusips.txt | grep 'Host' | awk '{print $4}' >> "$filepath/logs/misc-files/$typevar-discoresults.txt" #this excludes 100port-hosts
		#cat $filepath/logs/misc-files/$typevar-masscanalives-results.txt | grep 'Host' | awk '{print $4}' | sort -u >> $filepath/$typevar-masscan-alives.txt

		#Generate alives file
		cat "$filepath/logs/misc-files/$typevar-discoresults.txt" | sort -u | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n > "$filepath/$typevar-alives.txt"
		if [[ "$stage" == "discovery-alives" ]] && [[ "$only_flag" == true ]]; then
			if grep -q "\S" "$filepath/$typevar-alives.txt"; then
				echo -e "\e[32m [+] Alive hosts discovered -- "$(date)" \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			else
				echo -e "\e[33m [!] No alive hosts detected -- if unexpected, check targets or inquire about scan defenses or other interference \e[0m" | tee -a $filepath/logs/$typevar-timestamps.log
				#Remove firewall rule
				removefirewallrule
				echo -e "\e[33m [!] Exiting Zero-E... \e[0m" | tee -a $filepath/logs/$typevar-timestamps.log
				zrecleanup
				exit 1
			fi
		else
			if ! grep -q "\S" "$filepath/logs/misc-files/$typevar-discoresults.txt" 2>/dev/null; then
				echo -e "\e[33m [!] No alive hosts detected -- if unexpected, check targets or inquire about scan defenses or other interference \e[0m" | tee -a $filepath/logs/$typevar-timestamps.log
				#Remove firewall rule
				removefirewallrule
				echo -e "\e[33m [!] Exiting Zero-E... \e[0m" | tee -a $filepath/logs/$typevar-timestamps.log
				zrecleanup
				exit 1
			fi
		fi

		#Stage -- update
		if [[ "$only_flag" != true && "$stage_cont" == true ]]; then
			echo "discovery-ports" > /tmp/zeroe/stage.zre
			stage="discovery-ports"
		fi

	fi
	
	#Stage -- start
	if [[ "$stage" == "discovery-ports" ]] && ! { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]]; }; then
		
		setfirewallrule
		#Masscan open port discovery
		####################################################################
		####### Internal masscan command if adjustment is necessary ########
		imscan="sudo masscan --open-only -p 1-65535 --rate=8000 --src-port=55555 --excludefile $nostrikes --include-file "$filepath/$typevar-alives.txt" -oG $filepath/logs/misc-files/$typevar-discoscan-masscan-tcp.txt"
		echo "imscan=\"$imscan\"" >> /tmp/zeroe/vars.zre
		### Stored as variable to correctly reflect in report if changed ###
		####################################################################
		#^^^If scans are taking too long, remove -p 1-65535 and use --top-ports=32768
		#^^^If not getting any, or low number of, alive hosts, use --rate=500
		if [[ "$stage" == "discovery-ports" ]] && [[ -f "$(pwd)/paused.conf" ]] && [[ "$resume" = "y" ]]; then
			resume=''
			echo -e "\e[36m [-] Resuming masscan open port discovery scans -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			echo -e "\e[36m     Using options from resumed scan \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			if [[ "$firewallset" != true ]]; then
				setfirewallrule
			fi
			masscan --resume paused.conf >> "$filepath/logs/misc-files/$typevar-masscan-tcp.log" 2>&1 &
		else
			if [[ "$ngineer_mode" == true ]]; then #for ngineer mode
				if [[ "$ngineer_ports_default" == true ]]; then	
					if [[ "$firewallset" != true ]]; then
						setfirewallrule
					fi
					eval "$imscan" >> "$filepath/logs/misc-files/$typevar-masscan-tcp.log" 2>&1 &
				else
					echo -e "\e[33m [!] Using ZrE ngineer options for masscan open ports scan \e[0m"
					if [[ "$firewallset" != true ]]; then
						setfirewallrule
					fi
					eval "masscan $zreng_ports_opts --open-only --excludefile $nostrikes --include-file $filepath/$typevar-alives.txt -oG $filepath/logs/misc-files/$typevar-discoscan-masscan-tcp.txt" >> "$filepath/logs/misc-files/$typevar-masscan-tcp.log" 2>&1 &
				fi
			else
				if [[ "$firewallset" != true ]]; then
					setfirewallrule
				fi
				eval "$imscan" >> "$filepath/logs/misc-files/$typevar-masscan-tcp.log" 2>&1 &
			fi
		fi
		pid=$!
		sleep 4
		echo -ne "\e[36m [-] Discovering open TCP ports with Masscan... $(grep -o '[0-9]\+:[0-9]\+:[0-9]\+ remaining' "$filepath/logs/misc-files/$typevar-masscan-tcp.log" | tail -1) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		echo ""
		#Status indicators
		periodicfile="$filepath/logs/misc-files/$typevar-masscan-tcp.log"
		contstatus="Scanning TCP ports"
		statusmasscan
		#Error check and alert
		checked_cmd="$imscan"
		wait $pid
		exitstatus=$?
		errorcheck

		printf "\033[A\r\e[K\e[32m [+] Discovering open TCP ports with Masscan... Done\e[0m\n" | tee -a "$filepath/logs/$typevar-timestamps.log"
		#Filter out hosts with more than 100 ports open
		susinput="$filepath/logs/misc-files/$typevar-discoscan-masscan-tcp.txt"
		susips="$filepath/$typevar-100port-hosts-tcp.txt"
		susoutput="$filepath/logs/misc-files/$typevar-discoscan-masscan-tcp-nosusips.txt"
		filtersusips
		#Carve out TCP IP addresses and put them into a file
		cat $filepath/logs/misc-files/$typevar-discoscan-masscan-tcp-nosusips.txt | grep 'Host' | awk '{print $4}' >> $filepath/logs/misc-files/$typevar-discoresults.txt #this excludes 100port-hosts

		#Generate list of alive hosts
		cat $filepath/logs/misc-files/$typevar-discoresults.txt | sort -u | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n >> $filepath/$typevar-alives.txt
		cp $filepath/$typevar-alives.txt $filepath/$typevar-alives-tmp.txt
		cat $filepath/$typevar-alives-tmp.txt | sort -u | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n > $filepath/$typevar-alives.txt
		rm $filepath/$typevar-alives-tmp.txt

		#Stage -- update
		if [ "$udp" = "y" ] || [ "$udp" = "yes" ] || [ "$U_opt" = true ]; then
			echo "discovery-udp" > /tmp/zeroe/stage.zre
			stage="discovery-udp"
		elif [[ "$stage_cont" == true ]] || { [[ "$stage" == "discovery-ports" ]] && [[ "$only_flag" == true ]]; }; then
			echo "discovery-lists" > /tmp/zeroe/stage.zre
			stage="discovery-lists"
		fi

	fi

	#Stage -- start
	if { [[ "$stage" == "discovery-udp" ]] && [[ "$udp" = "y" || "$udp" = "yes" || "$U_opt" = true ]]; } || { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]] && [[ "$stage" != "discovery-lists" && "$stage" != "services-udp" ]]; }; then
		#UDP open port scan
		if [[ "$resume" = "y" ]]; then
			resume=''
			echo -e "\e[36m [-] Resuming UDP discovery scans -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			echo -e "\e[36m     Using options from resumed scan \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			nmap --resume "$filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap" >> $filepath/logs/misc-files/$typevar-discoscan-nmap-udp.log 2>>"$filepath/logs/$typevar-errors.log" &
		else
			if [[ "$ngineer_mode" == true ]]; then
				if [[ "$ngineer_udpa_default" == true ]]; then
					if [[ -f $filepath/logs/misc-files/$typevar-discoresults.txt ]]; then
						#15094 top ports is 99% effective. Reference this chart for --top-port number effectiveness: https://nmap.org/book/performance-port-selection.html
						nudpa="nmap -v -Pn -sU --open --min-rate 3000 --max-rate 5000 --top-ports 15094 --max-retries 3 --host-timeout 30 -oG $filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap --excludefile $nostrikes -iL $filepath/logs/misc-files/$typevar-discoresults.txt -d"
					else
						nudpa="nmap -v -Pn -sU --open --min-rate 3000 --max-rate 5000 --top-ports 15094 --max-retries 3 --host-timeout 30 -oG $filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap --excludefile $nostrikes -iL $ips -d"
					fi	
					eval "$nudpa" >> $filepath/logs/misc-files/$typevar-discoscan-nmap-udp.log 2>> $filepath/logs/$typevar-errors.log &
				else
					echo -e "\e[33m [!] Using ZrE ngineer options for Nmap UDP discovery scan \e[0m"
					if [[ -f $filepath/logs/misc-files/$typevar-discoresults.txt ]]; then
						eval "nmap -sU --open $zreng_udpa_opts -oG $filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap --excludefile $nostrikes -iL $filepath/logs/misc-files/$typevar-discoresults.txt -d" >> $filepath/logs/misc-files/$typevar-discoscan-nmap-udp.log 2>> $filepath/logs/$typevar-errors.log &
					else
						eval "nmap -sU --open $zreng_udpa_opts -oG $filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap --excludefile $nostrikes -iL $ips -d" >> $filepath/logs/misc-files/$typevar-discoscan-nmap-udp.log 2>> $filepath/logs/$typevar-errors.log &
					fi
				fi
			else
				if [[ -f $filepath/logs/misc-files/$typevar-discoresults.txt ]]; then
					#15094 top ports is 99% effective. Reference this chart for --top-port number effectiveness: https://nmap.org/book/performance-port-selection.html
					nudpa="nmap -v -Pn -sU --open --min-rate 3000 --max-rate 5000 --top-ports 15094 --max-retries 3 --host-timeout 30 -oG $filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap --excludefile $nostrikes -iL $filepath/logs/misc-files/$typevar-discoresults.txt -d"
				else
					nudpa="nmap -v -Pn -sU --open --min-rate 3000 --max-rate 5000 --top-ports 15094 --max-retries 3 --host-timeout 30 -oG $filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap --excludefile $nostrikes -iL $ips -d"
				fi	
				eval "$nudpa" >> $filepath/logs/misc-files/$typevar-discoscan-nmap-udp.log 2>> $filepath/logs/$typevar-errors.log &
			fi
		fi
		pid=$!
		echo -ne "\e[36m [-] Discovering alive hosts and open UDP ports with Nmap... \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		echo ""
		#Status indicator
		periodicfile="$filepath/logs/misc-files/$typevar-discoscan-nmap-udp.log"
		contstatus="Scanning UDP ports"
		statusnmap
		#Error check and alert
		checked_cmd="nmap -Pn -sU --open --min-rate 3000 --max-rate 5000 --top-ports 15094 --max-retries 3 --host-timeout 30 -oG $filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap --excludefile $nostrikes -iL $filepath/logs/misc-files/$typevar-discoresults.txt -d"
		wait $pid
		exitstatus=$?
		errorcheck

		printf "\033[A\r\e[K\e[32m [+] Discovering alive hosts and open UDP ports with Nmap... Done\e[0m\n" | tee -a "$filepath/logs/$typevar-timestamps.log"
		#Carve out UDP IP addresses and put them into a file
		if [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ]; then
			awk 'NR==FNR{ips[$0];next} {for (ip in ips) if ($0 !~ ip) print}' $filepath/$typevar-100port-hosts-tcp.txt $filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap > $filepath/logs/misc-files/$typevar-discoscan-nmap-udp-nosusips.txt #Filter out hosts with more than 100 open tcp ports
			cat $filepath/logs/misc-files/$typevar-discoscan-nmap-udp-nosusips.txt | grep '/open' | cut -d ' ' -f2 >> $filepath/logs/misc-files/$typevar-discoresults.txt
		else
			cat "$filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap" | grep '/open' | cut -d ' ' -f2 >> $filepath/logs/misc-files/$typevar-discoresults.txt
		fi

		#Stage -- update
		echo "discovery-lists" > /tmp/zeroe/stage.zre
		stage="discovery-lists"
	fi

	#Stage discovery-lists -- start
	if [[ "$stage" == "discovery-lists" ]]; then
		#Remove firewall rule
		if ! [[ "$udp" == "y" && "$only_flag" == true ]]; then
			removefirewallrule
		fi
		
		#Make final list of ordered, unique alive hosts excluding sus ips
		cat $filepath/logs/misc-files/$typevar-discoresults.txt | sort -u | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n >> $filepath/$typevar-alives.txt
		cp $filepath/$typevar-alives.txt $filepath/$typevar-alives-tmp.txt
		cat $filepath/$typevar-alives-tmp.txt | sort -u | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n > $filepath/$typevar-alives.txt
		rm $filepath/$typevar-alives-tmp.txt

		#Generate list of all open ports
		if ! { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]]; }; then
			#echo '===========' > $filepath/$typevar-openPorts.txt
			#echo '    TCP' >> $filepath/$typevar-openPorts.txt
			#echo '===========' >> $filepath/$typevar-openPorts.txt
			cat $filepath/logs/misc-files/$typevar-discoscan-masscan-tcp-nosusips.txt | grep 'open' | cut -d ' ' -f5 | cut -d '/' -f1 | sort -u >> $filepath/rangetemp.txt
			rangeout="$filepath/logs/misc-files/$typevar-portsfornmap-tcp.txt"
			singleportstorange
			sed -i '/^[ \t]*$/d' "$rangeout" #Removes blank lines and lines that only contain spaces
			cat $filepath/logs/misc-files/$typevar-portsfornmap-tcp.txt > $filepath/$typevar-openPorts.txt
			sed -i 's/^/TCP\//' $filepath/$typevar-openPorts.txt
			#echo '' >> $filepath/$typevar-openPorts.txt
		fi
		if [ "$udp" = "y" ] || [ "$udp" = "yes" ] || [ "$U_opt" = true ]; then
			if [[ "$only_flag" == true ]]; then
				rm $filepath/$typevar-openPorts.txt 2>/dev/null
			#	echo '===========' > $filepath/$typevar-openPorts.txt
			#else
			#	echo '===========' >> $filepath/$typevar-openPorts.txt
			fi
			#echo '    UDP' >> $filepath/$typevar-openPorts.txt
			#echo '===========' >> $filepath/$typevar-openPorts.txt
			if [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ]; then
				cat $filepath/logs/misc-files/$typevar-discoscan-nmap-udp-nosusips.txt | grep '/open' | cut -d ' ' -f4 | cut -d '/' -f1 | sort -u >> $filepath/rangetemp.txt
			else
				cat $filepath/logs/misc-files/$typevar-discoscan-nmap-udp.gnmap | grep '/open' | cut -d ' ' -f4 | cut -d '/' -f1 | sort -u >> $filepath/rangetemp.txt
			fi
			rangeout="$filepath/logs/misc-files/$typevar-portsfornmap-udp.txt"
			singleportstorange
			sed -i '/^[ \t]*$/d' "$rangeout" #Removes blank lines and lines that only contain spaces
			cat $filepath/logs/misc-files/$typevar-portsfornmap-udp.txt >> $filepath/$typevar-openPorts.txt
			sed -i '/^TCP\//! s/^/UDP\//' $filepath/$typevar-openPorts.txt
		fi
		nessusports 2>/dev/null
		# Verify that the open ports file is not empty
		#if [[ ! -s "$filepath/$typevar-openPorts.txt" ]]; then
		#    echo -e "\e[33m [!] No open ports detected on discovered hosts -- exiting Zero-E... \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		#    zrecleanup
		#	exit 1
		#fi

		#Status update
		alivesandportscheck
		if [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ] && [ -s "$filepath/$typevar-100port-hosts-udp.txt" ]; then
			echo -e "\e[33m [!] Excluding potential deception or firewall-protected hosts showing more than 100 open TCP/UDP ports -- recommend inquiring about hosts in $typevar-100port-hosts-tcp.txt and $typevar-100port-hosts-udp.txt \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		elif [ -s "$filepath/$typevar-100port-hosts-tcp.txt" ]; then
			echo -e "\e[33m [!] Excluding potential deception or firewall-protected hosts showing more than 100 open TCP ports -- recommend inquiring about hosts in $typevar-100port-hosts-tcp.txt \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		elif [ -s "$filepath/$typevar-100port-hosts-udp.txt" ]; then
			echo -e "\e[33m [!] Excluding potential deception or firewall-protected hosts showing more than 100 open UDP ports -- recommend inquiring about hosts in $typevar-100port-hosts-udp.txt \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		fi
		echo -e "\e[33m [!] Generated files for Nessus vulnerability scans -- Hosts: $typevar-alives.txt | Ports: $typevar-portsForNessus.txt \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
	
		#Stage -- update
		if [[ "$only_flag" != true && "$stage_cont" == true ]]; then
			echo "services-tcp" > /tmp/zeroe/stage.zre
			stage="services-tcp"
		elif { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]] && [[ "$stage_cont" == true ]]; }; then
			echo "services-udp" > /tmp/zeroe/stage.zre
			stage="services-udp"
		fi
	
	fi

	#Stage -- start
	if [[ "$stage" == "services-tcp" ]]; then
		#Nmap TCP service scans
		ntscan="nmap -sC -sV -Pn -O -p $(cat $filepath/logs/misc-files/$typevar-portsfornmap-tcp.txt | paste -sd "," -) --open --reason -oA $filepath/$typevar-tcp-servicescan-results --excludefile $nostrikes -iL $filepath/$typevar-alives.txt"
		echo "ntscan=\"$ntscan\"" >> /tmp/zeroe/vars.zre
		if grep -q "\S" "$filepath/logs/misc-files/$typevar-portsfornmap-tcp.txt"; then
			if [[ "$resume" = "y" ]]; then
				resume=''
				echo -e "\e[36m [-] Resuming TCP service scans \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				echo -e "\e[36m     Using options from resumed scan \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				nmap --resume $filepath/$typevar-tcp-servicescan-results.gnmap 1>/dev/null 2>>$filepath/logs/$typevar-errors.log &
			else
				if [[ "$ngineer_mode" == true ]]; then
					if [[ "$ngineer_tcps_default" == true ]]; then	
						eval "$ntscan -v" 1>/dev/null 2>>$filepath/logs/$typevar-errors.log &
					else
						echo -e "\e[33m [!] Using ZrE ngineer options for Nmap TCP service scan \e[0m"
						eval "nmap $zreng_tcps_opts -sV -Pn -p $(cat $filepath/logs/misc-files/$typevar-portsfornmap-tcp.txt | paste -sd "," -) -oA $filepath/$typevar-tcp-servicescan-results --excludefile $nostrikes -iL $filepath/$typevar-alives.txt" 1>/dev/null 2>>$filepath/logs/$typevar-errors.log &
					fi
				else
					eval "$ntscan -v" 1>/dev/null 2>>$filepath/logs/$typevar-errors.log &
				fi
			fi
			pid=$!
			echo -e "\e[36m [-] Scanning services on open TCP ports of alive hosts with Nmap -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			#Status indicator
			periodicfile="$filepath/$typevar-tcp-servicescan-results.nmap"
			contstatus="Scanning TCP ports"
			statusnmap
			#Error check and alert
			checked_cmd="$ntscan"
			wait $pid
			exitstatus=$?
			if [ $exitstatus -eq 0 ]; then
				printf "\r%-${#indicator}s\r" "" #Clears status indicator line
				if [ "$udp" = "y" ] || [ "$udp" = "yes" ] || [ "$U_opt" = true ]; then
					echo -e "\e[32m [+] Nmap TCP service scan complete, results saved as $typevar-tcp-servicescan-results -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
					#echo -e "\e[33m [!] Start working with TCP scan results. UDP scans may take a while, depending on the amount of hosts and ports. \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				else
					echo -e "\e[32m [+] Nmap TCP service scan complete, results saved as $typevar-tcp-servicescan-results -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				fi
			else
				printf "\r%-${#indicator}s\r" "" #Clears status indicator line
				errorcheck
			fi

			genwindowshostlist_inscript
			listiptohostname_inscript
			parsegrepnmap_inscript=true
			parsegrepnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 139,445,137,138 "$filepath/analysis/$typevar-smbHosts.txt"
			parsegrepnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 80,443,8080,8443,8000,8008,8888 "$filepath/analysis/$typevar-httpHosts.txt"
			parsegrepnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 22,23,3389,5985,5986,5900,5800,1494,5631,5632 "$filepath/analysis/$typevar-remoteAccessHosts.txt"
			parsegrepnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 1723,1194 "$filepath/analysis/$typevar-vpnHosts.txt"
			parsegrepnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 20,21,22,69,111,873,990,2049,3260 "$filepath/analysis/$typevar-fileshareHosts.txt"
			parsegrepnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 3306,5432,1433,1521 "$filepath/analysis/$typevar-databaseHosts.txt"
			parsegrepnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 25,465,587,143,993,110,995 "$filepath/analysis/$typevar-emailHosts.txt"
			parsegrepnmap "$filepath/$typevar-tcp-servicescan-results.gnmap" 389,636 "$filepath/analysis/$typevar-ldapHosts.txt"
		else
			echo -e "\e[33m [!] No open TCP ports detected -- TCP service scans skipped \e[0m" | tee -a $filepath/logs/$typevar-timestamps.log
		fi

		#Stage -- update
		if { [ "$udp" = "y" ] || [ "$udp" = "yes" ] || [ "$U_opt" = true ]; } && [[ "$stage_cont" == true ]]; then
			echo "services-udp" > /tmp/zeroe/stage.zre
			stage="services-udp"
		fi
	
	fi

	#Stage -- start
	if [[ "$stage" == "services-udp" ]] && [[ "$udp" = "y" || "$udp" = "yes" || "$U_opt" = true ]]; then
		#Nmap UDP service scans
		nsudp="nmap -v -sU -Pn -sV --open --min-rate 1000 --max-rate 3000 --reason -p $(cat $filepath/logs/misc-files/$typevar-portsfornmap-udp.txt | paste -sd "," -) -oA $filepath/$typevar-udp-servicescan-results --excludefile $nostrikes -iL $filepath/$typevar-alives.txt"
		if grep -q "\S" "$filepath/logs/misc-files/$typevar-portsfornmap-udp.txt"; then
			if [[ "$resume" = "y" ]]; then
				resume=''
				echo -e "\e[36m [-] Resuming UDP service scans \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				echo -e "\e[36m     Using options from resumed scan \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
				nmap --resume $filepath/$typevar-udp-servicescan-results.gnmap 1>/dev/null 2>>$filepath/logs/$typevar-errors.log &
			else
				if [[ "$ngineer_mode" == true ]]; then
					if [[ "$ngineer_udps_default" == true ]]; then	
						eval "$nsudp" 1>/dev/null 2>>$filepath/logs/$typevar-errors.log &
					else
						echo -e "\e[33m [!] Using ZrE ngineer options for Nmap UDP service scan \e[0m"
						eval "nmap $zreng_udps_opts -sU -sV -Pn --reason -p $(cat $filepath/logs/misc-files/$typevar-portsfornmap-udp.txt | paste -sd "," -) -oA $filepath/$typevar-udp-servicescan-results --excludefile $nostrikes -iL $filepath/$typevar-alives.txt" 1>/dev/null 2>>$filepath/logs/$typevar-errors.log &
					fi
				else
					eval "$nsudp -v" 1>/dev/null 2>>$filepath/logs/$typevar-errors.log &
				fi
			fi
			pid=$!
			echo -e "\e[36m [-] Scanning services on open UDP ports of alive hosts with Nmap -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			#Status indicator
			periodicfile="$filepath/$typevar-udp-servicescan-results.nmap"
			contstatus="Scanning UDP ports"
			statusnmap
			#Error check and alert
			checked_cmd="nmap -v -sU -Pn -sV --open --min-rate 1000 --max-rate 3000 --reason -p $(cat $filepath/logs/misc-files/$typevar-portsfornmap-udp.txt | paste -sd "," -) -oA $filepath/$typevar-udp-servicescan-results --excludefile $nostrikes -iL $filepath/$typevar-alives.txt"
			wait $pid
			exitstatus=$?
			if [ $exitstatus -eq 0 ]; then
				printf "\r%-${#indicator}s\r" "" #Clears status indicator line
				echo -e "\e[32m [+] Nmap UDP service scan complete, results saved as $typevar-udp-servicescan-results -- $(date) \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
			else
				printf "\r%-${#indicator}s\r" "" #Clears status indicator line
				errorcheck
			fi

			genwindowshostlist_inscript
			listiptohostname_inscript
		else
			echo -e "\e[33m [!] No open UDP ports detected -- UDP service scans skipped \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
		fi
	fi

	#Stage -- start
	#if [[ "$stage" == "methodology" ]] && ! { [[ "$udp" == "y" ]] && [[ "$only_flag" == true ]]; }; then		
	#fi #Stage end

	#fi
	if [[ "$firewallset" = true ]]; then
		removefirewallrule
	fi
	echo -e "\e[35m [=] Zero-E completed -- happy hacking! \e[0m" | tee -a "$filepath/logs/$typevar-timestamps.log"
	zrecleanup
fi